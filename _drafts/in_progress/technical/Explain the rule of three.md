Explain the rule of three

If a class requires a user-defined destructor, a user-defined copy constructor, or a user-defined copy assignment operator, it almost certainly requires all three.

When you return or pass an object by value, you manipulate a container, etc., these member functions will be called. If they are not user-defined, they are generated by the compiler (since C++98).

Since C++98 the compiler tries to generate 
- a default constructor (`T()`), that calls the default constructor of each class member and base class
-a copy constructor (`T(const T& other)`), that calls a copy constructor on each member and base class
- a copy assignment operator (`T& operator=(const T& other)`), that calls a copy assignment operator on each class member and base class
- the destructor ~T(), that calls the destructor of each class member and base class. Note that this default-generated destructor is never virtual (unless it is for a class inheriting from one that has a virtual destructor).

In case, you have a class holding on a raw or smart pointer, a file descriptor, database connection, or other types managing resources, there is a fair chance that the generated functions would be incorrect and you should implement them by hand.

And here comes the rule of three, if you implement by hand either the copy consturctor, the copy assignment operator or the destructor, the compiler will not generate those that you didn't write. So if you need to write any of these three, the assumption is that you'll need the rest as well.

This is the rule of three introduced by C++98 and tomorrow will move on to the rule of 5.

References
- [C++ Reference](https://en.cppreference.com/w/cpp/language/rule_of_three)
- [Fluent C++](https://www.fluentcpp.com/2019/04/19/compiler-generated-functions-rule-of-three-and-rule-of-five/)
- [Modernes C++](https://www.modernescpp.com/index.php/c-core-guidelines-constructors-assignments-and-desctructors)


Explain the rule of five

Alright, yesterday we talked about the rule of three. Do you remember what it was about?

Let's recap.

If you implement by hand either the copy consturctor, the copy assignment operator or the destructor, the compiler will not generate those that you didn't write. It's because the compiler assumes that if you'd have to implement on of them, it's almost for sure that you'd need the others too.

Rule of three was introduced by C++98, and rule of five was introduced by C++11.

What's that extra two?

It's about move semnatics that was introduced by C++11. So if you implement by hand any of the following special functions, then none of the others will be generated. You have to take care of implementing all of them:

- a copy constructor: `T(const T&)`
- a copy assignment: `operator=(const T&)`
- a move constructor: `T(X&&)`
- a move assignment: `operator=(T&&)`
- a destructor: `~T()` 

Tomorrow will move on to the rule of zero.

References
- [C++ Reference](https://en.cppreference.com/w/cpp/language/rule_of_three)
- [Fluent C++](https://www.fluentcpp.com/2019/04/19/compiler-generated-functions-rule-of-three-and-rule-of-five/)
- [Modernes C++](https://www.modernescpp.com/index.php/c-core-guidelines-constructors-assignments-and-desctructors)


**Explain the rule of five**

The last two days, we talked about the rule three introduced by C++98 and then about the rule of five which was complemented by the move semantics introduced by C++11.

Let's repeat the rule of five:

If you implement by hand any of the following special functions, then none of the others will be generated. You have to take care of implementing all of them:

- a copy constructor: `T(const T&)`
- a copy assignment: `operator=(const T&)`
- a move constructor: `T(X&&)`
- a move assignment: `operator=(T&&)`
- a destructor: `~T()` 

Today we finish the mini series of these rules with the short episode of the rule of zero.

It's the nick name of one the rules defined by the C++ Core Guidelines:

> [C.20: If you can avoid defining default operations, do](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-zero)

If all the members have all their special functions, you're done, you don't need to define any, zero.

class MyClass {
public:
    // ... no default operations declared
private:
    std::string name;
    std::map<int, int> rep;
};

MyClass mc;        // default construct
MyClass mc2 {nm};  // copy construct

As both std::map and std::string have all the special functions, none is needed in `MyClass`

The idea is that a class needs to declare any of the special functoins, then it should deal exclusively with ownership and other classes shouldn't decalre these specail functions.

So keep in mind, that if you need any of the special functions, implement all of them, but try not to need them at the first place.

References
- [C++ Reference](https://en.cppreference.com/w/cpp/language/rule_of_three)
- [Fluent C++](https://www.fluentcpp.com/2019/04/23/the-rule-of-zero-zero-constructor-zero-calorie/)
- [Modernes C++](https://www.modernescpp.com/index.php/c-core-guidelines-constructors-assignments-and-desctructors)

