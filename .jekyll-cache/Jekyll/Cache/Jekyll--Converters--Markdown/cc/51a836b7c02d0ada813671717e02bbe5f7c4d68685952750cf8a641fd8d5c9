I"Šl<p>In this next part of <a href="http://sandordargo.com/blog/2019/01/30/stl-algos-intro">the big STL algorithm tutorial</a>, we will discover the 2 modifying sequence algorithms that will help you get unique elements of a container:
<!--more--></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unique</code></li>
  <li><code class="language-plaintext highlighter-rouge">unique_copy</code></li>
</ul>

<p>Letâ€™s get started!</p>

<h2 id="unique"><code class="language-plaintext highlighter-rouge">unique</code></h2>

<p><code class="language-plaintext highlighter-rouge">unique</code> - and as a matter of fact <code class="language-plaintext highlighter-rouge">unique_copy</code> - could have been implemented as two algorithms, just like <code class="language-plaintext highlighter-rouge">remove</code> and <code class="language-plaintext highlighter-rouge">remove_if</code> are two different algorithms.</p>

<p>Consistency is not the strongest feature of the <code class="language-plaintext highlighter-rouge">&lt;algortihms&gt;</code> header.</p>

<p>In this case, we simply have two separate overloaded signatures, but letâ€™s go on the goal of this algorithm.</p>

<p><code class="language-plaintext highlighter-rouge">unique</code> will remove all the duplicated elements from a container. But only if they are consecutive. In case, you have two identical elements that are not placed next to each other, both supposed to be kept. But we are going to check that.</p>

<p>The return value is the same in both cases, it points at the new <code class="language-plaintext highlighter-rouge">end()</code> of the container after the duplicate ones were moved past the new end.</p>

<p><a href="http://coliru.stacked-crooked.com/a/106b2cfee74de5e7">In the first example</a>, weâ€™ll use the simpler signature where we only pass in an input range defined by the usual two iterators pointing in the beginning and the end of the range.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span><span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Original values: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;});</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> 
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"size: "</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", capacity: "</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="k">auto</span> <span class="n">oldEnd</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="k">auto</span> <span class="n">newEnd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"same values are only removed if they are next to each other:"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">newEnd</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;});</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> 
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="s">"oldEnd == newEnd? :"</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">oldEnd</span> <span class="o">==</span> <span class="n">newEnd</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"In fact, the end hasn't changed. oldEnd == numbers.end(): "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">oldEnd</span> <span class="o">==</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"number of elements removed: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">newEnd</span><span class="p">,</span> <span class="n">oldEnd</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Though if you use the end, stranfe results are there..."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">oldEnd</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;});</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> 
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"size: "</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", capacity: "</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", these values haven't changed"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">numbers</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">newEnd</span><span class="p">,</span> <span class="n">oldEnd</span><span class="p">);</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">numbers</span><span class="p">.</span><span class="n">shrink_to_fit</span><span class="p">();</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"size: "</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", capacity: "</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", we should erase what is between the return value of unique() and the old end"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>An interesting fact you might notice is that although the end of the vector has not <code class="language-plaintext highlighter-rouge">changed numbers.end()</code> is the same before and after calling <code class="language-plaintext highlighter-rouge">std::unique()</code>, what we have between the returned iterator and the (original) end has become meaningless. We could also say it is dangerous to use.</p>

<p>In fact, this makes perfect sense if we remind ourselves of how the STL is designed. Algorithms do not operate on collections, but on iterators. <code class="language-plaintext highlighter-rouge">std::unique</code> moves elements around each other, but it doesnâ€™t remove anything from the underlying collection. Thatâ€™s the exact same reason why you cannot delete elements with <code class="language-plaintext highlighter-rouge">std::remove</code>, but you have to use the <a href="https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom">remove-erase idiom</a>.</p>

<p>So, Iâ€™d say that if we want to use this in-place <code class="language-plaintext highlighter-rouge">unique</code> algorithm, we should never use that container as a whole anymore. Either we take care of removing the elements beyond the returned iterator or we donâ€™t use it anymore.</p>

<p>If we want to reuse the original container, itâ€™s better to use <code class="language-plaintext highlighter-rouge">std::unique_copy</code>, but before, letâ€™s have a glance at the other version of <code class="language-plaintext highlighter-rouge">unique</code> where we can customize how elements are compared.</p>

<p>As an optional third argument, we can pass in a binary predicate. In more understandable English, you can pass in a function, function object, <a href="https://www.sandordargo.com/blog/2018/12/19/c++-lambda-expressions">lambda function</a> taking two arguments (two elements next to each other in the collection) returning a boolean. The predicate should return true if the two elements are to be considered the same (not unique), false otherwise.</p>

<p>Here is a short example.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="k">struct</span> <span class="nc">Person</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">phoneNumber</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="s">"John D Smith"</span><span class="p">,</span> <span class="s">"555-1234"</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="s">"John David Smith"</span><span class="p">,</span> <span class="s">"784-1234"</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="s">"Adam Jones"</span><span class="p">,</span> <span class="s">"555-7894"</span><span class="p">}</span> <span class="p">};</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span><span class="n">people</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">people</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">auto</span> <span class="n">rhs</span><span class="p">){</span> <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">id</span><span class="p">;</span> <span class="p">});</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">people</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">it</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;});</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In the above example, we have different Person objects that might reference the very same physical being. So the names can differ a little bit, the phone numbers might be still different, but still want to consider two persons as the same. In this particular example, we can use the <code class="language-plaintext highlighter-rouge">id</code> for that, we make our comparison based on the <code class="language-plaintext highlighter-rouge">id</code> field.</p>

<p>Otherwise, there are no differences between the two different signatures.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unique_copy</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">std::unique_copy</code> works similarly to <code class="language-plaintext highlighter-rouge">std::unique</code>, but while the latter moves values around in the original container, the former copies the values to be kept into a target container.</p>

<p>As we learned for other algorithms, the target container is passed after the input, and while the input is denoted by a pair of operators, the target is only by a single one. This target collection has to be big enough to accommodate all the elements. The simplest way is to use a <code class="language-plaintext highlighter-rouge">back_inserter</code> for this purpose.</p>

<p>The return value is the same as for <code class="language-plaintext highlighter-rouge">std::unique</code>, an iterator pointing at right after the last copied element. Does this make sense? It does. First, itâ€™s consistent with <code class="language-plaintext highlighter-rouge">unique</code> and second, passing an inserter iterator as the target is not the only option. Maybe you created a big enough target collection for all the values and there will be some free capacity in the target. By free capacity in this case we mean zero constructed elements. In that case, itâ€™s useful to see where the copied values end.</p>

<p>Letâ€™s see an example of this case.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span><span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">uniqueNumbers</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="err">Â </span> <span class="err">Â </span> 
<span class="err">Â </span> <span class="err">Â </span> <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_copy</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">uniqueNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Content of uniqueNumbers: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">uniqueNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">uniqueNumbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;});</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> 
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Content of uniqueNumbers until the returned iterator: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">uniqueNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">it</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;});</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It the above example we initialize the target vector with the size of the original one with contiguous duplicates. As such, after calling the <code class="language-plaintext highlighter-rouge">unique_copy</code> there will still zero-initialized elements in the target vector.</p>

<p>We should also see as a reminder that even though we called <code class="language-plaintext highlighter-rouge">unique_copy</code>, the copied elements are not necessarily unique, as only the neighbouring duplicates got removed - exactly as the contract of the <code class="language-plaintext highlighter-rouge">unique*</code> algorithms promises.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Today, we learned about <code class="language-plaintext highlighter-rouge">unique</code> and <code class="language-plaintext highlighter-rouge">unique_copy</code>, algorithms that remove duplicated items from a range if the duplicated values are next to each other. Thatâ€™s their biggest catch - that duplicated elements should be next to each other, but itâ€™s well documented.</p>

<p>Next time weâ€™ll learn about the algorithms that bring us some randomness. Stay tuned!</p>
:ET