I"êD<p>In this next part of <a href="http://sandordargo.com/blog/2019/01/30/stl-algos-intro">the big STL algorithm tutorial</a>, we will continue with 4 algorithms that either help us to rotate elements around a given element in the input range or they just shift elements around:
<!--more--></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">rotate</code></li>
  <li><code class="language-plaintext highlighter-rouge">rotate_copy</code></li>
  <li><code class="language-plaintext highlighter-rouge">shift_left</code> / <code class="language-plaintext highlighter-rouge">shift_right</code></li>
</ul>

<p>Up until now the meaning of the STL function names was pretty straightforward. Finding something or reversing a container doesnâ€™t need much explanation. But what the hell is rotating a container?</p>

<p>The simplest explanation I could come up with is the following. If you think you have a more understandable one, let me know in the comments.</p>

<p>To rotate a container by one simply means to take (or <code class="language-plaintext highlighter-rouge">pop</code>) its first element and put (or <code class="language-plaintext highlighter-rouge">push_back</code>) it back at the end of the container.</p>

<p>Here is an example:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> --><td class="rouge-code"><pre>// First rotation
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} -&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}
// Second rotation
{1, 2, 3, 4, 5, 6, 7, 8, 9, 0} -&gt; {2, 3, 4, 5, 6, 7, 8, 9, 0, 1}
// Third rotation
{2, 3, 4, 5, 6, 7, 8, 9, 0, 1} -&gt; {3, 4, 5, 6, 7, 8, 9, 0, 1, 2}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now that we know what rotating means, letâ€™s get started!</p>

<h2 id="rotate"><code class="language-plaintext highlighter-rouge">rotate</code></h2>

<p>In the STL we got used to defining the input container by two iterators, denoting the beginning and the end of the container we wish to operate on. Itâ€™s not the case for <code class="language-plaintext highlighter-rouge">rotate</code>. The first and the third(!) parameter is to pass in the iterators pointing at the first and last elements, what is the one in the middle for?</p>

<p>Itâ€™s also an iterator! It should point to the element that you want to be the new first element. So for example if you want to rotate by one, you could call it like this:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="err">Â </span><span class="n">std</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This also means that by using <code class="language-plaintext highlighter-rouge">rotate</code>, you donâ€™t define how many rotations you want to perform, but rather that you want to rotate until that middle parameter shows up at the beginning of the container.</p>

<p>Here is a complete example:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
<span class="err">Â </span> 
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">5</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="err">Â </span> 
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"numbers after rotation: "</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">;</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="err">Â </span> <span class="c1">// numbers after rotation: Â 5 6 7 8 9 0 1 2 3 4</span>
<span class="err">Â </span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>If you are interested in undefined behaviours caused by non-intended usage I encourage you to define another container and replace one of the parameters with an iterator pointing at another vector of ints.</p>

<p>Thatâ€™s basically the only surprise <code class="language-plaintext highlighter-rouge">rotate</code> can give you.</p>

<p>Itâ€™s worth noting that the signature slightly changed with C++11. Before, it was returning nothing, and since then it returns the iterator pointing to the element that now contains the value previously pointed by the first parameter.</p>

<h2 id="rotate_copy"><code class="language-plaintext highlighter-rouge">rotate_copy</code></h2>

<p>As usual, the STL provides us two types of the same algorithm - where it makes sense -, by default it modifies the passed in range: goodbye immutability, hello more optimal memory consumption; but usually there is another version where the algorithm gets a <code class="language-plaintext highlighter-rouge">_copy</code> suffix and an extra parameter.</p>

<p>When this second flavour is used, the input range goes unchanged and the results are copied to a new container. This new container is passed in only by denoting its beginning. Thus you have to make sure that either the output container is big enough to accommodate all the results or you have to pass it in as inserter. Most often this would mean <code class="language-plaintext highlighter-rouge">std::back_inserter</code>.</p>

<p>This is the case for <code class="language-plaintext highlighter-rouge">rotate</code>/<code class="language-plaintext highlighter-rouge">rotate_copy</code> as well. <code class="language-plaintext highlighter-rouge">rotate_copy</code> takes its first three parameters the same way as rotate (beginning of input, new first element after rotating, then end of input range) and then as an extra fourth element, we have to pass in the beginning of the output range.</p>

<p>Here is an example:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="err">Â </span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rotatedNumbers</span><span class="p">;</span>
<span class="err">Â </span> <span class="n">rotatedNumbers</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="err">Â </span> 
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">rotate_copy</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">5</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">rotatedNumbers</span><span class="p">));</span>
<span class="err">Â </span> 
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"rotatedNumbers: "</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">number</span> <span class="o">:</span> <span class="n">rotatedNumbers</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">;</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="err">Â </span> <span class="c1">// rotatedNumbers: Â 5 6 7 8 9 0 1 2 3 4</span>
<span class="err">Â </span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="shift_left--shift_right"><code class="language-plaintext highlighter-rouge">shift_left</code> / <code class="language-plaintext highlighter-rouge">shift_right</code></h2>

<p>These two are brand new algorithms added to the STL with C++20. When I first saw them, I had misconceptions. I thought that they could be the elementary operations of <code class="language-plaintext highlighter-rouge">std::rotate</code>, so basically rotating by one in a direction or the other. I was wrong. So what it is?</p>

<p>As usual, youâ€™ll send in the input range by specifying its beginning and its end and as an additional parameter, you can specify the number of positions to shift.</p>

<p>What does shift mean then? If you want to shift left by 1, it means that every element will be moved by 1 to the left! For right shifting, itâ€™s obviously to the right.</p>

<p><a href="https://en.cppreference.com/w/cpp/algorithm/shift">CppReference</a> says that if you try to shift by a bigger number than the length of the full input, nothing would happen. Thatâ€™s something I could validate on <a href="https://wandbox.org/">wandbox</a> with GCC 11 and C++2a. But it also says that nothing would happen if <code class="language-plaintext highlighter-rouge">n</code> is negative. In that case, I got a core dump. Implementation might change it the future, I guess. Anyway, this is C++2a, not C++20 yet.</p>

<p>What you also have to keep in mind is that if you shift left by one, you basically lose the first element (at position 0) in your input. So shifting by one to left and then one to the right, will not keep your range identitical to the original one:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> --><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">shift_left</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// {1, 2, 3, 4, 5, 6, 7, 8, 9, 9}</span>
<span class="n">std</span><span class="o">::</span><span class="n">shift_right</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// {1, 1, 2, 3, 4, 5, 6, 7, 8, 9}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Thatâ€™s the difference with rotate. What is taken from the beginning ofÂ the end is not put to the other end of the container, but itâ€™s just discarded.</p>

<p>But are the items copied or moved? Iâ€™d encourage you to try it. You can simply wrap the above integers into a small class and log in the special functions when they are called.</p>

<p>I made this experiment, and if your type supports move semantics, they will be used. Otherwise, copy assignments are used.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Today, we learned about 4 algorithms that help us to rotate/shift the elements around in a container. Probably rotating is more interesting. Elements are moved to the left and what we would drop, it gets pushed_back to the end. Probably the most readable way to use it is by expressing the second parameter with the beginning of the input container + the number of shifts/rotations by one you want to perform. But the most readable way might depend on your use case.</p>

<p>For some interesting real-life use cases,Â Iâ€™d invite you to watch <a href="http://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning">Sean Parentâ€™s talk from GoingNative 2013</a>.</p>

<p>Next time weâ€™ll learn about <code class="language-plaintext highlighter-rouge">shuffle</code>, <code class="language-plaintext highlighter-rouge">random_shuffle</code>, and <code class="language-plaintext highlighter-rouge">sample</code> algorithms. Stay tuned!</p>
:ET