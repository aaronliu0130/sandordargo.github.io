I"ç5<p>In this next part of <a href="http://sandordargo.com/blog/2019/01/30/stl-algos-intro">the big STL algorithm tutorial</a>, we will discover all the non-modifying sequence operations that we haven‚Äôt seen yet.
<!--more--></p>

<p>Namely, we are going to have a deeper look at the following functions:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">count</code></li>
  <li><code class="language-plaintext highlighter-rouge">count_if</code></li>
  <li><code class="language-plaintext highlighter-rouge">equal</code></li>
  <li><code class="language-plaintext highlighter-rouge">mismatch</code></li>
  <li><code class="language-plaintext highlighter-rouge">is_permutation</code></li>
</ul>

<h2 id="count"><code class="language-plaintext highlighter-rouge">count</code></h2>
<p>The name speaks for itself, right? <code class="language-plaintext highlighter-rouge">count</code> takes a range of iterators and as a third parameter, it takes a value that it‚Äôd look for in the passed in range. As simple as that</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  auto myvector = std::vector&lt;int&gt;{1, 2, 3, 1, 4, 5};
  auto count = std::count(myvector.begin(), myvector.end(), 1);
  std::cout &lt;&lt; "Number of occurences of '1' in myvector: " &lt;&lt; count;
  
  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Unsurprisingly the answer is 2.</p>

<h2 id="count_if"><code class="language-plaintext highlighter-rouge">count_if</code></h2>
<p><code class="language-plaintext highlighter-rouge">count_if</code> differs from <code class="language-plaintext highlighter-rouge">count</code> the same way as <code class="language-plaintext highlighter-rouge">find_if</code> differs from <code class="language-plaintext highlighter-rouge">find</code>. Just like <code class="language-plaintext highlighter-rouge">count</code> (or <code class="language-plaintext highlighter-rouge">find</code>) it takes a range of iterators, but instead of a value as a third parameter, it takes a unary predicate and returns how many times the predicate evaluates to <code class="language-plaintext highlighter-rouge">true</code> by passing to it each element of the list.</p>

<p>A unary predicate can be a function object, a pointer to a function or a lambda function. <a href="http://sandordargo.com/blog/2018/12/19/c++-lambda-expressions">It depends on your use-case which one you should use.</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  auto myvector = std::vector&lt;int&gt;{1, 2, 3, 1, 4, 5};
  auto count = std::count_if(myvector.begin(), myvector.end(), [](int number){return number % 2 == 0;});
  std::cout &lt;&lt; "Number of even numbers in myvector: " &lt;&lt; count;
  
  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this case, the answer will be again two. But while in or example for <code class="language-plaintext highlighter-rouge">count</code> number <code class="language-plaintext highlighter-rouge">1</code> was counted twice, here <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">4</code> were counted as even numbers.</p>

<h2 id="equal"><code class="language-plaintext highlighter-rouge">equal</code></h2>

<p><code class="language-plaintext highlighter-rouge">equal</code> function returns a boolean with its value depending on whether all the elements of two ranges are equal or not. That‚Äôs the simple explanation, but life can be a bit different.</p>

<p>With the constructor that takes only the parameters, it is definitely the case. The first two iterators define a range and the third parameter defines the start of another range. Let‚Äôs take a simple case, where we have two vectors with the same contents:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  auto myvector = std::vector&lt;int&gt;{1, 2, 3, 1, 4, 5};
  auto otherVector(myvector);
  if (std::equal(myvector.begin(), myvector.end(), otherVector.begin())) {
      std::cout &lt;&lt; "The two vectors are equal\n ";
  } else {
      std::cout &lt;&lt; "The two vectors are NOT equal\n ";
  }
  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Easy-peasy, our two vectors are equal. In our next example we insert an element at the beginning of the second vector and we try to ignore it from the comparison by not passing the <code class="language-plaintext highlighter-rouge">begin()</code> iterator, but an iterator of <code class="language-plaintext highlighter-rouge">begin()+1</code>. What should happen?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  auto myvector = std::vector&lt;int&gt;{1, 2, 3, 1, 4, 5};
  auto otherVector(myvector);
  otherVector.insert(otherVector.begin(),42);
  if (std::equal(myvector.begin(), myvector.end(), otherVector.begin()+1)) {
      std::cout &lt;&lt; "The two vectors are equal\n ";
  } else {
      std::cout &lt;&lt; "The two vectors are NOT equal\n ";
  }
  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We start a comparison after the mismatching element, so if in the second vector we have the same number of elements afterwards as in the original vector and these elements match, <code class="language-plaintext highlighter-rouge">equal()</code> will also say so.</p>

<p>So what is going to happen if insert the same element at the end of the vector and we start the comparison from the beginning?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  auto myvector = std::vector&lt;int&gt;{1, 2, 3, 1, 4, 5};
  auto otherVector(myvector);
  otherVector.push_back(42);
  if (std::equal(myvector.begin(), myvector.end(), otherVector.begin())) {
      std::cout &lt;&lt; "The two vectors are equal\n ";
  } else {
      std::cout &lt;&lt; "The two vectors are NOT equal\n ";
  }
  return 0;
}

</pre></td></tr></tbody></table></code></pre></div></div>

<p>Equal will return <code class="language-plaintext highlighter-rouge">true</code>! What? So what does equal do again? It checks if the first passed range is part of the second one starting from that specified point defined by the third parameter. It doesn‚Äôt check if two containers are equal or not. For that, you can simply compare two containers.</p>

<p>There is a second constructor through which it‚Äôs possible to pass a binary predicate as a comparator of the two ranges. Otherwise it works the same way.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  auto myvector = std::vector&lt;int&gt;{1, 2, 3, 1, 4, 5};
  auto otherVector(myvector);
  otherVector.push_back(42);
  if (std::equal(myvector.begin(), myvector.end(), otherVector.begin(), [](int i, int j){return i==j;})) {
      std::cout &lt;&lt; "The two vectors are equal\n ";
  } else {
      std::cout &lt;&lt; "The two vectors are NOT equal\n ";
  }
  return 0;
}

</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="mismatch"><code class="language-plaintext highlighter-rouge">mismatch</code></h2>

<p><code class="language-plaintext highlighter-rouge">mismatch</code> is quite similar to <code class="language-plaintext highlighter-rouge">equal</code>. It also exposes two constructors and you can choose among them based on the way you‚Äôd like to compare the two ranges that you pass in the same way as you did it for ‚Äòequal‚Äô.</p>

<p>The difference is that while <code class="language-plaintext highlighter-rouge">equal</code> returns an integer, mismatch returns a pair of iterators. An iterator to the first range and to the second one pointing at the positions of the first mismatch.</p>

<p>In case of failure, so in case of no mismatch, the iterator of the first range is points right after to its last element and the second iterator points to the second range at the same relative position as the first one. So in case the two ranges are equal, both points after the last element. When the first range is part of the second range, but the second range is longer, the second iterator points to the first element that is not in the first range.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  auto myvector = std::vector&lt;int&gt;{1, 2, 3, 4, 5};
  auto otherVector = std::vector&lt;int&gt;{1, 2, 3, 42, 5};
  auto result = std::mismatch(myvector.begin(), myvector.end(), otherVector.begin(), [](int i, int j){return i==j;});
  std::cout &lt;&lt; "Mismatching elements are " &lt;&lt; *result.first &lt;&lt; " and " &lt;&lt; *result.second &lt;&lt; "\n";
  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="is_permutation"><code class="language-plaintext highlighter-rouge">is_permutation</code></h2>

<p><code class="language-plaintext highlighter-rouge">is_permutation</code> is also similar to <code class="language-plaintext highlighter-rouge">equal</code>. It offers two constructors, both taking two ranges, the first one defined by its beginning and end while the other is only defined by its start point. And as we‚Äôve seen with <code class="language-plaintext highlighter-rouge">equal</code> and <code class="language-plaintext highlighter-rouge">mismatch</code>, <code class="language-plaintext highlighter-rouge">is_permutation</code> also accepts an optional binary predicate that is used to compare the elements of the first and second ranges.</p>

<p>Like <code class="language-plaintext highlighter-rouge">equal</code>, <code class="language-plaintext highlighter-rouge">is_permutation</code> also returns a boolean which will be <code class="language-plaintext highlighter-rouge">true</code> in case all the elements match. But for <code class="language-plaintext highlighter-rouge">is_permutation</code> the order doesn‚Äôt matter. It‚Äôll return <code class="language-plaintext highlighter-rouge">true</code> if the two queried ranges consist of the same elements regardless of their positions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  auto myvector = std::vector&lt;int&gt;{1, 2, 3, 1, 4, 5};
  auto otherVector(myvector);
  std::random_shuffle(otherVector.begin(), otherVector.end());
  if (std::is_permutation(myvector.begin(), myvector.end(), otherVector.begin())) {
      std::cout &lt;&lt; "The two vectors are permutations of each other\n ";
  } else {
      std::cout &lt;&lt; "The two vectors are NOT permutations of each other\n ";
  }
  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>More about random_shuffle in another post later, but given it‚Äôs name, you can safely assume that it will shuffle the elements of a vector.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, we finished discussing the non-modifying sequence operations of the <code class="language-plaintext highlighter-rouge">&lt;algorithm&gt;</code> header. We saw how <code class="language-plaintext highlighter-rouge">count</code>, <code class="language-plaintext highlighter-rouge">count_if</code>, <code class="language-plaintext highlighter-rouge">equal</code>, <code class="language-plaintext highlighter-rouge">mismatch</code> and <code class="language-plaintext highlighter-rouge">is_permutation</code> work.</p>

<p>Next time we‚Äôll start learning about the modifying sequence operations. Stay tuned!</p>
:ET