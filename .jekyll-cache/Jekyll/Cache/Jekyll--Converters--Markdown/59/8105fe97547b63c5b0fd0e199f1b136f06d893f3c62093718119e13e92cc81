I"éÅ<p>Once again we were practising <a href="https://williamdurand.fr/2013/06/03/object-calisthenics/">Object Calisthenics</a> during our weekly coding dojo. If you don‚Äôt know what it is about, I‚Äôd advise you to check out <a href="https://williamdurand.fr/2013/06/03/object-calisthenics/">the rules</a>. You might not want to apply all of them for your production code, but at least some parts of the constraints could be extremely useful.
<!--more--></p>

<p>The rules that are giving the biggest challenge are the ones prohibiting the use of primitive values and containers naked. It means that all numbers, booleans, even strings and all the containers must be wrapped into an object and by the way, you shall not use any getters. In other words, the rules say that one should use strong types that clearly represents the concepts you want to model. You won‚Äôt use an <code class="language-plaintext highlighter-rouge">int</code> plain old type, but you‚Äôll rather introduce an <code class="language-plaintext highlighter-rouge">Age</code> class. You‚Äôll not use a simple <code class="language-plaintext highlighter-rouge">string</code> but rather <code class="language-plaintext highlighter-rouge">Name</code>. Or you‚Äôll not use a <code class="language-plaintext highlighter-rouge">vector</code> of <code class="language-plaintext highlighter-rouge">Players</code> but rather a <code class="language-plaintext highlighter-rouge">Team</code>.</p>

<p>This requires patience and practice. It is not as difficult as it might sound, but it definitely takes time to write all the boilerplate. On the other hand, in a few sessions for sure, you‚Äôll learn well how to override the different operators.</p>

<p>But let‚Äôs not forget that we are humans and we tend to move towards the least resistance. We look for shortcuts, smart solutions so that we still comply with the rules.</p>

<p>Once someone had the idea of inheriting from <code class="language-plaintext highlighter-rouge">std::vector</code>. Next time someone else tried, and the last time everyone did. Did it work well? Actually, it was not so bad. We discovered some syntactic rules that we were not aware of - C++ 11 is still new‚Ä¶ - but at the retrospective part, one of our junior hires said that it‚Äôs not a good idea to inherit from a <code class="language-plaintext highlighter-rouge">vector</code>.</p>

<p>Why? - I asked. She couldn‚Äôt reply more than <em>because some people said so on StackOverflow</em>.</p>

<p>I think this is not a great argument even if those people are right. Anyone can share his or her dogmatic views on the internet presenting it as the one and only truth of life - not just in technology. Before taking something for granted, we‚Äôd better understand what is behind.</p>

<p>Here is my attempt to explain how to use strong types of containers in C++ what are the pros and cons of each approach. Feel free to share your ideas in the comments section.</p>

<h2 id="what-is-a-strong-type">What is a strong type?</h2>

<p>First, let‚Äôs repeat what is a strong type. A strong type carries extra information, a <a href="https://www.fluentcpp.com/2016/12/08/strong-types-for-strong-interfaces/">specific meaning through its name</a>. While you can use booleans or strings everywhere, the only way they carry can carry meaning is the name of their instances.</p>

<p>If you look at this function signature, perhaps you think it‚Äôs alright:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Car</span><span class="o">::</span><span class="n">Car</span><span class="p">(</span><span class="n">unit32_t</span> <span class="n">horsepower</span><span class="p">,</span> <span class="n">unit32_t</span> <span class="n">numberOfDoors</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isAutomatic</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isElectric</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It has relatively good names, so what is the issue?</p>

<p>Let‚Äôs look at a possible instantiation.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">myCar</span><span class="p">{</span><span class="n">Car</span><span class="p">(</span><span class="mi">96</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">)};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Yeah, what? God knows‚Ä¶ And you if you take your time to actually look up the constructor and do the mind mapping. Some IDEs can help you visualizing parameter names, like if they were Python-style named parameters, but you shouldn‚Äôt rely on that.</p>

<p>Of course you could name the variables as such:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">constexpr</span> <span class="n">unit32_t</span> <span class="n">horsepower</span> <span class="o">=</span> <span class="mi">96</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="n">unit32_t</span> <span class="n">numberOfDoors</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">isAutomatic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">isElectric</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">myCar</span><span class="p">{</span><span class="n">Car</span><span class="p">(</span><span class="n">horsepower</span><span class="p">,</span> <span class="n">numberOfDoors</span><span class="p">,</span> <span class="n">isAutomatic</span><span class="p">,</span> <span class="n">isElectric</span><span class="p">)};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now you understand right away which variable represents what. You have to look a few lines upper to actually get the values, but everything is in sight. On the other hand, this requires will-power. Discipline. You cannot enforce it. Well, you can be a thorough code reviewer, but you won‚Äôt catch every case and anyway, you won‚Äôt be there all the type.</p>

<p>Strong typing is there to help you!</p>

<p>Imagine the signature as such:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Car</span><span class="o">::</span><span class="n">Car</span><span class="p">(</span><span class="n">Horsepower</span> <span class="n">hp</span><span class="p">,</span> <span class="n">DoorsNumber</span> <span class="n">numberOfDoors</span><span class="p">,</span> <span class="n">Transmission</span> <span class="n">transmission</span><span class="p">,</span> <span class="n">Fuel</span> <span class="n">fuel</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now the previous instantiation could look like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">myCar</span> <span class="o">=</span> <span class="n">Car</span><span class="p">{</span><span class="n">Horsepower</span><span class="p">{</span><span class="mi">98u</span><span class="p">},</span> <span class="n">DoorsNumber</span><span class="p">{</span><span class="mi">4u</span><span class="p">},</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Automatic</span><span class="p">,</span> <span class="n">Fuel</span><span class="o">::</span><span class="n">Gasoline</span><span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This version is longer and more verbose than the original version - which was quite unreadable -, but much shorter than the one where introduced well named helpers for each parameter</p>

<p>So one advantage of strong typing is readability and one other is safety. It‚Äôs much harder to mix up values. In the previous examples, you could have easily mixed up door numbers with performance, but by using strong typing, that would actually lead to a compilation error.</p>

<h2 id="strongly-typed-containers">Strongly typed containers</h2>

<p>Now that we know what strong typing is about, let‚Äôs see the different options to create a strongly typed container. We are going to start with the option we were experimenting at our coding dojo, the one that inspired this article.</p>

<h3 id="inheriting-from-a-vector">Inheriting from a vector</h3>

<p>It‚Äôs soo easy! You just publicly inherit from the <code class="language-plaintext highlighter-rouge">std::vector</code> and you either implement the constructors you‚Äôd need or you declare that you want to use the ones from the base class. This latter is even easier than the former.</p>

<p>Let‚Äôs see an example:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Squad</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Player</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Player</span><span class="o">&gt;::</span><span class="n">vector</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It‚Äôs simple, it‚Äôs readable, yet you‚Äôll find a lot of people at different forums who will tell you that this is the eighth deadly sin and if you are a serious developer you should avoid it at all costs.</p>

<p>Why do they say so?</p>

<p>There are two main arguments. One is that algorithms and containers are well-separated concerns in the STL. The other one is about the lack of virtual constructors.</p>

<p>But are these valid concerns?</p>

<p>They might be. It depends.</p>

<p>Let‚Äôs start with the one about the lack of a virtual destructor. It seems more practical.</p>

<p>Indeed, the lack of a virtual destructor might lead to undefined behaviour and a memory leak. Both can be serious issues, but the undefined behaviour is worse because it can not just lead to crashes but even to difficult to detect memory corruption eventually leading to strange application behaviour.</p>

<p>But the lack of undefined behaviour doesn‚Äôt lead to undefined behaviour and memory leak by default, you have to use your derived class in such a way.</p>

<p>If you delete an object through a pointer to a base class that has a non-virtual destructor, you have to face the consequences of undefined behaviour. Plus if the derived object introduces new member variables, you‚Äôll also have some nice memory leak. But again, that‚Äôs the smaller problem.</p>

<p>On the other hand, this also means that those who rigidly oppose inheriting from <code class="language-plaintext highlighter-rouge">std::vector</code> - or from any class without a virtual destructor - because of undefined behaviour and memory leaks, are¬†not right.</p>

<p>If you know what you are doing, and you only use this inheritance to introduce a strongly typed vector, not to introduce polymorphic behaviour and additional states to your container, you are perfectly fine to use this technique. Simply, you have to respect the limitations, though probably this is not the best strategy to use in case of a public library. But more on that just in a second.</p>

<p>So the other main concern is that you might mix containers and algorithms in your new object. And it‚Äôs bad because the creators of the STL said so. And so what? <a href="https://en.wikipedia.org/wiki/Alexander_Stepanov">Alexander Stepanov</a> who originally designed the STL and the other who have been later contributed to it are smart people and there is a fair chance that they are better programmers than most of us. They designed functions, objects that are widely used in the C++ community. I think it‚Äôs okay to say that they are used by everyone.</p>

<p>Most probably we are not working under such constraints, we are not preparing something for the whole C++ community. We are working on specific applications with very strict constraints. Our code will not be reused as such. Never. We don‚Äôt work on generic libraries, we work on one-off business applications.</p>

<p>As long as we keep our code clean (whatever it means), it‚Äôs perfectly fine to provide a non-generic solution.</p>

<p>As a conclusion, we can say that for application usage, inheriting from containers in order to provide strong typing is fine, as long as you don‚Äôt start to play with polymorphism.</p>

<p>But we have other options to choose from.</p>

<h2 id="creating-an-alias">Creating an alias</h2>

<p>We can create an alias either by using the <code class="language-plaintext highlighter-rouge">using</code> keyword or with the good old <code class="language-plaintext highlighter-rouge">typedef</code>. Essentially the next two statements are the same:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">using</span> <span class="n">Team</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Player</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Player</span><span class="o">&gt;</span> <span class="n">Team</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This is probably the simplest solution to get container types with descriptive type names. The only problem is that they are not so strong.</p>

<p>A <code class="language-plaintext highlighter-rouge">Team</code> in the above example is literally the same as a vector of Players. In other words, you can whatever list of players in where a <code class="language-plaintext highlighter-rouge">Team</code> is expected, it can even be a vector of players without a team. That‚Äôs not a team, right?</p>

<p>So while this option requires the least amount of typing, it doesn‚Äôt provide any safety, just a bit of extra readability.</p>

<p>Let‚Äôs move to our next option.</p>

<h3 id="private-inheritance">Private inheritance</h3>

<p>Instead of the original idea which was to use public inheritance, we can use private inheritance to get our strong type. <a href="XXXXXXXXXXXXXX">As discussed a few weeks ago</a> with private inheritance, you‚Äôll only inherit the implementation from the base class, but not the API as it basically represents a <code class="language-plaintext highlighter-rouge">has-a</code> relationship instead of an <code class="language-plaintext highlighter-rouge">is-a</code> one.</p>

<p>This means that if you inherit privately from <code class="language-plaintext highlighter-rouge">std::vector</code> no functionality of the underlying container class will be exposed to the users of the new derived class.</p>

<p>Private inheritance eliminates the problem of a missing virtual destructor because it wouldn‚Äôt even be possible to refer to the derived class with a base class pointer. That‚Äôs how private inheritance works.</p>

<p>On the other hand, you‚Äôll have to type a lot as you‚Äôll have to expose manually the needed API of the base class. Depending on whether you use at least C++11 you might be able to use the <code class="language-plaintext highlighter-rouge">using</code> keyword. Here are the two ways to forward the calls, or in other words, to expose the API:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Team</span> <span class="o">:</span> <span class="k">private</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Player</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="err">¬†</span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Player</span><span class="o">&gt;::</span><span class="n">push_back</span><span class="p">;</span>
<span class="err">¬†</span><span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
<span class="err">¬†</span> <span class="err">¬†</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Player</span><span class="o">&gt;::</span><span class="n">empty</span><span class="p">();</span>
<span class="err">¬†</span><span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>I strongly recommend the usage of the <code class="language-plaintext highlighter-rouge">using</code> keyword. It requires less typing and there are fewer opportunities to make mistakes, especially if you think about const correctness.</p>

<p>The necessity of manually exposing the underlying vector‚Äôs API has a non-expected side effect. You‚Äôll actually expose only what you need and you‚Äôll have a leaner API.</p>

<h3 id="composition">Composition</h3>

<p>While using private inheritance has its pros we also have to keep in mind what <a href="https://isocpp.org/wiki/faq/private-inheritance#priv-inherit-vs-compos">the C++ standard says about it</a>:</p>

<blockquote>
  <p><em>Use composition when you can, private inheritance when you have to.</em></p>
</blockquote>

<p>But do we <strong>have</strong> to use private inheritance to have a strongly typed container?</p>

<p>The simple answer is no, we don‚Äôt.</p>

<p>We can follow the good old <em>follow composition over inheritance rule</em> and do something like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Team</span>
<span class="p">{</span>
<span class="nl">public:</span>
<span class="err">¬†</span> 
<span class="err">¬†</span> <span class="n">Team</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="p">}</span>

<span class="nl">private:</span>
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">people</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>You have to do almost the same as you‚Äôd with private inheritance pre C++11. It‚Äôs a bit verbose and you have to pay a lot of attention to what should be const and what is not, but apart from it, there is no big difference.</p>

<p>What is a bit cumbersome is the long return type names everywhere.</p>

<p>Let‚Äôs make it a bit simpler to read:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Team</span>
<span class="p">{</span>
<span class="err">¬†</span> <span class="k">using</span> <span class="n">Team_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nl">public:</span>
<span class="err">¬†</span> <span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">;</span>
<span class="err">¬†</span> <span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="p">;</span>

<span class="err">¬†</span> <span class="n">Team</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="err">¬†</span> <span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">people</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="kt">void</span> <span class="n">push_back</span> <span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">)</span> <span class="p">{</span><span class="n">people</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">person</span><span class="p">);}</span>

<span class="nl">private:</span>
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">people</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We introduced a private alias for the container of persons also two public ones for the iterators. For the sake of the example, I also added implemented the push_back method.</p>

<p>Here is very simple example how you can <code class="language-plaintext highlighter-rouge">Team</code> now. Here is the full example.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="err">¬†</span> <span class="err">¬†</span> <span class="n">Person</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>
<span class="err">¬†</span> <span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">{};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Team</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="err">¬†</span> 
<span class="err">¬†</span> <span class="n">Team</span> <span class="n">team</span><span class="p">;</span>
<span class="err">¬†</span> <span class="n">team</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Person</span><span class="p">{</span><span class="s">"Messi"</span><span class="p">});</span>
<span class="err">¬†</span> <span class="n">team</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Person</span><span class="p">{</span><span class="s">"Suarez"</span><span class="p">});</span>
<span class="err">¬†</span> <span class="n">team</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Person</span><span class="p">{</span><span class="s">"Griezmann"</span><span class="p">});</span>
<span class="err">¬†</span> 
<span class="err">¬†</span> 
<span class="err">¬†</span> 
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"team members are: "</span><span class="p">;</span>
<span class="err">¬†</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">player</span> <span class="o">:</span> <span class="n">team</span><span class="p">)</span> <span class="p">{</span>
<span class="err">¬†</span> <span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">player</span><span class="p">.</span><span class="n">_name</span><span class="p">;</span>
<span class="err">¬†</span> <span class="p">}</span>
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="err">¬†</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<h2 id="conclusion">Conclusion</h2>

<p>We briefly discussed how to create strongly typed collections in C++. It is not an exhaustive list, I didn‚Äôt mention the <a href="https://www.fluentcpp.com/2017/05/23/strong-types-inheriting-functionalities-from-underlying/">Curisouly Returning Template Pattern</a> for example, I didn‚Äôt even mention the open-source libraries available.</p>

<p>Given the discussed options, I cannot say which is the best. As almost always in life, it depends. What is clear on the other hand that inheriting publicly from an STL container is not something from the devil as long as you understand what you do and you respect the rules.</p>

<p>Otherwise, if public inheritance is out of scope and a simple alias is not enough for your use-case, even though I prefer composition over inheritance, the possibility to use the <code class="language-plaintext highlighter-rouge">using</code> keyword pushes me a bit towards private inheritance.</p>

<p>Do you use strong types in your projects?</p>
:ET