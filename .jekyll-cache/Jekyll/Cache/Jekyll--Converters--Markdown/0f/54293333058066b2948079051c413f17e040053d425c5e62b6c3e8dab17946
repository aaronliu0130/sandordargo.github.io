I"<p>I’ve started to work on an old and big application recently so that I can practice what I read in <a href="https://michaelfeathers.silvrback.com/">Michael Feathers’</a> must-read book on <a href="https://amzn.to/2Jf4EWC">Working with legacy code</a>.</p>

<p>A week ago my most experienced colleague (experience != years of service) sent me link pointing to a file in our code repository with the brief message of “spot the core dump”.</p>

<p>It turned out that the erroneous code was there for quite a significant amount of time and it was easily reproducible “just by two lines”. To be more exact you could navigate in just two lines your object into a state where it would core on the necessary function call. It doesn’t sound a difficult scenario, does it?</p>

<p>Here is a simplified version of the code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre>class Member {
public:
  int getANumber() const {
    return _number;
  }

private:
  int _number;
};

class CoringClass {
public:
  CoringClass() {
    _member = 0;
  }
  
  CoringClass(const CoringClass&amp; other) {
    if (other._member) {
      _member = new Member();
      *_member = (*(other._member));
    }
  }
  
  Member* accessMember() {
    return _member;
  }

private:
  Member* _member;
};

</pre></td></tr></tbody></table></code></pre></div></div>

<p>Can you already see the error? If yes, you have great eyes! If not, don’t worry. It took some time for my colleague. For me, even more. In fact, that’s why I’m writing this article. To help others as well as me to recognize such issues more easily.</p>

<p>Now I’m convinced that even if you wouldn’t write such a code, it’s more difficult to recognize it than not causing it.</p>

<p>Here are the three lines where the last one will actually produce undefined behaviour but in a more realistic class, it would core.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>CoringClass notYetCoring;
CoringClass coring(notYetCoring);
int whatHappens = coring.accessMember()-&gt;getANumber();

</pre></td></tr></tbody></table></code></pre></div></div>

<p>The biggest problem with the above code is that <code class="language-plaintext highlighter-rouge">CoringClass</code> in certain conditions fails to initialize its member variable.</p>

<p>Let’s have a quick reminder how C++ initializes its members:
<a href="https://en.wikipedia.org/wiki/Passive_data_structure">POD</a> members of the class will be zero-initialized through the default constructor, even without an explicit initiation in the constructor. <a href="https://stackoverflow.com/questions/26142100/c-default-constructor-does-not-initialize-pointer-to-nullptr">But a raw pointer as a member of the class will not be zero initialised!</a></p>

<p>It means that <code class="language-plaintext highlighter-rouge">coring.acceddMmember()</code> can point anywhere in the memory. If you are lucky, when you try to use it, it will core directly. If you are less fortunate, it will return you some nonsense value and your application will keep running using that value.</p>

<p>Check what happens if you print <code class="language-plaintext highlighter-rouge">coring.accessMember()</code>. This is a possible output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>0x722da2fc9910
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In order to fix the code, there are several options, but the copy constructor must be fixed. When you use the copy constructor, you must take care of the initialization of the new object. The default constructor is not called, so <code class="language-plaintext highlighter-rouge">_member</code> should be initialized in the copy constructor.</p>

<p>One way is that you explicitely initialize the <code class="language-plaintext highlighter-rouge">_member</code> to 0.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>CoringClass(const CoringClass&amp; other) : _member(0) {
  ...
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>If you print <code class="language-plaintext highlighter-rouge">coring.accessMember()</code> now, you’ll get a predictable <code class="language-plaintext highlighter-rouge">0</code>. That’s good. The behaviour is not undefined anymore, you can make checks against that <code class="language-plaintext highlighter-rouge">0</code> value.</p>

<p>It is an option now to change the <code class="language-plaintext highlighter-rouge">accessMember()</code> function so that in case it points to <code class="language-plaintext highlighter-rouge">0</code>, it initializes itself.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>Member* accessMember() {
   if (_member == nullptr) {
       _member = new Member();
   }
   return _member;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>You can also choose to check the nullity of <code class="language-plaintext highlighter-rouge">_member</code> returned by <code class="language-plaintext highlighter-rouge">accessMember()</code> whenever you try to access it. Although it is more secure if you have a default <code class="language-plaintext highlighter-rouge">Member</code> rather than dealing with <code class="language-plaintext highlighter-rouge">nullptr</code>s.</p>

<p>The key lesson here is that you should always initialize all the members of a class in C++.</p>

<p>You might count on the compiler because it actually does initialize some members by default, but it’s safer to be always explicit - it leaves <strike>no</strike> fewer opportunities to fail… But either you are explicit or not, always make sure that all of the constructors initialize all the members.</p>
:ET