I"Ê<p>Three laws of objects. Sounds catchy enough? To me, it did. I read about these laws in <a href="https://amzn.to/2VoCO0k">Ken Pugh‚Äôs Prefactoring</a>.</p>

<p>If you sense a not too much-hidden reference to Asimov‚Äôs <a href="https://en.wikipedia.org/wiki/Three_Laws_of_Robotics">Three Laws of Robotics</a> from <a href="https://amzn.to/2Rp2sD8">I, Robot</a>, it‚Äôs not a coincidence. It‚Äôs the author‚Äôs purpose.</p>

<p>Enough, Sandor, show me the laws - you might say and you‚Äôd be right. There you go:
<!--more--></p>

<ul>
  <li>An object shall do what its methods say it does</li>
  <li>An object shall do no harm</li>
  <li>An object shall notify its user if it is unable to perform a requested operation</li>
</ul>

<p>Let‚Äôs expand them one by one.</p>

<h2 id="an-object-shall-do-what-its-methods-say-it-does">An object shall do what its methods say it does</h2>

<p>Let‚Äôs break this law even down into two paragraphs.</p>

<h3 id="a-rose-by-any-other-name-is-not-a-rose">A Rose by Any Other Name Is Not a Rose</h3>

<p>For each concept in the system, you must create a clearly defined name. One clearly defined name. Stick to it.</p>

<p>The name is an important part of the method itself. Meaning that if you change the name, but keep the code intact, the method becomes another one. A new name will hold at least a slightly different meaning, so conceptually the method changes. Even worse if you start using both the old and the new names at the same time.</p>

<p>Would the famous painting of Magritte be the same piece of art if it was called ‚ÄúThis is a pipe‚Äù?</p>

<p><img src="{{ site.baseurl }}/assets/img/magritte-this-is-not-a-pipe.jpg" alt="The Treachery of Images from https://knowyourmeme.com/memes/this-is-not-a-pipe-parodies" title="The Treachery of Images from https://knowyourmeme.com/memes/this-is-not-a-pipe-parodies" /></p>

<h3 id="principle-of-least-surprises">Principle of Least Surprises</h3>

<p>So we have a clearly defined name for a given concept that is used by a given object/method. It is also important that the code does what the name reasonably indicates.</p>

<p>It is necessary that the method doesn‚Äôt do anything else. It should not cause us some unwanted surprises. In the book, the example of <code class="language-plaintext highlighter-rouge">delete</code> and <code class="language-plaintext highlighter-rouge">remove</code> is used. Let‚Äôs say you store references to some objects in an array. Should a <code class="language-plaintext highlighter-rouge">remove</code> operation delete the referenced object itself? Or should a <code class="language-plaintext highlighter-rouge">delete</code> operation remove the reference from the list?</p>

<p>Good question.</p>

<p>Given a name, the method should do what you would expect by that name. Your expectations might be based on plain English or on some company dictionary, the most important is to stay consistent.</p>

<p>But surprises might still arise. What if your function is not <a href="https://en.wikipedia.org/wiki/Idempotence">idempotent</a>? Meaning that you call it twice in a row with the same list of arguments and it doesn‚Äôt return the same value. Would it be surprising for you? Unless the underlying data source doesn‚Äôt change, it most probably would. But let‚Äôs say, <a href="https://dev.to/thorstenhirsch/poll-do-you-know-what-idempotent-means-4759">it depends</a>. Just like some unwanted side effects that change the state of your object, even though it‚Äôs supposed to be a getter. Apparently, functional programming is a possible answer to guarantee at least the least possible surprises.</p>

<p>Regarding the name, keep in mind that a <a href="http://arlobelshee.com/good-naming-is-a-process-not-a-single-step/">good names depends</a> on you. You are responsible to name things well in the code you deliver.</p>

<h2 id="an-object-shall-do-no-harm">An object shall do no harm</h2>

<p>The second law seems to be an obvious next step after the Principle of Least Surprises. Unless a function/object harming itself is something that you‚Äôd expect to have. What is considered harm anyway?</p>

<p><a href="https://amzn.to/2VoCO0k">Prefactoring</a> takes an object creating widgets as an example. In that program, for each widget creation, the configuration from a file had to be read. But the object responsible for creating those widgets didn‚Äôt close the configuration file as soon as they were not needed only much later at destruction time. The running OS could open 20 files simultaneously.</p>

<p>As such, no more than 20 widgets could be created. The object creating widgets was harmful as it kept locked unnecessary resources.</p>

<p>In C++, it‚Äôs even more easy to create some harmful objects. Think about objects leaving memory leaks after themselves. They are harmful. How much? That depends on the size of the leak. If you are using raw pointers when ownership has to be handled, it‚Äôs kind of guaranteed that you‚Äôll eventually find yourself fixing memory leaks. Want to learn a bit more about memory leaks? <a href="https://en.wikipedia.org/wiki/Memory_leak">Check out this Wikipedia page first</a>. Ray, I mean <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> should be a great friend of yours while you‚Äôre learning the different ways of tackling memory leaks.</p>

<p>If you work with a language where you don‚Äôt directly control object destructions - so you depend on a garbage collector -, you have to pay explicit attention to release resources manually.</p>

<p>But even if you use a language like C++, you have to think twice, when some resources can be released. The sooner, the better.</p>

<h2 id="an-object-shall-notify-its-user-if-it-is-unable-to-perform-a-requested-operation">An object shall notify its user if it is unable to perform a requested operation</h2>

<p>According to the Third Law of Objects, if an object faces troubles, it shall never stay silent, it must speak! It might print to the logs, it can return some error codes or it can throw exceptions. As you wish, or better to say as it makes sense given the circumstances.</p>

<p>The point behind this law is that if the object fails silently or does a reparative action without reporting it, then debugging will become very difficult. Let‚Äôs say that you have a function that should append a new element to list, but only if such an element is not part of the list yet. As an example, let say you have a big garage and you a function called park car. You have your Ferrari already in the garage, but then you call the method again with your Ferrari:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>garage.park(myFerrari);
</pre></td></tr></tbody></table></code></pre></div></div>

<p>If the method does nothing or it replaces the previous instance of your Ferrari with this one, most probably you just mask an error which will become more daunting later on. But when the error will come back to you, you won‚Äôt have all the logs that could help you investigate easier.</p>

<p>Just like in management, report issues as soon as they arise in software too.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, we have read about the Three Laws of Objects, as Ken Pugh described them in <a href="https://amzn.to/2VoCO0k">his book called Prefactoring</a>. According to these laws, objects should act as their name suggest and their behaviour shouldn‚Äôt cause surprises. While they do as they say, they shall leave no harm nor in the system nor in the neighbouring objects. Last but not least, objects should report their difficulties, so you are aware of problems as early as they arise.</p>

<p>Happy coding and reading!</p>
:ET