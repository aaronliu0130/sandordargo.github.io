I"™<<p><a href="https://www.sandordargo.com/blog/2020/10/14/strong-types-for-containers">Last time</a> we discussed strong types and in particular, strongly typed containers. We introduced the idea through a constructor that takes two integers and two boolean values and we saw how easy it is to mess them up.
<!--more--></p>

<h2 id="a-little-recap-of-the-problem">A little recap of the problem</h2>

<p>There is not much difference between the two below instantiations of the <code class="language-plaintext highlighter-rouge">Car</code> constructor</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="n">Car</span><span class="o">::</span><span class="n">Car</span><span class="p">(</span><span class="n">unit32_t</span> <span class="n">horsepower</span><span class="p">,</span> <span class="n">unit32_t</span> <span class="n">numberOfDoors</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isAutomatic</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isElectric</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="k">auto</span> <span class="n">myCar</span><span class="p">{</span><span class="n">Car</span><span class="p">(</span><span class="mi">96</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">)};</span>
<span class="k">auto</span> <span class="n">myCar</span><span class="p">{</span><span class="n">Car</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">)};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Yet one doesnâ€™t make much sense, while the other is something meaningful. Then we ended up with the following constructor and instantiations:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> --><td class="rouge-code"><pre><span class="n">Car</span><span class="o">::</span><span class="n">Car</span><span class="p">(</span><span class="n">Horsepower</span> <span class="n">hp</span><span class="p">,</span> <span class="n">DoorsNumber</span> <span class="n">numberOfDoors</span><span class="p">,</span> <span class="n">Transmission</span> <span class="n">transmission</span><span class="p">,</span> <span class="n">Fuel</span> <span class="n">fuel</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">myCar</span> <span class="o">=</span> <span class="n">Car</span><span class="p">{</span><span class="n">Horsepower</span><span class="p">{</span><span class="mi">98u</span><span class="p">},</span> <span class="n">DoorsNumber</span><span class="p">{</span><span class="mi">4u</span><span class="p">},</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Automatic</span><span class="p">,</span> <span class="n">Fuel</span><span class="o">::</span><span class="n">Gasoline</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">myCar</span> <span class="o">=</span> <span class="n">Car</span><span class="p">{</span><span class="n">DoorsNumber</span><span class="p">{</span><span class="mi">98u</span><span class="p">},</span> <span class="n">Horsepower</span><span class="p">{</span><span class="mi">4u</span><span class="p">},</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Automatic</span><span class="p">,</span> <span class="n">Fuel</span><span class="o">::</span><span class="n">Gasoline</span><span class="p">};</span> <span class="c1">// Really?</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Here we could, we can already see the value of strong typing, itâ€™s much more difficult to make a mistake. Not only the - sometimes hardcoded - numbers and the variable names represent values, but the types as well. One more checkpoint.</p>

<p>Though thatâ€™s not the last step if you want to increase safety and readability, especially in unit tests, where most of the hardcoded values reside.</p>

<h2 id="user-defined-literals-to-the-rescue">User-defined literals to the rescue</h2>

<p>User-defined literals allow integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix.</p>

<p>Ok, what does it mean in practice?</p>

<p>It means that still keeping the strong types of <code class="language-plaintext highlighter-rouge">Horsepower</code> and <code class="language-plaintext highlighter-rouge">DoorsNumber</code>, you can declare a <code class="language-plaintext highlighter-rouge">Car</code> object as such:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">myCar</span> <span class="o">=</span> <span class="n">Car</span><span class="p">{</span><span class="mi">98</span><span class="n">_hp</span><span class="p">,</span> <span class="mi">4</span><span class="n">_doors</span><span class="p">,</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Automatic</span><span class="p">,</span> <span class="n">Fuel</span><span class="o">::</span><span class="n">Gasoline</span><span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Just like in the previous version, you have to write the type or something similar, yet if you look at it, it seems more natural to write <code class="language-plaintext highlighter-rouge">98_hp</code> or <code class="language-plaintext highlighter-rouge">4_doors</code> than <code class="language-plaintext highlighter-rouge">Horsepower(98u)</code> or <code class="language-plaintext highlighter-rouge">DoorsNumber(4u)</code>. We are closer to the ideal state of code when it reads like a well-written prose as Grady Booch wrote in <a href="https://amzn.to/3jR0mXn">Object
Oriented Analysis and Design with Applications</a>.</p>

<p>All that you need for that is a user-defined literal for both types. For the sake of brevity, letâ€™s omit <code class="language-plaintext highlighter-rouge">Transmission</code> and <code class="language-plaintext highlighter-rouge">Fuel</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">Horsepower</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Horsepower</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">performance</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_performance</span><span class="p">(</span><span class="n">performance</span><span class="p">)</span> <span class="p">{}</span>
<span class="nl">private:</span>
 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m_performance</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Horsepower</span> <span class="k">operator</span><span class="s">""</span> <span class="n">_hp</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">horsepower</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//1</span>
    <span class="k">return</span> <span class="n">Horsepower</span><span class="p">(</span><span class="n">horsepower</span><span class="p">);</span> <span class="c1">//2</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">DoorsNumber</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">DoorsNumber</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numberOfDoors</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_numbeOfDoors</span><span class="p">(</span><span class="n">numberOfDoors</span><span class="p">)</span> <span class="p">{}</span>
<span class="nl">private:</span>
 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m_numbeOfDoors</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">DoorsNumber</span> <span class="k">operator</span><span class="s">""</span> <span class="n">_doors</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">numberOfDoors</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//3</span>
    <span class="k">return</span> <span class="n">DoorsNumber</span><span class="p">{</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numberOfDoors</span><span class="p">)};</span> <span class="c1">//4</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Car</span><span class="p">(</span><span class="n">Horsepower</span> <span class="n">performance</span><span class="p">,</span> <span class="n">DoorsNumber</span> <span class="n">doorsNumber</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_performance</span><span class="p">(</span><span class="n">performance</span><span class="p">),</span> <span class="n">m_doorsNumber</span><span class="p">(</span><span class="n">doorsNumber</span><span class="p">)</span> <span class="p">{}</span>
<span class="nl">private:</span>
  <span class="n">Horsepower</span> <span class="n">m_performance</span><span class="p">;</span>
  <span class="n">DoorsNumber</span> <span class="n">m_doorsNumber</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">car</span> <span class="o">=</span> <span class="n">Car</span><span class="p">{</span><span class="mi">98</span><span class="n">_hp</span><span class="p">,</span> <span class="mi">4</span><span class="n">_doors</span><span class="p">};</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>There are a couple of things to notice here. On lines 1) and 3) we use <code class="language-plaintext highlighter-rouge">unsigned long long int</code>. Either we envision extremely powerful cars with a door for everyone in the world, or there is something else going on.</p>

<p>Itâ€™s something else.</p>

<p>For a reason that I havenâ€™t found myself, only <a href="https://en.cppreference.com/w/cpp/language/user_literal">about a dozen types are allowed on literal operators</a> and this seemed to be the best available option.</p>

<p>This doesnâ€™t mean that we should change the types wrapped by <code class="language-plaintext highlighter-rouge">Horsepower</code> or <code class="language-plaintext highlighter-rouge">DoorsNumber</code> . There is no reason to change them, so in the literal operators, we must narrow from an <code class="language-plaintext highlighter-rouge">unsigned long long int</code> to an <code class="language-plaintext highlighter-rouge">unsigned int</code>.</p>

<p>We could of course fall back an implicit narrowing as we did on line 2), but implicit conversions are barely a good idea, and <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-narrowing">narrowing conversions are even worse - even according to the Core Guidelines</a>. If you really must perform one, <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-named">be explicit about it</a>, like we were on line 4). Please note, that probably <code class="language-plaintext highlighter-rouge">gsl::narrow_cast</code> is a better idea, given that you have access to <code class="language-plaintext highlighter-rouge">gsl</code>.</p>

<p><code class="language-plaintext highlighter-rouge">static_cast</code> has no performance overhead like <code class="language-plaintext highlighter-rouge">dynamic_cast</code> has, so that cannot be a concern. And besides, the above usage is mostly to increase the readability of unit tests, and their performance is not a big concern.</p>

<p>But I donâ€™t want to imply that user-defined literals can only be useful when you write unit tests. Even with the above usage, you might increase the readability of your production code when you define some constants, but more importantly there can be other usages.</p>

<p>Imagine that it makes come conversions, such as you could use it for converting between Celsius and Fahrenheit.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>

<span class="kt">long</span> <span class="kt">double</span> <span class="k">operator</span><span class="s">""</span> <span class="n">_celsius_to_fahrenheit</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">celsius</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">celsius</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">5</span> <span class="o">+</span><span class="mi">32</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"100 Celsius is "</span> <span class="o">&lt;&lt;</span> <span class="mf">100.0</span><span class="n">_celsius_to_fahrenheit</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>Today, we have learned about user-defined literals, a powerful way to boost the readability of your code. Whether you want to perform some conversions on certain primitive types or you want to improve the instantiation of your strongly-typed primitives, user-defined literals will help you.</p>

<p>Have you already used them? Please share your use-cases!</p>
:ET