I"àL<p>This is a statement frequently repeated by people who either just more familiar with the <code class="language-plaintext highlighter-rouge">&lt;algorithms&gt;</code> header in C++ and/or are advocates of functional programming in C++. And of course, let‚Äôs not forget about the people who just repeat what others say without understanding the reasons behind.
<!--more--></p>

<p>We shouldn‚Äôt act like people who are just part of a herd. Even if a message is valid, we shouldn‚Äôt just broadcast it because someone knowledgeable said so. We should understand why they are right.</p>

<p>Today, let‚Äôs discuss the reasons usually mentioned to prove why the good old loops are considered worse than using predefined structures of the standard library.</p>

<ol>
  <li>If you have to write something a thousand times, there is a fair chance that you‚Äôll make some mistakes once in a while. On the other hand, if you use functions that were written before and used a million times, you won‚Äôt face any bugs.</li>
  <li>Algorithms have a better performance</li>
  <li>Algorithms are more expressive</li>
</ol>

<p>Are these points valid?</p>

<h2 id="loops-are-error-prone">Loops are error-prone</h2>

<p>Few are humble enough to admit this. ‚ÄúI‚Äôm not a moron, I can write a simple for loop that will break whenever an element is found.‚Äù</p>

<p>Until you can‚Äôt.</p>

<p>This is mostly not about your experience. It‚Äôs about being human. If you do, you err. No matter what. You can put in place procedures that will limit the quantity and the scope of your mistakes, like having code reviews and unit tests, but you cannot eradicate the possibility of <a href="http://sandordargo.com/blog/2020/02/26/what-to-do-when-screwed-up">screwing it up</a>.</p>

<p>Interestingly, these objections usually come from people who also complain that coding dojo exercises are too easy for them. People who claim cannot learn from <a href="http://sandordargo.com/blog/2018/08/08/gilded-rose-revisited">refactoring the gilded rose</a>.</p>

<p>Using a predefined structure, an algorithm is a lot about being humble and accept the wisdom of thousands if not millions.</p>

<h2 id="algorithms-have-a-better-performance">Algorithms have a better performance</h2>

<p>This is only partially true. If we speak about C++, functions in the <code class="language-plaintext highlighter-rouge">&lt;algorithms&gt;</code> header are not optimized for corner cases. They are optimized for a certain portability between different systems and container types. You can use them on any STL container without knowing their exact type. As such, we cannot assume that they can take advantage of the characteristics of the underlying datasets. Especially that they don‚Äôt operate directly on the containers, but through the iterators that give access to data behind. I say that we cannot assume, because in fact, very few people understand what is going on under the hoods of the compiler and you might find or write an implementation of the standard library that is much bigger than the usual ones, but optimized for each container type.</p>

<p>At the same time, chances are good that your for loops are not optimized either. And it‚Äôs alright. Of course, as you write your loops, you are in control. You can optimize them, you can get the last cycles out of them. You cannot do the same with the already written functions of a library, even if it‚Äôs the standard library.</p>

<p>But honestly, most probably you don‚Äôt need those last drops of performance. If you do, you are in a small minority and probably the standard implementation of the STL is not for you. But there are others, like the <a href="https://github.com/electronicarts/EASTL">Eastl</a> focusing on performance.
In nominal cases, algorithms will provide better performance. In addition, since C++17 you can set <a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">execution policies</a> for the algorithms of the standard library.</p>

<p>In short, just by passing an optional parameter to an algorithm, you can parallelize the execution of it.</p>

<p>It‚Äôs that simple:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">par_unseq</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>If you have access to the necessary hardware and compiler supporting parallel execution, try this new feature to have a better visibility on the possible performance gain!</p>

<h2 id="algorightms-are-more-expressive-than-loops">Algorightms are more expressive than loops</h2>

<p>I truly believe so.</p>

<p>You can use algorithms in a more expressive way than <code class="language-plaintext highlighter-rouge">for</code> or <code class="language-plaintext highlighter-rouge">while</code> loops.</p>

<p>But it doesn‚Äôt come automatically, there is no automation for this. You need some practice to find the good one.</p>

<p>Let‚Äôs take an example.</p>

<p>In python, it‚Äôs very easy to check if an element is in a list.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">isIncluded</span> <span class="o">=</span> <span class="n">searchedOne</span> <span class="ow">in</span> <span class="n">collection</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>How would you do this in C++?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">isIncluded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">collection</span><span class="p">)</span> <span class="p">{</span>
<span class="err">¬†</span> <span class="k">if</span> <span class="p">(</span><span class="n">searchedOne</span> <span class="o">==</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
<span class="err">¬†</span> <span class="err">¬†</span> <span class="n">isIncluded</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="err">¬†</span> <span class="err">¬†</span> <span class="k">break</span><span class="p">;</span>
<span class="err">¬†</span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>And this is not the worst possible form as I already took advantage of the range based for loop.</p>

<p>While it‚Äôs a bit verbose, it is also easy to understand. We loop through a collection and as soon as we found the element we were looking for, we break out of the loop. As I wrote, it‚Äôs a bit lengthy, but otherwise, it‚Äôs OK.</p>

<p>Let‚Äôs see what happens, if use <code class="language-plaintext highlighter-rouge">std::find</code> instead.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">foundPosition</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">collection</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">collection</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">searchedOne</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">isIncluded</span> <span class="o">=</span> <span class="p">(</span><span class="n">foundPosition</span> <span class="o">!=</span> <span class="n">collection</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The first thing we can observe is that it‚Äôs terse, only two lines compared to the 7 we had earlier. And in fact, we could make all this a one-liner.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">isIncluded</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">collection</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">collection</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">searchedOne</span><span class="p">)</span> <span class="o">!=</span> <span class="n">collection</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>But this is just to show it‚Äôs possible, not to say it‚Äôs more readable than the 2 line version. Actually I think that the line version is optimal here.</p>

<p>On the first line, we search for the position of an element. If it‚Äôs not part of the container, it‚Äôll point behind the last element, so at <code class="language-plaintext highlighter-rouge">std::vector&lt;&gt;::end()</code> meaning that it‚Äôs not part of the collection.</p>

<p>In the second line, we just make the comparison between the result of find and <code class="language-plaintext highlighter-rouge">end</code> to see if we found what we‚Äôve been looking for.</p>

<p>Recently in a code review, in the unit tests, I ran into a similar <code class="language-plaintext highlighter-rouge">for</code> loop. Similar, yet a bit different.</p>

<p>The difference was that it also contained a condition. Here is the original for loop:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">key</span> <span class="o">:</span> <span class="n">keys</span><span class="p">)</span> <span class="p">{</span>
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">aValue</span><span class="p">;</span>
<span class="err">¬†</span> <span class="k">if</span> <span class="p">(</span><span class="n">not</span> <span class="n">iCache</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">aValue</span><span class="p">)</span> <span class="o">||</span> <span class="n">expectedValue</span> <span class="o">!=</span> <span class="n">aValue</span><span class="p">)</span> <span class="p">{</span>
<span class="err">¬†</span> <span class="err">¬†</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="err">¬†</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Without too much thinking, I just asked if we could use an algorithm, like <code class="language-plaintext highlighter-rouge">std::find_if</code>. The discussion went on and we came up with this code.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">found</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">keys</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
<span class="err">¬†</span> <span class="err">¬†</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">expectedValue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iCache</span><span class="p">](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">aValue</span><span class="p">;</span>
<span class="err">¬†</span> <span class="k">return</span> <span class="n">not</span> <span class="n">iCache</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">aValue</span><span class="p">)</span> <span class="o">||</span> <span class="n">expectedValue</span> <span class="o">!=</span> <span class="n">aValue</span><span class="p">;</span>
<span class="p">});</span>
<span class="k">return</span> <span class="n">found</span> <span class="o">!=</span> <span class="n">keys</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It‚Äôs not really shorter than the original code, probably it‚Äôs even longer a bit. And while the variable name <code class="language-plaintext highlighter-rouge">found</code> is clear enough and the meaning of <code class="language-plaintext highlighter-rouge">std::find_if</code> is also straightforward, there is something that is difficult to understand. Maybe it‚Äôs not doing the same thing as the original code. The lambda is our scapegoat. It‚Äôs a bit complex. How could we do it better?</p>

<p>We could save and name the lambda, but first, let‚Äôs just try to write down in plain English what do we want. If there is any key that we cannot find in the cache and whose value doesn‚Äôt meet our expectations, we should return <code class="language-plaintext highlighter-rouge">false</code>, otherwise, we are fine.</p>

<p>In other words, in order to return <code class="language-plaintext highlighter-rouge">true</code>, there should be no element that doesn‚Äôt match our expectations.</p>

<p>There should be no mismatch.</p>

<p>None of the elements should be a mismatch.</p>

<p>Bingo!</p>

<p>There is an algorithm exactly for that.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">valueMismatch</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">expectedValue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iCache</span><span class="p">](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
<span class="err">¬†</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">aValue</span><span class="p">;</span>
<span class="err">¬†</span> <span class="k">return</span> <span class="p">(</span><span class="n">not</span> <span class="n">iCache</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">aValue</span><span class="p">))</span> <span class="o">||</span> <span class="n">expectedValue</span> <span class="o">!=</span> <span class="n">aValue</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">none_of</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">keys</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">valueMismatch</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>With this version, my colleague was convinced that it‚Äôs better to use an algorithm than the original <code class="language-plaintext highlighter-rouge">for</code> loop.</p>

<p>The bottom line is that there is no magic algorithm to use instead of a for loop. But there something like 105 of them. Johnathan Boccara talked about all of them in about an hour.</p>

<p>If you know them and keep thinking for a bit, it‚Äôs pretty sure that you‚Äôll find once matching your use case and you can make your code more expressive.</p>

<h2 id="conclusion">Conclusion</h2>

<p>It‚Äôs important to understand why something is better than the other option. It‚Äôs not enough just to keep repeating others‚Äô opinions.</p>

<p>Today we saw, why algorithms are most of the time better than plain old for loops.</p>

<p>They are less error-prone than loops as they were already written and tested - a lot. Unless you are going for the last drops of performance, algorithms will provide be good enough for you and actually more performant than simple loops.</p>

<p>But the most important point is that they are more expressive. It‚Äôs straightforward to pick the good among many, but with education and practice, you‚Äôll be able to easily find an algorithm that can replace a for loop in most cases.</p>

<p>Happy coding!</p>
:ET