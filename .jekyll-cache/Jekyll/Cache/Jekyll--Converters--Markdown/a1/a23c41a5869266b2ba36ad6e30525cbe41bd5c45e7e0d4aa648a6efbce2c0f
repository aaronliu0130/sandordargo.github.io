I"Œ.<p>Do you use exceptions in your code? Do you always catch the most generic one or do you write multiple catch blocks? Do you rethrow them or just swallow the exceptions right after they occur? Do you have an error-handling strategy after all?
<!--more--></p>

<p>These are daunting questions and it would be probably worth addressing them one by one in different posts, but for the time being, I write about just a small slice of these.</p>

<p>It is almost always better to pass around objects by (<code class="language-plaintext highlighter-rouge">const</code>) reference, thatâ€™s something we learned by heart. But what about exceptions? If you donâ€™t catch the most generic exception (<code class="language-plaintext highlighter-rouge">catch(...)</code>)and instead of swallowing it you even plan to rethrow it, itâ€™s critical to catch by (<code class="language-plaintext highlighter-rouge">const</code>) reference.</p>

<h2 id="whats-the-problem">Whatâ€™s the problem?</h2>

<p>Consider the following piece of code. There is a new exception type declared (1). In function <code class="language-plaintext highlighter-rouge">a()</code> we throw it (2) and then right there we catch a quite generic <code class="language-plaintext highlighter-rouge">std::exception</code> by value (3). After logging it, we rethrow the exception (4). In <code class="language-plaintext highlighter-rouge">main()</code>, we catch our custom exception type by <code class="language-plaintext highlighter-rouge">const</code> reference (5):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;exception&gt;
</span>
<span class="k">class</span> <span class="nc">SpecialException</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span> <span class="c1">// 1</span>
<span class="nl">public:</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">throw</span><span class="p">()</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span><span class="k">return</span> <span class="s">"SpecialException"</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="k">try</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="k">throw</span> <span class="n">SpecialException</span><span class="p">();</span> <span class="c1">// 2</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 3</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="c1">// std::cout &lt;&lt; "exception caught in a(): " &lt;&lt; e.what() &lt;&lt; std::endl;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="k">throw</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="k">try</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="n">a</span><span class="p">();</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">SpecialException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//5</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="c1">// std::cout &lt;&lt; "exception caught in main(): " &lt;&lt; e.what() &lt;&lt; std::endl;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>What will be the output? Think about it before you actually click on <a href="http://coliru.stacked-crooked.com/a/c1f8591d71f76097">this link</a> and check it for yourself.</p>

<p>â€¦
..
.</p>

<p>So the output is apart from a compiler warning advising you not to catch anything by value is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre>exception caught in a(): std::exception
exception caught in main(): SpecialException
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="why-do-we-log-a-narrower-exception-later">Why do we log a narrower exception later?</h2>

<p>How is that even possible? Letâ€™s ignore now that itâ€™s very strange that first, we logged a wide exception than a narrow one. These kinds of questions should be addressed by our error handling policy.</p>

<p>What is interesting here is that when we logged a standard exception by value, we lost some of the information. Even though a <code class="language-plaintext highlighter-rouge">SpecialException</code> was flying around, in order to squeeze it into an <code class="language-plaintext highlighter-rouge">std::exception</code> variable, the compiler had to get rid of some parts of that exception. In other words, it got <em>sliced</em>. Had we caught it by reference, we would have kept its original type.</p>

<p>So because of slicing, we lost some information. But we got that it back after rethrowing the exception. How could that happen?</p>

<p>When you rethrow an exception simply by calling <code class="language-plaintext highlighter-rouge">throw;</code>, it will rethrow the original exception. There is no move, no copy taking place, if youâ€™d check the address of the exception from catch to catch it would be the same - thatâ€™s something impossible if you caught by value as it already makes a copy. And here lies the point. Catching by value makes a copy of the exception. But you donâ€™t rethrow the copy. You rethrow the original exception that was copied.</p>

<p>As such, any modification to the exception caught by value will be lost, including the slicing.</p>

<p>So as we rethrow the original exception, not the one we use within the <code class="language-plaintext highlighter-rouge">catch</code> block, but the one that left the <code class="language-plaintext highlighter-rouge">try</code> block we still keep that narrower <code class="language-plaintext highlighter-rouge">SpecialException</code>.</p>

<h3 id="can-we-alter-an-exception-in-a-persistent-way-after-all">Can we alter an exception in a persistent way after all?</h3>

<p>Letâ€™s assume that our <code class="language-plaintext highlighter-rouge">SpecialException</code> has an <code class="language-plaintext highlighter-rouge">append(std::string message)</code> member function. We want to add some information to the exception before weâ€™d rethrow it and of course, we want to retain that information. Is this possible?</p>

<p>Yes, but you must catch by reference and you have catch the type that has that <code class="language-plaintext highlighter-rouge">append()</code> function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="k">catch</span><span class="p">(</span><span class="n">SpecialException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">e</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"Some information"</span><span class="p">);</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="k">throw</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As you caught by reference, you donâ€™t create a copy but you got a handle to the original exception. If you modify that one, it will be reflected in the rethrown exceptions.</p>

<h3 id="are-there-other-ways-to-rethrow">Are there other ways to rethrow?</h3>

<p>As you could observe, we used a simple <code class="language-plaintext highlighter-rouge">throw;</code> but you might have encountered situations where - given that you caught an exception with the name <code class="language-plaintext highlighter-rouge">e</code> - <code class="language-plaintext highlighter-rouge">throw e;</code> Â was written.</p>

<p>The difference is that even if you caught <code class="language-plaintext highlighter-rouge">e</code> by reference if you <code class="language-plaintext highlighter-rouge">throw e;</code>, the rethrown exception will be copied from e. One potential issue with that is its cost - after all, we copy an object pretty much in vain. Then you might now rethrow the same type as was caught. To be more specific, if you caught <code class="language-plaintext highlighter-rouge">std::exception</code> by reference and you just simply use <code class="language-plaintext highlighter-rouge">throw;</code>, you will still rethrow the original <code class="language-plaintext highlighter-rouge">SpecialException</code>, while if you <code class="language-plaintext highlighter-rouge">throw e</code>, that <code class="language-plaintext highlighter-rouge">SpecialException</code> will be copied into <code class="language-plaintext highlighter-rouge">std::exception</code> so we lose information pretty much the same way as we lost information in the case of catching by value.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Today we saw the main differences between catching errors by reference and value.</p>

<p>So why should you always catch by (<code class="language-plaintext highlighter-rouge">const</code>) reference instead of by value and use simply <code class="language-plaintext highlighter-rouge">throw;</code> instead of <code class="language-plaintext highlighter-rouge">throw e;</code> (where <code class="language-plaintext highlighter-rouge">e</code> is the caught exception)?</p>

<p>The most important reason is to be unequivocal. While small performance difference can be an argument, I think that is are negligible compared to being clear on intent and meaning. If you catch by reference there is no question of type and no question of what you operate on.</p>

<p>Always catch your exceptions by reference.</p>
:ET