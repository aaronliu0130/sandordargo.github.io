I"á(<p>In this article, we are going to discover the pattern that is called the Curiously Recurring Template Pattern. Are you curious? Read on!
<!--more--></p>

<h2 id="introduction">Introduction</h2>

<p>Have you ever wondered about a derived class whose base has access to the derived classâ€™ members? Did it seem like something impossible? Impossible? Really? But in this world, nothing is impossible. Not even accessing the members of a derived class. From the base. All you need is some curiosity.</p>

<p>Some curiosity in the form of the Curiously Recurring Template Pattern. The CRTP is an idiom in C++ in which <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">a class letâ€™s call it X derives from a class template instantiation using X itself as template argument</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>// The Curiously Recurring Template Pattern (CRTP)
template&lt;class X&gt;
class Base
{
    // methods within Base can use template to access members of Derived
};

class Derived : public Base&lt;Derived&gt;
{
    // ...
};
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Like so many things in history, the CRTP was discovered around the same time at multiple places in the world.</p>

<p>The technique itself was formalized earlier, but in C++ it was Jim Coplien (author on many <a href="https://amzn.to/2BMKr8x">books about advanced C++</a> and programming in general) in 1995 who came up with the name and observed it some early C++ template codes.</p>

<p>The other thread leads us to Microsoft, where it was also discovered in the same year and became part of the Active Template Library. Funny enough, one of the first code reviewers thought that such code would not even compile. As we might know from programming history it didnâ€™t just compile, but both the ATL and Windows Template Library heavily used this technique.</p>

<p>By the way, you might have heard about this technique as the Upside Down inheritance.</p>

<h2 id="how-to-use-the-crtp">How to use the CRTP</h2>

<p>There are two broad categories for CRTP usage. You can either add some functionality to your derived class or you can use the technique to implement static polymorphism.</p>

<p>Letâ€™s check both categories.</p>

<h3 id="adding-functionality">Adding functionality</h3>

<p>The CRTP consists of:</p>
<ul>
  <li>Inheriting from a template class</li>
  <li>Use the derived class itself as a template parameter of the base class</li>
</ul>

<p>As mentioned earlier, the main advantage of this technique is that the base class have access to the derived class methods. Why is that?</p>

<p>The base class uses the derived class as a template parameter.</p>

<p>In the base class, we can get the underlying Derived object with a static cast:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>class Base {
  void foo() {
    X&amp; underlying = static_cast&lt;X&amp;&gt;(*this);  
    // now you can access X's public interface
  }
};
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In practice, this brings us the possibility of enriching our Derived classâ€™ interface through some base classes. In practice, youâ€™d use this technique to add some general functionalities to a class such as some mathematical functions to a sensor class (such as explained by <a href="https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/">Johnathan Baccara</a>). Although these functionalities can be implemented as non-member function or non-member template functions, those are hard to know about when you check the interface of a class. Whereas the public methods of a CRTPâ€™s base class are part of the interface.</p>

<h4 id="adding-numerical-functions-to-a-class-by-johnathan-baccara">Adding numerical functions to a class (by Johnathan Baccara)</h4>

<p>Here is the full example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre>template &lt;typename T&gt;
struct NumericalFunctions
{
    void scale(double multiplicator);
    void square();
    void setToOpposite();
};

class Sensitivity : public NumericalFunctions&lt;Sensitivity&gt;
{
public:
    double getValue() const;
    void setValue(double value);
    // rest of the sensitivity's rich interface...
};

template &lt;typename T&gt;
struct NumericalFunctions
{
    void scale(double multiplicator)
    {
        T&amp; underlying = static_cast&lt;T&amp;&gt;(*this);
        underlying.setValue(underlying.getValue() * multiplicator);
    }
    void square()
    {
        T&amp; underlying = static_cast&lt;T&amp;&gt;(*this);
        underlying.setValue(underlying.getValue() * underlying.getValue());
    }
    void setToOpposite()
    {
        scale(-1);
    };
};
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="object-counter">Object counter</h4>

<p>Another example of adding functionality is implementing object counters.</p>

<p>You can create a counter base class:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>template &lt;typename T&gt;
class Counter
{
    static int _createdObjects;
    static int _aliveObjects;

    Counter()
    {
        ++_createdObjects;
        ++_aliveObjects;
    }
    
    Counter(const Counter&amp;)
    {
        ++_createdObjects;
        ++_aliveObjects;
    }
protected:
    ~counter() // objects should never be removed through pointers of this type
    {
        --_aliveObjects;
    }
};
template &lt;typename T&gt; int Counter&lt;T&gt;::_createdObjects( 0 );
template &lt;typename T&gt; int Counter&lt;T&gt;::_aliveObjects( 0 );

</pre></td></tr></tbody></table></code></pre></div></div>

<p>Then even though you have one pair of static counters tracking the created and alive objects, you can have separate counters for separate types. All this, because the Counter is a template base class, that you specialize with the derived class as such:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>class X : counter&lt;X&gt;
{
    // ...
};

class Y : counter&lt;Y&gt;
{
    // ...
};
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="static-polymorphism">Static polymorphism</h3>

<p>If you want to use polymorphism in C++, you have to declare functions you want to overload as virtual functions. Right?</p>

<p>Right! Butâ€¦ Not necessarily.</p>

<p>You can avoid virtuals, so you can avoid the runt0time cost of virtual tables in your code by using static interfaces and, surprise, surprise, the CRTP pattern.</p>

<p>Letâ€™s take an example. We want to model vehicles and in the example, the interface will have one method, <code class="language-plaintext highlighter-rouge">getNumberOfWheels</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>template &lt;typename T&gt;
class Vehicle
{
public:
    double getNumberOfWheels() const
    {
        return static_cast&lt;T const&amp;&gt;(*this).getNumberOfWheels();
    }
};
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Then we can create the derived class as such:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>class Bus : public Vehicle&lt;Bus&gt;
{
public:
    explicit Bus(int value) : value_(value) {}
    double getNumberOfWheels() const {return value_;}
private:
    int value_;
};
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>class Scooter : public Vehicle&lt;Scooter&gt;
{
public:
    double getNumberOfWheels() const {return 2;}
};
</pre></td></tr></tbody></table></code></pre></div></div>
<p>If you really want to spare runtime, this technique might help you a bit. Remember, there will be no run-time resolutions of virtual calls because there are no virtual function calls.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Curiously Recurring Template Pattern is an interesting technique at least to know and sometimes to use. With the help of the pattern you access the derived classâ€™ public interface from the base class which helps you mostly:</p>
<ul>
  <li>adding functionality to a derived class through the base</li>
  <li>implementing polymorphism without the cost of virtual tables</li>
</ul>

<p>If you want to get deeper knowledge, Iâ€™d recommend you to read the following pages and articles:</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern</a></li>
  <li><a href="https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/">https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/</a></li>
  <li><a href="https://stackoverflow.com/questions/4173254/what-is-the-curiously-recurring-template-pattern-crtp">https://stackoverflow.com/questions/4173254/what-is-the-curiously-recurring-template-pattern-crtp</a></li>
</ul>
:ET