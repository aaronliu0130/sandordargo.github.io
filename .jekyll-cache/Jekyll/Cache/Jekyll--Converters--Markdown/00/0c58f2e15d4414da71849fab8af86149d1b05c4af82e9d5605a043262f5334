I"ƒ<p>Yesterday we started to sketch up a hello world REST application. Its hello service doesnâ€™t even have to return anything in its response it just has to print <em>hello, world!</em> to the logs. But how do you test that?</p>

<p>One of the greatest advantages of mob or pair programming is that you wonâ€™t just skip some tests saying that I canâ€™t test that. You simply must.</p>

<p>So how do you test that you printed something to the logs?</p>

<p>I extended a bit what we did yesterday and upload it to <a href="https://github.com/sandordargo/SpringTestConfigurationExample">this repository</a>.</p>

<p>When you just want a unit test it is fairly easy. In Java you just inject your dependency (in this case a <code class="language-plaintext highlighter-rouge">PrintStream</code>) in the constructor. I think youâ€™d do something similar in other languages too.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> --><td class="rouge-code"><pre>  @Test
  public void controllerPrintedGreetingToOutput() throws UnsupportedEncodingException {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    PrintStream out = new PrintStream(outputStream);
    HelloController controller = new HelloController(out);

    controller.greet("Peter File");
    String expected = "Hello, Peter File!" + System.getProperty("line.separator");
    String actual = new String(outputStream.toByteArray(), "UTF-8");

    assertEquals(expected, actual);
  }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>What you have to take care of is that your class under test accepts a custom <code class="language-plaintext highlighter-rouge">PrintStream</code> in its constructor, while its default output stream is <code class="language-plaintext highlighter-rouge">System.out</code>. Easy peasy, but you have multiple options.</p>

<p>The conventional way would be to simply use multiple constructors:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td> --><td class="rouge-code"><pre>class HelloService {
	PrintStream outputStream;

	HelloService() {
		this(System.out);
	}

	HelloService(PrintStream outputStream) {
		this.outpuStream = outputStream;
	}

	//...
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The other option is to use the features of Spring framework and declare <code class="language-plaintext highlighter-rouge">outputStream</code> with the <code class="language-plaintext highlighter-rouge">@Autowired</code> annotation.</p>

<p>It also means that you have to specify your configuration, otherwise you will get nice NPEâ€™s when you try to do anything with your autowired member variable.</p>

<p>So letâ€™s turn <code class="language-plaintext highlighter-rouge">BootstrapRun</code> from simply your main class into a configuration, by adding <code class="language-plaintext highlighter-rouge">@Configuration</code> annotation to the class and also to declare a getter for <code class="language-plaintext highlighter-rouge">PrintStream</code> with the <code class="language-plaintext highlighter-rouge">@Bean</code> annotation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td> --><td class="rouge-code"><pre>@SpringBootApplication
@Configuration
public class BootstrapRun {

  @Bean
  public PrintStream getPrintStream() {
    return System.out;
  }

  public static void main(String[] args) {
    SpringApplication.run(BootstrapRun.class, args);
  }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This way we donâ€™t have to pollute with multiple constructors our class in order to make it testable and to have the production behaviour at the same time. End it makes integration testing so much easier! Youâ€™ll see!</p>

<p>Using <code class="language-plaintext highlighter-rouge">@Autowired</code> was already interesting to me, but configuring the integration test was way more enlighting.</p>

<p>In the integration test we wanted to instatiate our server and cell the service it exposes. In other words you donâ€™t interact directly neither with your controller nor with yout service. So you canâ€™t instatiate them with another constructor. Now it comes really handy that we used <code class="language-plaintext highlighter-rouge">@Autowired</code> for our <code class="language-plaintext highlighter-rouge">PrintStream</code> instead of having multiple constructors. Letâ€™s override the configuration!</p>

<p>We can do it directly in our integration test by creating a nested static class.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre>@Configuration
@Import(BootstrapRun.class)
public static class TestBootstrap {

  @Bean
  @Primary
  public PrintStream getPrintStream() {
    return new PrintStream(outputStream);
  }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>There are three things to mention here.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">@Import(BootstrapRun.class)</code> means that this configuration class is build based on the class passed as a parameter. It is like <code class="language-plaintext highlighter-rouge">extends</code> for a normal class.</p>
  </li>
  <li>
    <p>The second thing to mention here is the usage of <code class="language-plaintext highlighter-rouge">@Primary</code> annotation. In case you override a <code class="language-plaintext highlighter-rouge">@Bean</code> from your base config, you donâ€™t have to use <code class="language-plaintext highlighter-rouge">@Primary</code>. But as soon as in your config chain you have two functions with the same return type, Spring will complain that it doesnâ€™t know which one to use. 
In order to be explicit and clear about my intentions I prefer to use <code class="language-plaintext highlighter-rouge">@Primary</code> even if it is not mandatory.</p>
  </li>
  <li>
    <p>The last thing to mention is to say where <code class="language-plaintext highlighter-rouge">outputStream</code> comes from. As I said <code class="language-plaintext highlighter-rouge">TestBootstrap</code> is a nested class. <code class="language-plaintext highlighter-rouge">outputstream</code> is a member in the encapsulating test class so that its content can be verified easily.</p>
  </li>
</ul>

<p>The only thing left is to use these new configurations when we start up our server. Itâ€™s really easy:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td> --><td class="rouge-code"><pre>  //...
  private static ConfigurableApplicationContext context;
  //...
  @BeforeClass
  public static void startServer() {
    context = SpringApplication.run(TestBootstrap.class);
  }

</pre></td></tr></tbody></table></code></pre></div></div>

<p>Thatâ€™s it. Thatâ€™s how you can validate even your logs in an integration test. You can check the whole code at <a href="https://github.com/sandordargo/SpringTestConfigurationExample">my github repository</a>.</p>
:ET