I"M+<p>Even after spending years in software development, you will find expressions that you simply don’t understand. Even if you are considered somewhat a senior. Those terms might express an advanced concept or something that is more basic, it doesn’t matter. You should always be humble enough to accept that you don’t understand them and hungry enough to seek for comprehension.
<!--more--></p>

<p>I spent quite some time reading about test contravariance and even though I didn’t understand the word <em>contravariance</em>, by devoting some time to the topic I understood the concept without understanding the word. Then I came through <em>“covariant return types”</em> in the boost documentation, then on other blogs and it became crystal clear that I’m missing something important.</p>

<p>In this post, I attempt to provide a summary of my understanding on covariant return types.</p>

<p>The most simple explanation is that when you use covariant return types for a virtual function and for all its overriden versions, you can replace the original return type with something narrower, in other words, with something more specialized.</p>

<p>Let’s take a concrete example in the realms of automobiles.</p>

<p>Let’s say you have a <code class="language-plaintext highlighter-rouge">CarFactoryLine</code> producing <code class="language-plaintext highlighter-rouge">Car</code>s. The specialization of these factory lines might produce <code class="language-plaintext highlighter-rouge">SUV</code>s, <code class="language-plaintext highlighter-rouge">SportsCar</code>s, etc.</p>

<p>How do you represent it in code?</p>

<p>The obvious way is still having the return type as a Car pointer, right?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">CarFactoryLine</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="n">Car</span><span class="o">*</span> <span class="n">produce</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">Car</span><span class="p">{};</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">SUVFactoryLine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarFactoryLine</span> <span class="p">{</span>
<span class="nl">public:</span>	
	<span class="k">virtual</span> <span class="n">Car</span><span class="o">*</span> <span class="n">produce</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">SUV</span><span class="p">{};</span>
	<span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This will work as long as a <code class="language-plaintext highlighter-rouge">SUV</code> is a derived class of <code class="language-plaintext highlighter-rouge">Car</code>.</p>

<p>But working like this is cumbersome because if you directly try to get a SUV out of your SUVFactory line, you will get a compilation error:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">SUVFactoryLine</span> <span class="n">sf</span><span class="p">;</span>
    <span class="n">SUV</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">produce</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*
output:
main.cpp: In function 'int main()':
main.cpp:27:20: error: invalid conversion from 'Car*' to 'SUV*' [-fpermissive]
   27 | SUV* c = sf.produce();
      |          ~~~~~~~~~~^~
      |                    |
      |                    Car*
*/</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>So it means you have to apply a dynamic cast, somehow like this:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="c1">// ...</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">SUVFactoryLine</span> <span class="n">sf</span><span class="p">;</span>
    <span class="n">Car</span><span class="o">*</span> <span class="n">car</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">produce</span><span class="p">();</span>
    <span class="n">SUV</span><span class="o">*</span> <span class="n">suv</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">SUV</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">suv</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"We indeed got a SUV</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Car is not a SUV</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
output:
We indeed got a SUV
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>For the sake of brevity, I didn’t delete the pointers. It’s already too long.</p>

<p>So ideally, <code class="language-plaintext highlighter-rouge">SUVFactoryLine::produce</code> should be able to change its return type fixed into <code class="language-plaintext highlighter-rouge">SUV*</code> while still keeping the <a href="http://sandordargo.com/blog/2018/07/05/cpp-override">override specifier</a>. Is that possible?</p>

<p>It is!</p>

<p>This below example works like a charm:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
 <span class="k">virtual</span> <span class="o">~</span><span class="n">Car</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">SUV</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{};</span>

<span class="k">class</span> <span class="nc">CarFactoryLine</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="n">Car</span><span class="o">*</span> <span class="n">produce</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">Car</span><span class="p">{};</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">SUVFactoryLine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarFactoryLine</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="n">SUV</span><span class="o">*</span> <span class="n">produce</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">SUV</span><span class="p">{};</span>
	<span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">SUVFactoryLine</span> <span class="n">sf</span><span class="p">;</span>
    <span class="n">SUV</span><span class="o">*</span> <span class="n">car</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">produce</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>But you could also directly get a <code class="language-plaintext highlighter-rouge">Car*</code> from <code class="language-plaintext highlighter-rouge">SUVFactoryLine::produce()</code>, this would be also valid:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Car</span><span class="o">*</span> <span class="n">car</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">produce</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>What we have seen in <code class="language-plaintext highlighter-rouge">SUVFactoryLine</code> is that in C++, in a derived class, in an overriden function you don’t have to return the same type as in the base class, but you must return a covariant type. In other words, you can replace the original type with a “narrower” one, i.e. with a more specified data type.</p>

<p>As you could see, this helps a lot. There is no need for casting at all. But you must not forget to use <a href="http://sandordargo.com/blog/2018/07/05/cpp-override">override specifier</a> because if you don’t use it, it’s easy to overlook and you might think that <code class="language-plaintext highlighter-rouge">SUV* SUVFactoryLine::produce()</code> doesn’t override <code class="language-plaintext highlighter-rouge">Car* CarFactoryLine::produce()</code> while actually it does.</p>

<p>So in the end, when can we speak about covariant return types? When in a derived class’ overriden method a narrower, a more specialized type can replace the other wider type from the base implementation. It’s as simple as that.</p>
:ET