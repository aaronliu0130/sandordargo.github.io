I";L<p>Yes, they can, but you should not rely on them, as you might not get what you’d expect. 
<!--more--></p>

<p>If you wonder how this topic came up, the answer is static code analysis! We have been using static code analyzers for years, and little by little, by cleaning up the touching parts, by applying the boy scout rule, we’ve removed the worst offenders.</p>

<p>What are the worst ones depends highly on how the analyzer. You might not agree with some of the recommendations but if you see even those frequently enough, you’ll start fixing them and stop adding them…</p>

<p>Of course, you don’t have to be a passenger in this vehicle. You should be the driver as much as you can. On a corporate level, this means that you should customize the profiles used by the analyzers to your needs.</p>

<p>As I spoke about this in <a href="https://www.youtube.com/watch?v=CNDejB6Hg5A&amp;t=2s">Zuckerberg’s gray T-shirt and coding guidelines</a>, this mostly means that you should add rules to the industry-standard profile and not remove them.</p>

<p>In my company, we recently applied a new quality profile to our codebase which resulted in thousands of new violations which we started to categorize based on whether we want to fix it in the short term, mid-term or best effort.</p>

<p>If you wonder why we categorize after the profile is applied, we didn’t create the profile, but we want to provide valuable feedback to the creators plus a plan to deal with it to our teammates.</p>

<p>During the coming months, I’ll share you a couple of the most interesting rules we found.</p>

<h2 id="the-problem-of-default-arguments"><a href="https://rules.sonarsource.com/cpp/RSPEC-3719">The problem of default arguments</a></h2>

<p>While it’s syntactically perfectly correct to use default argument initializers in virtual functions, there is a fair chance that the code will not be maintained over time. In parallel, the emerging chaos will lead to incorrect polymorphic code and unnecessary complexity in your class hierarchy.</p>

<p>Let’s see an example:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DerivedLeft</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">13</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DerivedRight</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>What would you expect from the following <code class="language-plaintext highlighter-rouge">main</code> function?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> --><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">DerivedLeft</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DerivedLeft</span><span class="p">;</span>
  <span class="n">Base</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">();</span>
  <span class="n">d</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>You might expect:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre><span class="mi">42</span>
<span class="mi">13</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>If that’s the case, congratulations! Especially if was not by chance. If you expected something else, don’t worry. It’s not evident and that’s the problem with using default parameter values for virtual functions.</p>

<p><code class="language-plaintext highlighter-rouge">b</code> points to a derived class, yet <code class="language-plaintext highlighter-rouge">Base</code>’s default value was used.</p>

<p>Now what about the following possible <code class="language-plaintext highlighter-rouge">main</code>?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> --><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Base</span> <span class="o">*</span><span class="n">b2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Base</span><span class="p">;</span>
  <span class="n">DerivedRight</span> <span class="o">*</span><span class="n">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DerivedRight</span><span class="p">;</span>
  <span class="n">b2</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">();</span>
  <span class="n">d2</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>You might expect 42 twice in a row, but that’s incorrect. The code won’t compile. The overriding function doesn’t <em>“inherit”</em> the default value, so the empty <code class="language-plaintext highlighter-rouge">fun</code> call on <code class="language-plaintext highlighter-rouge">DerivedRight</code> fails.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre><span class="cm">/*
main.cpp: In function 'int main()':
main.cpp:28:11: error: no matching function for call to 'DerivedRight::fun()'
   28 |   d2-&gt;fun();
      |           ^
main.cpp:19:8: note: candidate: 'virtual void DerivedRight::fun(int)'
   19 |   void fun(int p) override {
      |        ^~~
main.cpp:19:8: note:   candidate expects 1 argument, 0 provided
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="static-vs-dynamic-types">Static vs dynamic types</h2>

<p>In order to understand better what is happening behind the scenes, let’s take a step back. Let’s modify a bit our original example and let’s forget about <code class="language-plaintext highlighter-rouge">DerivedRight</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::fun "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">13</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived::fun "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Derived</span> <span class="o">*</span><span class="n">derived</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">;</span>
  <span class="n">derived</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">();</span>
  <span class="n">Base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">derived</span><span class="p">;</span>
  <span class="n">base</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>What output do you expect now?</p>

<p>It is going to be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre>Derived::fun 13
Derived::fun 42
</pre></td></tr></tbody></table></code></pre></div></div>

<p>You might find it surprising that in both cases the derived version was called, yet with different default parameters.</p>

<p>The reason is that a virtual function is called on the dynamic type of the object, while the default parameter values are based on the static type. The dynamic type is <code class="language-plaintext highlighter-rouge">Derived</code> in both cases, but the static type is different, hence the different default values are used.</p>

<h2 id="is-it-really-a-problem-if-so-what-to-do">Is it really a problem? If so, what to do?</h2>

<p>It’s definitely not a syntactic issue, after all, it compiles.</p>

<p>The main problem is that it’s misleading and easy to misunderstand the code as for determining which function will be executed the dynamic type is used, but for getting the default argument the static type is used.</p>

<p>It’s better to avoid such complexities and make the functions that need a default behaviour non-virtual.</p>

<p>A way to achieve this is to use a protected so-called forwarding function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fun_impl</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="p">}</span>
<span class="nl">protected:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fun_impl</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::fun "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DerivedLeft</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">protected:</span>
  <span class="kt">void</span> <span class="n">fun_impl</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"DerivedLeft::fun "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DerivedRight</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">protected:</span>
  <span class="kt">void</span> <span class="n">fun_impl</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"DerivedRight::fun "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">DerivedLeft</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DerivedLeft</span><span class="p">;</span>
  <span class="n">Base</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">DerivedRight</span> <span class="o">*</span><span class="n">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DerivedRight</span><span class="p">;</span>

  <span class="n">b</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">();</span>
  <span class="n">d</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">();</span>
  <span class="n">d2</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It this case, only the implementation is altered and the behaviour is exactly one would expect:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> --><td class="rouge-code"><pre><span class="n">DerivedLeft</span><span class="o">::</span><span class="n">fun</span> <span class="mi">42</span>
<span class="n">DerivedLeft</span><span class="o">::</span><span class="n">fun</span> <span class="mi">42</span>
<span class="n">DerivedRight</span><span class="o">::</span><span class="n">fun</span> <span class="mi">42</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>In case you really need a second default behaviour, you can create another non-virtual <code class="language-plaintext highlighter-rouge">fun</code> function in the corresponding derived class with the new default argument forward still to <code class="language-plaintext highlighter-rouge">fun_impl</code>, it will work.</p>

<p>Though it can also be questioned whether it’s a good idea to use the same signatures in different classes in the same hierarchy without one overriding the other.</p>

<p>The best is to avoid the need for such varying default arguments.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Static code analyzers can help us both fixing - potential - bugs in our code and at the same type to educate the team about subtle rules and cases that we might not have considered otherwise.</p>

<p>Today we saw that using default arguments for virtual functions is a bad idea because it mixes static and dynamic types and hence it will become by the time a maintenance burden.</p>

<p>With a simple function forwarding, you can avoid the need.</p>

<p>Given these differences compared to normal polymorphic behaviour, it’s best to avoid any default arguments in virtual functions.</p>
:ET