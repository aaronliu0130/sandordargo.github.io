I"òK<p>In this next part of <a href="http://sandordargo.com/blog/2019/01/30/stl-algos-intro">the big STL algorithm tutorial</a>, we will discover the different functions of the <code class="language-plaintext highlighter-rouge">&lt;algorithm&gt;</code> header that we can use to find an item in a container.
<!--more--></p>

<p>Namely, we are going to examine the following functions:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">find</code></li>
  <li><code class="language-plaintext highlighter-rouge">find_if</code></li>
  <li><code class="language-plaintext highlighter-rouge">find_if_not</code></li>
  <li><code class="language-plaintext highlighter-rouge">find_end</code></li>
  <li><code class="language-plaintext highlighter-rouge">find_first_of</code></li>
  <li><code class="language-plaintext highlighter-rouge">search</code></li>
  <li><code class="language-plaintext highlighter-rouge">search_n</code></li>
  <li><code class="language-plaintext highlighter-rouge">adjacent_find</code></li>
</ul>

<p>If you have a feeling that some functions are missing, you might think of <code class="language-plaintext highlighter-rouge">find_first_not_of</code> and similar functions. They are not part of the <code class="language-plaintext highlighter-rouge">&lt;algorithm&gt;</code> header but they are provided by the <code class="language-plaintext highlighter-rouge">&lt;string&gt;</code> header and as such, they operate on only strings. Thus, they are not part of this series.</p>

<h2 id="find"><code class="language-plaintext highlighter-rouge">find</code></h2>
<p>Our first function for today is <code class="language-plaintext highlighter-rouge">find</code> and it can be used to find an element a container by passing the container and the value to the <code class="language-plaintext highlighter-rouge">find</code> method.</p>

<p>It is as simple as that. It returns an iterator to the first element that matches the value we are looking for. In case of no elements matched, the iterator points at the end (after the last element) of the container.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  auto myvector = std::vector&lt;int&gt;{1, 2, 3, 4, 5};

  auto it = std::find(myvector.begin(), myvector.end(), 3);
  if (it != myvector.end()) {
    std::cout &lt;&lt; "Element found in myvector: " &lt;&lt; *it &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; "Element not found in myvector\n";
  }

  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="find_if"><code class="language-plaintext highlighter-rouge">find_if</code></h2>
<p>The difference between <code class="language-plaintext highlighter-rouge">find</code> and <code class="language-plaintext highlighter-rouge">find_if</code> is that while find is looking for a value in the container, <code class="language-plaintext highlighter-rouge">find_if</code> takes a unary predicate and checks whether the predicate returns <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code> to a given element.</p>

<p>It will return an iterator pointing at the first element for which the predicate returns <code class="language-plaintext highlighter-rouge">true</code>. As usual, in case of no match, the iterator will point at the very end of the container.</p>

<p>A unary predicate can be a function object, a pointer to a function or a lambda function. <a href="http://sandordargo.com/blog/2018/12/19/c++-lambda-expressions">It depends on your use-case which one you should use.</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  auto myvector{1, 2, 3, 4, 5};

  auto it = find_if(myvector.begin(), myvector.end(), [](int number){return number % 2 == 0;});
  if (it != myvector.end()) {
    std::cout &lt;&lt; "Even element found in myvector: " &lt;&lt; *it &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; "No even element found in myvector\n";
  }

  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="find_if_not"><code class="language-plaintext highlighter-rouge">find_if_not</code></h2>
<p>Almost the same as <code class="language-plaintext highlighter-rouge">find_if</code>. But instead of the first match of the predicate in the given collection, it returns the first mismatch.</p>

<p>For demonstration purposes, let take our previous example and modify it only by adding a single <em>not</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  auto myvector{1, 2, 3, 4, 5};

  auto it = find_if_not(myvector.begin(), myvector.end(), [](int number){return number % 2 == 0});
  if (it != myvector.end()) {
    std::cout &lt;&lt; "Even element found in myvector: " &lt;&lt; *it &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; "No even element found in myvector\n";
  }

  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>While the previous example with <code class="language-plaintext highlighter-rouge">find_if</code> returned all the even numbers, <code class="language-plaintext highlighter-rouge">find_if_not</code> with the same predicate would return all the odd numbers.</p>

<h2 id="find_end"><code class="language-plaintext highlighter-rouge">find_end</code></h2>
<p>You can use <code class="language-plaintext highlighter-rouge">find_end</code> to look for a subsequence in a container. As the <code class="language-plaintext highlighter-rouge">end</code> suffix implies, it will return something related to the last match. That something will be an iterator to the first element of the matching subsequence (which is the last matching subsequence). You can use it in two different ways. In the first example, the items are compared by values.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  std::vector&lt;int&gt; numbers {1,2,3,4,5,1,2,3,4,5};

  std::vector&lt;int&gt; subsequence {1,2,3};

  
  auto it = std::find_end (numbers.begin(), numbers.end(), subsequence.begin(), subsequence.end());

  if (it!=numbers.end()) {
    std::cout &lt;&lt; "needle1 last found at position " &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n';
  }

  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The other possibily is to pass in a predicate as comparision function. Apart from using that one instead a <em>by value</em> comparision, there is no difference:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  std::vector&lt;int&gt; numbers {1,2,3,4,5,1,2,3,4,5};

  std::vector&lt;int&gt; subsequence {4,5,1};

  // using predicate comparison:
  auto it = std::find_end (numbers.begin(), numbers.end(), subsequence.begin(), subsequence.end(), [](int i, int j){return i == j;});

  if (it!=numbers.end())
    std::cout &lt;&lt; "subsequence last found at position " &lt;&lt; (it-numbers.begin()) &lt;&lt; '\n';

  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>
<p>As usual, the predicate can be any either a lambda, a function object or a function itself.</p>

<p>Personally what I found strange is that based on the name I would expect the same behaviour from <code class="language-plaintext highlighter-rouge">find_end</code> as from <code class="language-plaintext highlighter-rouge">find</code> apart from the direction of the search. From <code class="language-plaintext highlighter-rouge">find</code> I would expect the first match, from <code class="language-plaintext highlighter-rouge">find_end</code> the last one. Instead, <code class="language-plaintext highlighter-rouge">find</code> looks for one single value, but <code class="language-plaintext highlighter-rouge">find_end</code> tries to match a whole subsequence.</p>

<p>While you can use <code class="language-plaintext highlighter-rouge">find_end</code> make a subsequence of length one to look for the last matching element, you cannot use <code class="language-plaintext highlighter-rouge">find</code> to search for a subsequence.</p>

<h2 id="find_first_of"><code class="language-plaintext highlighter-rouge">find_first_of</code></h2>
<p>And now probably you expect that Iâ€™m going to present the function that looks for a subsequence from the beginning of a container. Sorry, but if you really expected that, I have to disappoint you.</p>

<p><code class="language-plaintext highlighter-rouge">find_first_of</code> is similar to <code class="language-plaintext highlighter-rouge">find_end</code> in a sense that it either takes two pairs of iterators or two pairs of iterators and predicate. But what does it do with the inputs?</p>

<p>It will return an iterator to the first pair of iterators and to the first element that matches any of the elements of the second passed range or any of the elements of the second range for which the predicate evaluates to true.</p>

<p>Take the following example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  std::vector&lt;int&gt; numbers {1,2,3,4,5,1,2,3,4,5};

  std::vector&lt;int&gt; targets {4,5,2};

  // using predicate comparison:
  auto it = std::find_first_of (numbers.begin(), numbers.end(), targets.begin(), targets.end(), [](int i, int j){return i == j;});

  if (it!=numbers.end())
    std::cout &lt;&lt; "first match found at position " &lt;&lt; (it-numbers.begin()) &lt;&lt; '\n';

  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The output will be</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>first match found at position 1
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Letâ€™s check why. The first element of the <code class="language-plaintext highlighter-rouge">targets</code> is 4. Its first occurrence in <code class="language-plaintext highlighter-rouge">numbers</code> is at position 3 (starting from zero). The next element 5 can be found at position 4, the last element, 1 can be found at position 1. This means that it is 1 that can be found earliest in the <code class="language-plaintext highlighter-rouge">numbers</code> container.</p>

<h2 id="search"><code class="language-plaintext highlighter-rouge">search</code></h2>

<p>And here we go! Do you remember that <code class="language-plaintext highlighter-rouge">find_end</code> looks for the last match of a subsequence in a container? Here you have its counterpart that looks for the first one. For the sake of intuitivity (watch out, irony just passed by), it is called <code class="language-plaintext highlighter-rouge">search</code>!</p>

<p>Just like the previous two presented functions <code class="language-plaintext highlighter-rouge">find_end</code> and <code class="language-plaintext highlighter-rouge">find_first_of</code>, it can either take two ranges defined by two pairs of iterators or the same plus a predicate.</p>

<p>Here you have it in action.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {
  std::vector&lt;int&gt; numbers {1,2,3,4,5,1,2,3,4,5};

  std::vector&lt;int&gt; subsequence {4,5,1};

  // using predicate comparison:
  auto it = std::search (numbers.begin(), numbers.end(), subsequence.begin(), subsequence.end(), [](int i, int j){return i == j;});

  if (it!=numbers.end())
    std::cout &lt;&lt; "subsequence first found at position " &lt;&lt; (it-numbers.begin()) &lt;&lt; '\n';

  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="search_n"><code class="language-plaintext highlighter-rouge">search_n</code></h2>

<p><code class="language-plaintext highlighter-rouge">search_n</code> can also compare by value or with the help of a predicate. It will look for <code class="language-plaintext highlighter-rouge">n</code> matching occurrences of the value or the value/predicate combination.</p>

<p>What it will return is an iterator pointing at the first matching element. If there is no match, as usual, the returned iterator will point right after the last element.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {

  std::vector&lt;int&gt; myvector{10,20,30,30,20,10,10,20};
  
  auto it = std::search_n (myvector.begin(), myvector.end(), 2, 30);

  if (it!=myvector.end()) {
    std::cout &lt;&lt; "two 30s found at position " &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; "match not found\n";
  }

  it = std::search_n (myvector.begin(), myvector.end(), 2, 10,  [](int i, int j){return i == j;});

  if (it!=myvector.end()) {
    std::cout &lt;&lt; "two 10s found at position " &lt;&lt; int(it-myvector.begin()) &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; "match not found\n";
  }

  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="adjacent_find"><code class="language-plaintext highlighter-rouge">adjacent_find</code></h2>

<p>First I didnâ€™t intend to discuss <code class="language-plaintext highlighter-rouge">adjacent_find</code> in this episode, but later I felt it belongs more to here than to other topics. After all, it is also used to find elements.</p>

<p>Like we could get used to it, this another find method offers two overloaded signature, one that takes a predicate and one that doesnâ€™t. Besides that optional parameter, it only takes two iterators defining a range that it should iterate upon.</p>

<p>Unless you write the predicate as such, <code class="language-plaintext highlighter-rouge">adjacent_find</code> doesnâ€™t look for a particular value in a container. Rather, it looks for any two neighbouring elements that are matching, or any two elements next two each other satisfying a condition passed in with the predicate. An important note is that you have to do the test on both elements in the lambda as youâ€™re going to see in a minute.</p>

<p><em>As usual</em>, it returns an iterator to the first matching element, in case of no match, to the end of the container.</p>

<p>We are going to see two examples on the same container. With the first call, we are going to return the first two adjacent matching elements and with the next call the first two neighbouring elements that are even.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> --><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main () {

  std::vector&lt;int&gt; myvector{1, 0, 1, 1, 2, 3, 4, 6};
  
  auto it = std::adjacent_find (myvector.begin(), myvector.end());

  if (it!=myvector.end()) {
    std::cout &lt;&lt; "two 1s found next to each other starting at position " &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; "no two equal elements found next to each other\n";
  }

  it = std::adjacent_find (myvector.begin(), myvector.end(), [](int i, int j){return (i % 2 == 0) &amp;&amp; (j % 2 == 0);});

  if (it!=myvector.end()) {
    std::cout &lt;&lt; "two adjacent even numbers found starting at position " &lt;&lt; int(it-myvector.begin()) &lt;&lt; '\n';
  } else {
    std::cout &lt;&lt; "no two neighbouring equal numbers found\n";
  }

  return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, we learnt about functions in the standard library that can be used to search for one or multiple elements in containers without ever modifying them.</p>

<p>We could also see some quirks of the STL. Like the unexpected differences between <code class="language-plaintext highlighter-rouge">find</code> and <code class="language-plaintext highlighter-rouge">find_end</code> and the non-matching name of the complementary <code class="language-plaintext highlighter-rouge">search</code> algorithms. But if you think more about it, itâ€™s also strange that <code class="language-plaintext highlighter-rouge">find_end</code>, <code class="language-plaintext highlighter-rouge">search</code> and <code class="language-plaintext highlighter-rouge">search_n</code> take a predicate as an optional parameter while <code class="language-plaintext highlighter-rouge">find</code> and <code class="language-plaintext highlighter-rouge">find_if</code> are different methods. I donâ€™t have te exact reason behind, but I think itâ€™s historical and the committee didnâ€™t want to change the existing API and neither wanted to overcomplicate the additional accepted new methods.</p>

<p>Regardless of all these oddities, the presented functions are more than useful and they should be part of each C++ developerâ€™s toolkit.</p>

<p>Keep tuned, in the next episode weâ€™ll discuss the rest of the non-modifying sequence operations..</p>
:ET