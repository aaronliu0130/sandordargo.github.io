I"œJ<p>In this next part of <a href="http://sandordargo.com/blog/2019/01/30/stl-algos-intro">the big STL algorithm tutorial</a>, we will discover only one algorithm, the <code class="language-plaintext highlighter-rouge">transform</code>. I find very important, plus it doesnâ€™t have variants like the <code class="language-plaintext highlighter-rouge">copy</code> or <code class="language-plaintext highlighter-rouge">move</code> algorithms. On the other hand, it has two quite distinct constructors. Letâ€™s check them one by one.
<!--more--></p>

<ul>
  <li>Unary <code class="language-plaintext highlighter-rouge">transform</code></li>
  <li>Binary <code class="language-plaintext highlighter-rouge">transform</code></li>
</ul>

<h2 id="unary-transform">Unary <code class="language-plaintext highlighter-rouge">transform</code></h2>

<p>Unary <code class="language-plaintext highlighter-rouge">transform</code> is - letâ€™s say - the basic transformation algorithm. It does exactly what I would have expected from such a function. It takes a range of inputs, applies a given operation on each element and puts the results into an output range.</p>

<p>Itâ€™s return value - just like for the other overloaded version - is an iterator pointing to right after last output element.</p>

<p>As a unary operator, as usual, you can pass a function pointer, a functor or a lambda expression. For the sake of brevity, Iâ€™ll stick to the lambdas in the coming examples.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span> 
<span class="err">Â </span> <span class="err">Â </span> 
<span class="k">auto</span> <span class="n">values</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">doubleValues</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">doubleValues</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">number</span><span class="p">;});</span>

<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">doubleValues</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">doubleValues</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">number</span><span class="p">){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;});</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>What happens if you run this? Youâ€™ll get a very nice core dump due to a segmentation fault!
What does this mean in practice?</p>

<p>If you remember, we hit this problem already in the episode about <a href="http://sandordargo.com/blog/2019/08/14/stl-alogorithms-tutorial-part-5-copy-operations"><code class="language-plaintext highlighter-rouge">std::copy</code></a>. <code class="language-plaintext highlighter-rouge">doubleValues</code> has been initialized to zero members, and there is simply not enough space in it to insert new elements.</p>

<p>There are two ways to resolve this. One is to reserve enough space for the vector in the memory by zero initializing enough elements. This is totally acceptable if you know how many elements youâ€™d need and when zero initialization is cheap.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">doubleValues</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Another option, is that instead of <code class="language-plaintext highlighter-rouge">doubleValues.begin()</code>, you pass an inserter iterator such as <code class="language-plaintext highlighter-rouge">std::back_inserter()</code>. That will take care of the job.</p>

<p>Here is a working example:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span> 
<span class="err">Â </span> <span class="err">Â </span> 
<span class="k">auto</span> <span class="n">values</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">doubleValues</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">doubleValues</span><span class="p">),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">number</span><span class="p">;});</span>

<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">doubleValues</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">doubleValues</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">number</span><span class="p">){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;});</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This will work whatever size the output will be.</p>

<p>To gain some resources <a href="https://stackoverflow.com/questions/7397768/choice-between-vectorresize-and-vectorreserve">we can preallocate some memory in our vector</a>, but most of the time it wonâ€™t make any difference.</p>

<h2 id="binary-transform">Binary <code class="language-plaintext highlighter-rouge">transform</code></h2>

<p>So what is a binary transformation? It means that the last parameter of the constructor will be a lambda (or functor, function, etc. as usual) that takes two inputs instead of one.</p>

<p>But from where that second parameter comes from?</p>

<p>From another input iterator!</p>

<p>But while the first input range is defined by two iterators (begin and end), the second one is defined by only itâ€™s start point as it should have at least the same number of elements as the second one. What happens if the second range contains fewer elements? Nasty things that weâ€™ll see in another article. As a rule, keep in mind that always the first range should be the shorter/smaller one.</p>

<p>Letâ€™s see an example respecting the rules:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span> 
<span class="err">Â </span> <span class="err">Â </span> 
<span class="k">auto</span> <span class="n">values</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">otherValues</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">results</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">otherValues</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">number</span><span class="p">,</span> <span class="kt">int</span> <span class="n">otherNumber</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">number</span><span class="o">+</span><span class="n">otherNumber</span><span class="p">;</span> <span class="p">});</span>

<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">results</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">number</span><span class="p">){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;});</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this example, you could see that we define two input ranges and our lambda expression takes two elements, one from the first and one from the second range.</p>

<p>Can you combine elements of different types?</p>

<p>Of course, you can as long as you respect the types of the containers.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span> 
<span class="err">Â </span> <span class="err">Â </span> 
<span class="k">auto</span> <span class="n">values</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">otherValues</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">{</span><span class="mf">10.1</span><span class="n">f</span><span class="p">,</span><span class="mf">20.2</span><span class="n">f</span><span class="p">,</span><span class="mf">30.3</span><span class="n">f</span><span class="p">,</span><span class="mf">40.4</span><span class="n">f</span><span class="p">,</span><span class="mf">50.5</span><span class="n">f</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">results</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">otherValues</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">number</span><span class="p">,</span> <span class="kt">float</span> <span class="n">otherNumber</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">number</span><span class="o">+</span><span class="n">otherNumber</span><span class="p">);});</span>

<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">results</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">number</span><span class="p">){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;});</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this example, we combined <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">float</code> elements and returned <code class="language-plaintext highlighter-rouge">string</code> ones. It works, but if you run the code you also received a nice example of why itâ€™s difficult to work with floating-point numbers when you need precision.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Today, we learnt about the <code class="language-plaintext highlighter-rouge">transform</code> algorithm. It takes elements of one or two ranges and puts the results of the transformation into another container.</p>

<p>Next time weâ€™ll start learning about the replace algorithms. Stay tuned!</p>
:ET