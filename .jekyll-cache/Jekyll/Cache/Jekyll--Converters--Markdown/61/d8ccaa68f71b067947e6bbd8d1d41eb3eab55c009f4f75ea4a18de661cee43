I"i<p>In this next part of <a href="http://sandordargo.com/blog/2019/01/30/stl-algos-intro">the big STL algorithm tutorial</a>, we will discover the 4 modifying sequence algorithms that will help you removing elements from containers:
<!--more--></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">remove</code></li>
  <li><code class="language-plaintext highlighter-rouge">remove_if</code></li>
  <li><code class="language-plaintext highlighter-rouge">remove_copy</code></li>
  <li><code class="language-plaintext highlighter-rouge">remove_copy_if</code></li>
</ul>

<p>Letâ€™s get started!</p>

<h2 id="remove"><code class="language-plaintext highlighter-rouge">remove</code></h2>
<p>Remove is a fairly simple algorithm. You pass in a container, or better to say a range defined by two iterators (its beginning and its end) as a third parameter a value that you want to remove. If there are multiple elements in the range matching the passed in value, all of them will be removed. The element next to the one removed takes its place and the range will be shortened by one element.</p>

<p>Letâ€™s be more precise here. The elements that are removed, are not <strong>really</strong> removed, they are not deleted. They are shifted to the end of the original range, and the iterator pointing at the end of the container is updated. What does this mean?</p>

<p>Many things.</p>
<ul>
  <li>The size of the container doesnâ€™t change.</li>
  <li>Elements are still there at the end of the container</li>
  <li>Destructors are not called by running <code class="language-plaintext highlighter-rouge">std::remove</code></li>
  <li>In fact, what elements are there at the end is undefined beaviour. They might be the elements you removed or the original elements at those positions. Up to the implementation.</li>
</ul>

<p>At the time of writing, <a href="http://coliru.stacked-crooked.com/a/8df97662d3faa232">coliru</a>, compiled with gdb and with version C++ 17, keep in positions the original values, while they are also copied to the left.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>

<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"number of elements in vector: "</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"numbers before remove: "</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">;</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="err">Â </span> 
<span class="err">Â </span> <span class="k">auto</span> <span class="n">beginning_of_removed_items</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span> 
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"number of elements in vector after remove/before erase: "</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"numbers after after remove/before erase: "</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">;</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="err">Â </span> <span class="n">numbers</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">beginning_of_removed_items</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="err">Â </span> 
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"number of elements in vector after erase: "</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"numbers after erase: "</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">;</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="err">Â </span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Hence you donâ€™t usually use <code class="language-plaintext highlighter-rouge">std::remove</code> on its own, but by combined with <code class="language-plaintext highlighter-rouge">&lt;your container type&gt;::erase</code> that actually removes items in the passed in range.</p>

<p>As <code class="language-plaintext highlighter-rouge">std::remove</code> returns an iterator to the first element that has been moved to the end by passing that one and the original <code class="language-plaintext highlighter-rouge">end()</code> iterator to <code class="language-plaintext highlighter-rouge">erase</code> will do the work for you.</p>

<p>By the way, if you think about it, <code class="language-plaintext highlighter-rouge">std::remove</code> can be a quite slow operation. Removing an element than having another to take its place - depending on the underlying data structure - can be very slow. If itâ€™s a linked list, this can mean just updating a link (or two if its a doubly-linked list) - apart from scanning the items for comparison -, but if we talk about a vector, in other words, a dynamic array where elements are stored in a contiguous memory area, removing an element will invoke copy operations. Probably a lot. Each on the right of the element being removed will be copied. Then if there is another element to be removed, the same will happen, elements on the right, shifted by one to the left.</p>

<p>Hence, you have to choose wisely the data structure you want to use, depending on the use caseâ€¦</p>

<p>I digressed a bit, but I think it was important.</p>

<p>Please note that what I mentioned in this section are true for the other <code class="language-plaintext highlighter-rouge">remove</code> algorithms, except that elements are compared to the values passed in</p>

<h2 id="remove_if"><code class="language-plaintext highlighter-rouge">remove_if</code></h2>

<p>Just like <code class="language-plaintext highlighter-rouge">std::remove</code>, <code class="language-plaintext highlighter-rouge">std::remove_if</code> takes the passed in range the usual way, but as a third parameter it accepts a unary predicate. It can be a function, a function object, or a <a href="http://sandordargo.com/blog/2018/12/19/c++-lambda-expressions">lambda function</a> that takes an element of the container and compares it against something defined in the function and returns a boolean. If it returns true, that element will be removed - as remove was defined in the previous section -, if not, the element survives.
Just like for <code class="language-plaintext highlighter-rouge">remove</code>, as a return value you get back an iterator pointing to the beginning of the removed values. Prefer using <code class="language-plaintext highlighter-rouge">remove</code> combined with <code class="language-plaintext highlighter-rouge">erase</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>

<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"original numbers: "</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">;</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="err">Â </span> 
<span class="err">Â </span> <span class="n">numbers</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;}),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="err">Â </span> 
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"numbers after removing/erasing the even ones: "</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">;</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="err">Â </span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="remove_copy"><code class="language-plaintext highlighter-rouge">remove_copy</code></h2>

<p><code class="language-plaintext highlighter-rouge">remove_copy</code> doesnâ€™t change the input range. It will copy whatever doesnâ€™t match the passed in value, into another container. Iâ€™d dare to say that <code class="language-plaintext highlighter-rouge">remove_copy</code> is not the best possible name for this algorithm, Iâ€™d rather call it <code class="language-plaintext highlighter-rouge">copy_unless</code> or <code class="language-plaintext highlighter-rouge">copy_if_not</code>.</p>

<p>It accepts the input range with the usual two iterators pointing to the beginning and the end of the range. As a third parameter, it takes another iterator, pointing to the beginning of the range, you want to copy the non-matching elements to. The last parameter is the value that will not be copied to the new container.</p>

<p>Here is an example.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">copiedNumbers</span><span class="p">;</span>

<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">remove_copy</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">copiedNumbers</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
<span class="err">Â </span> 
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"copied numbers: "</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">number</span> <span class="o">:</span> <span class="n">copiedNumbers</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">;</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="err">Â </span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As we learned for the <a href="https://dev.to/sandordargo/the-big-stl-algorithms-tutorial-modifying-sequence-operations-copy-et-al-1751"><code class="language-plaintext highlighter-rouge">std::copy</code> algorithms</a>, the output container either has to be big enough to accommodate the values copied into it, or you have to use an inserter, such as <a href="https://en.cppreference.com/w/cpp/iterator/back_inserter">back inserter</a>.</p>

<h2 id="remove_copy_if"><code class="language-plaintext highlighter-rouge">remove_copy_if</code></h2>

<p><code class="language-plaintext highlighter-rouge">remove_copy_if</code> is the combination of <code class="language-plaintext highlighter-rouge">remove_copy</code> and <code class="language-plaintext highlighter-rouge">remove_if</code>. It takes an input range defined by the usual two parameters, then just like <code class="language-plaintext highlighter-rouge">remove_copy</code>, it takes the third one to define the beginning of the output range - where elements will be copied to - and as <code class="language-plaintext highlighter-rouge">remove_if</code>, it takes a predicate as the last parameter that helps to decide whether an element should be removed, in other words not copied, or kept, a.k.a. copied.</p>

<p>Iâ€™m sure that by now you know that the predicate can be a <a href="http://sandordargo.com/blog/2018/12/19/c++-lambda-expressions">lambda expression</a>, a functor or a function pointer.Â </p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">copiedNumbers</span><span class="p">;</span>

<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">remove_copy_if</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">copiedNumbers</span><span class="p">),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;});</span>
<span class="err">Â </span> 
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"copied numbers: "</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">number</span> <span class="o">:</span> <span class="n">copiedNumbers</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">;</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="err">Â </span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>Today, we learned about 4 algorithms removing values from a container. <code class="language-plaintext highlighter-rouge">remove</code> and <code class="language-plaintext highlighter-rouge">remove_if</code> will perform in-place modifications, while <code class="language-plaintext highlighter-rouge">remove_copy</code> and <code class="language-plaintext highlighter-rouge">remove_copy_if</code> will not touch the input, but instead will create a new output range without the values that we wanted to remove.</p>

<p>Next time weâ€™ll learn about the <code class="language-plaintext highlighter-rouge">reverse</code> algorithms. Stay tuned!</p>
:ET