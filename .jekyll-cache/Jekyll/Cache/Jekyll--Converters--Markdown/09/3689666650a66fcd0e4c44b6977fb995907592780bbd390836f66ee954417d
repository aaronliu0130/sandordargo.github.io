I"om<p>During the last month or so, we examined the ins and outs of C++ concepts. We checked their <a href="https://www.sandordargo.com/blog/2021/02/10/cpp-concepts-motivations">main motivations</a>, we saw <a href="https://www.sandordargo.com/blog/2021/02/17/cpp-concepts-4-ways-to-use-them">how we can use them with functions</a>, <a href="https://www.sandordargo.com/blog/2021/02/24/cpp-concepts-with-classes">with classes</a> and <a href="https://www.sandordargo.com/blog/2021/03/03/cpp-concepts-in-standard-library">what kind of concepts are shipped with the standard library</a>. Then during the last two weeks, we discovered how to write our own ones (<a href="https://www.sandordargo.com/blog/2021/03/10/write-your-own-cpp-concepts-part-i">part I</a>, <a href="https://www.sandordargo.com/blog/2021/03/17/write-your-own-cpp-concepts-part-ii">part II</a>).
<!--more-->
To conclude this series, let’s see two real-world examples of useful concepts.</p>

<h2 id="numbers-finally">Numbers finally</h2>

<p>We’ve been playing with a concept called <code class="language-plaintext highlighter-rouge">Number</code> for weeks. I’ve always said it’s incomplete. Let’s have a quick reminder of why:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
#include &lt;iostream&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Number</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">Number</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="n">Number</span> <span class="k">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"add(1, 2): "</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"add(1, 2.14): "</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.14</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="c1">// std::cout &lt;&lt; "add(\"one\", \"two\"): " &lt;&lt; add("one", "two") &lt;&lt; '\n'; // error: invalid operands of types 'const char*' and 'const char*' to binary 'operator+'</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"add(true, false): "</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
add(1, 2): 3
add(1, 2.14): 3.14
add(true, false): 1
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Our problem is that even though we only want to accept integrals and floating-point numbers, <code class="language-plaintext highlighter-rouge">bool</code>s are also accepted. <code class="language-plaintext highlighter-rouge">bool</code>s are accepted because <code class="language-plaintext highlighter-rouge">bool</code> is an integral type.</p>

<p>There is even worse! <code class="language-plaintext highlighter-rouge">add(0, 'a')</code> returns 97 as <code class="language-plaintext highlighter-rouge">a</code> is a character and as such it’s considered an integral type. The ASCII code of <code class="language-plaintext highlighter-rouge">a</code> is 97 and if you add that to 0, you get the result of this call.</p>

<p>But let’s say, we really want to accept numbers and let’s say in the constrained world of <em>real numbers</em>.</p>

<p>We have to limit the types we accept. As <code class="language-plaintext highlighter-rouge">std::is_floating_point</code> returns <code class="language-plaintext highlighter-rouge">true</code> only for <code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">double</code> and <code class="language-plaintext highlighter-rouge">long double</code>, there is no problem there. But floating-point numbers are not enough and as we already saw, <code class="language-plaintext highlighter-rouge">std::is_integral</code> returns <code class="language-plaintext highlighter-rouge">true</code> for some types that we might not want to accept as numbers.</p>

<p>The following types and their <code class="language-plaintext highlighter-rouge">const</code> and/or <code class="language-plaintext highlighter-rouge">unsgined</code> versions are considered integral:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bool</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">char</code>, <code class="language-plaintext highlighter-rouge">char8_t</code>, <code class="language-plaintext highlighter-rouge">char16_t</code>, <code class="language-plaintext highlighter-rouge">char32_t</code>, <code class="language-plaintext highlighter-rouge">wchar_t</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">long long</code></li>
</ul>

<p>But we only want to accept the types from the third line, booleans and characters are not our cups of tea.</p>

<p>Before C++20, we’d have to either disallow certain overloads or use static assertions with templates to make sure that only certain types would be accepted.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">addPreCpp20</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">"addPreCpp20 requires integral types"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">addPreCpp20</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// valid</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">addPreCpp20</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.14</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// woulnd't compile, static assertion fails</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The main problem with these that we’d have to do the same steps for each function, for each parameter.</p>

<p>With overloads, we might end up with a too-long list of combinations (when you have 3 numeric parameters that you want to constrain), or your templates are either too repetitive or just too complex for most working on the codebase.</p>

<p>C++20 brought us concepts and we have to define our <code class="language-plaintext highlighter-rouge">Number</code> concept only once, and then <a href="https://www.sandordargo.com/blog/2021/02/17/cpp-concepts-4-ways-to-use-them">it’s easy to use it</a>.</p>

<p>Just repeat our requirements:</p>
<ul>
  <li>we want to accept floating-point numbers</li>
  <li>we want to accept integral numbers</li>
  <li>we don’t want to accept integral types that can be converted to <code class="language-plaintext highlighter-rouge">int</code>s such as <code class="language-plaintext highlighter-rouge">bool</code>s and <code class="language-plaintext highlighter-rouge">char</code>s.</li>
</ul>

<p>As the first trial, you might try something like this</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Number</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> 
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">char8_t</span><span class="o">&gt;</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">char16_t</span><span class="o">&gt;</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">char32_t</span><span class="o">&gt;</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">wchar_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">Number</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="n">Number</span> <span class="k">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>              
</pre></td></tr></tbody></table></code></pre></div></div>

<p>But we are not done yet. The following compiles and prints 139!</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We have to include all the unsigned versions! Luckily only <code class="language-plaintext highlighter-rouge">char</code> has an unsigned eversion. <code class="language-plaintext highlighter-rouge">const</code>s we don’t have to permit as those as a <code class="language-plaintext highlighter-rouge">const char</code> would be automatically considered a <code class="language-plaintext highlighter-rouge">char</code> and therefore it wouldn’t compile.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
#include &lt;iostream&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Number</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> 
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span>                 
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">char8_t</span><span class="o">&gt;</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">char16_t</span><span class="o">&gt;</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">char32_t</span><span class="o">&gt;</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">wchar_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">Number</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="n">Number</span> <span class="k">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"add(1, 2): "</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"add(1, 2.14): "</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.14</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="c1">// std::cout &lt;&lt; "add(\"one\", \"two\"): " &lt;&lt; add("one", "two") &lt;&lt; '\n'; // error: invalid operands of types 'const char*' and 'const char*' to binary 'operator+'</span>
    <span class="c1">// std::cout &lt;&lt; "add(true, false): " &lt;&lt; add(true, false) &lt;&lt; '\n'; // unsatisfied constraints</span>
    <span class="c1">// const char c = 'a';</span>
    <span class="c1">// std::cout &lt;&lt; add(c, 42); // unsatisfied constraints</span>
    <span class="c1">// unsigned char uc = 'a';</span>
    <span class="c1">// std::cout &lt;&lt; add(uc, 42); // unsatisfied constraints</span>
<span class="p">}</span>
<span class="cm">/*
add(1, 2): 3
add(1, 2.14): 3.14
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="utility-functions-constrained">Utility functions constrained</h2>

<p>Utility functions are most often not used in the enclosing class - if there is any - but with other types.</p>

<p>Usually using them doesn’t make sense but only with certain types. If the number of types is limited enough, or maybe they are even tied to a class hierarchy, it’s straightforward how or at least with what you can use the utilities.</p>

<p>But if the available types are broad enough, often they are templatized. In such cases, documentation and (template) parameter names can come to the rescue. It’s better than nothing, but not optimal.</p>

<p>As we all learned, the best documentation is code. The best way to document behaviour is through unit tests and through code that expresses its own intentions. If it can make unintended usage impossible, even better! Preferably by compilation errors, or at worst with runtime failures. (Watch <a href="https://www.youtube.com/watch?v=nLSm3Haxz0I">this video</a> by Matt Godbolt on the topic!)</p>

<p>Concepts provide a concise and readable way to tell the reader about the types that are supposed to be used.</p>

<p>By checking a codebase I often work with, I found some helper functions encoding messages by taking the values from some data objects. The data objects these helper functions can deal with are nowhere listed and the parameter names offer very little help. As the business object taken are also templatized, you’ll end up either with a try-and-fail approach our you have to dig deep in the code to understand what it does with the passed-in objects, how they are accessed, etc.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">BusinessObject</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">encodeSomeStuff</span><span class="p">(</span><span class="n">BusinessObject</span> <span class="n">iBusinessObject</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">doStuff</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>With concepts, we could make this simpler by creating a concept that lists all the characteristics of the business objects this encoder is designed to deal with and that’s it!</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">BusinessObjectWithEncodeableStuff_t</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">BusinessObjectWithEncodeableStuff</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">BusinessObjectWithEncodeableStuff_t</span> <span class="n">bo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bo</span><span class="p">.</span><span class="n">interfaceA</span><span class="p">();</span>
  <span class="n">bo</span><span class="p">.</span><span class="n">interfaceB</span><span class="p">();</span>
  <span class="p">{</span> <span class="n">bo</span><span class="p">.</span><span class="n">interfaceC</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="nf">encodeSomeStuff</span><span class="p">(</span><span class="n">BusinessObjectWithEncodeableStuff</span> <span class="k">auto</span> <span class="n">iBusinessObject</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">doStuff</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Or if the concept would not be used in other places, you might not want to name it, just use it like you would use an <a href="https://www.sandordargo.com/blog/2020/02/19/immediately-invoked-lambda-functions">immediately invoked lambda function</a> without attaching any name to it.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">BusinessObjectWithEncodeableStuff</span><span class="p">&gt;</span>
<span class="n">requires</span> <span class="nf">requires</span> <span class="p">(</span><span class="n">BusinessObjectWithEncodeableStuff</span> <span class="n">bo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bo</span><span class="p">.</span><span class="n">interfaceA</span><span class="p">();</span>
  <span class="n">bo</span><span class="p">.</span><span class="n">interfaceB</span><span class="p">();</span>
  <span class="p">{</span> <span class="n">bo</span><span class="p">.</span><span class="n">interfaceC</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">encodeSomeStuff</span><span class="p">(</span><span class="n">BusinessObjectWithEncodeableStuff</span> <span class="n">iBusinessObject</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">doStuff</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Do you see that <code class="language-plaintext highlighter-rouge">requires</code> is written twice written twice? It’s not a typo! This is finally a good place to use nested constraints. We cannot directly use a parameter in a template function with a <code class="language-plaintext highlighter-rouge">requires</code> clause, but it’s possible to use an unnamed constraint, or if you prefer to say so a nested constraint.</p>

<p>With the demonstrated ways, we won’t simplify our utilities, but we’ll make them self-documenting. By using concepts they reveal with kind of types they were meant to be used. Should you try to compile them with any different parameter, you’ll receive quite decent error messages from the compiler.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Today, in the last part of the C++20 concepts series we saw two real-life examples of how concepts can make our code more expressive, how they can increase the understandability and maintainability of our code.</p>

<p>I hope you enjoyed this series as much as I did, let me know in the comments if you feel that I should have covered some topics more deeply.</p>

<p>If you’re looking forward to getting even more examples and more verbose explanations that wouldn’t fit the size limits of blog posts, <a href="https://leanpub.com/cppconcepts">enter your e-mail address here</a> to get notified once my book on concepts is released!</p>

:ET