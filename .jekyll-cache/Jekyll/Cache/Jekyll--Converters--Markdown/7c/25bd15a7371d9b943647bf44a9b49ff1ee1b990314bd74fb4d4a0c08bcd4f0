I"ò¨<p>In this next part of <a href="http://sandordargo.com/blog/2019/01/30/stl-algos-intro">the big STL algorithm tutorial</a>, we cover the sorting operations - except for ranges which will be covered in a different series.
<!--more--></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sort</code></li>
  <li><code class="language-plaintext highlighter-rouge">stable_sort</code></li>
  <li><code class="language-plaintext highlighter-rouge">partial_sort</code></li>
  <li><code class="language-plaintext highlighter-rouge">partial_sort_copy</code></li>
  <li><code class="language-plaintext highlighter-rouge">is_sorted</code></li>
  <li><code class="language-plaintext highlighter-rouge">is_sorted_until</code></li>
  <li><code class="language-plaintext highlighter-rouge">nth_element</code></li>
</ul>

<h2 id="sort"><code class="language-plaintext highlighter-rouge">sort</code></h2>

<p>Is it a bit too much to say that <code class="language-plaintext highlighter-rouge">std::sort</code> is the flagship algorithm of the above sorting algorithms? Probably not, at least if we discuss the basics for this algorithm, we donâ€™t need to discuss all the details for each other.</p>

<p>By default, <code class="language-plaintext highlighter-rouge">std::sort</code> takes two parameters, two iterators that define a range that the user wants to sort.</p>

<p>There is a third optional parameter to define, the comparator that is used for the sorting. As usual, it can be a lambda, a function pointer or a function object (a functor). Itâ€™s a binary function, it accepts two elements and returns a bool - or at least a value that is convertible into bool. This function shouldnâ€™t modify any of its components that seems quite reasonable. The function should return <code class="language-plaintext highlighter-rouge">true</code> if the first parameter should precede the second in the sorted range.</p>

<p><code class="language-plaintext highlighter-rouge">std::sort</code> is a void algorithm, it doesnâ€™t return anything. Letâ€™s see an example with and without a comparator.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">Transmission</span> <span class="p">{</span><span class="n">Automatic</span><span class="p">,</span> <span class="n">Manual</span><span class="p">};</span>

<span class="k">struct</span> <span class="nc">Car</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">horsePower</span><span class="p">;</span>
  <span class="n">Transmission</span> <span class="n">transmission</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">num</span><span class="p">){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;});</span>    
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">cars</span> <span class="p">{</span>
    <span class="n">Car</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Automatic</span><span class="p">},</span>
    <span class="n">Car</span><span class="p">{</span><span class="mi">80</span><span class="p">,</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Manual</span><span class="p">},</span>
    <span class="n">Car</span><span class="p">{</span><span class="mi">250</span><span class="p">,</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Manual</span><span class="p">},</span>
    <span class="n">Car</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Manual</span><span class="p">},</span>
    <span class="n">Car</span><span class="p">{</span><span class="mi">120</span><span class="p">,</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Automatic</span><span class="p">},</span>
  <span class="p">};</span>
  
  <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">cars</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cars</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Car</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Car</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">horsePower</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">horsePower</span><span class="p">;});</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">cars</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cars</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">car</span><span class="p">){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Car.hp "</span> <span class="o">&lt;&lt;</span> <span class="n">car</span><span class="p">.</span><span class="n">horsePower</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">car</span><span class="p">.</span><span class="n">transmission</span> <span class="o">==</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Manual</span><span class="p">)</span> <span class="o">?</span> <span class="s">"manual"</span> <span class="o">:</span> <span class="s">"automatic"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;});</span>    
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>I think the above examples are pretty straightforward, what is worth to notice is how the comparator is written. As smaller performance cars should come before the stronger ones - at least in our examples - the comparator returns <code class="language-plaintext highlighter-rouge">true</code> if the first passed in car is weaker than the second. Thatâ€™s how we built an ascendingly sorted container.</p>

<h2 id="stable_sort"><code class="language-plaintext highlighter-rouge">stable_sort</code></h2>

<p>What is the difference between <code class="language-plaintext highlighter-rouge">stable_sort</code> and <code class="language-plaintext highlighter-rouge">sort</code>?</p>

<p><code class="language-plaintext highlighter-rouge">stable_sort</code> gives us a guarantee that the order of equivalent elements will be preserved after the algorithm applied. <code class="language-plaintext highlighter-rouge">sort</code> doesnâ€™t give any such promise.</p>

<p>In other words, sticking with the example of cars, if in the input container a manual gearbox car precedes an automatic one and they both have the same performance, itâ€™ll come before it even after calling <code class="language-plaintext highlighter-rouge">stable_sort</code> on them.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">Transmission</span> <span class="p">{</span><span class="n">Automatic</span><span class="p">,</span> <span class="n">Manual</span><span class="p">};</span>

<span class="k">struct</span> <span class="nc">Car</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">horsePower</span><span class="p">;</span>
  <span class="n">Transmission</span> <span class="n">transmission</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">cars</span> <span class="p">{</span>
    <span class="n">Car</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Automatic</span><span class="p">},</span>
    <span class="n">Car</span><span class="p">{</span><span class="mi">80</span><span class="p">,</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Manual</span><span class="p">},</span>
    <span class="n">Car</span><span class="p">{</span><span class="mi">250</span><span class="p">,</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Manual</span><span class="p">},</span>
    <span class="n">Car</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Manual</span><span class="p">},</span>
    <span class="n">Car</span><span class="p">{</span><span class="mi">120</span><span class="p">,</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Automatic</span><span class="p">},</span>
  <span class="p">};</span>
  
  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">cars</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cars</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Car</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Car</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">horsePower</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">horsePower</span><span class="p">;});</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">cars</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cars</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">car</span><span class="p">){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Car.hp "</span> <span class="o">&lt;&lt;</span> <span class="n">car</span><span class="p">.</span><span class="n">horsePower</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">car</span><span class="p">.</span><span class="n">transmission</span> <span class="o">==</span> <span class="n">Transmission</span><span class="o">::</span><span class="n">Manual</span><span class="p">)</span> <span class="o">?</span> <span class="s">"manual"</span> <span class="o">:</span> <span class="s">"automatic"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;});</span>    
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="partial_sort"><code class="language-plaintext highlighter-rouge">partial_sort</code></h2>

<p>As the name suggests, this algorithm is not going to sort the whole container. But what does it sort exactly?</p>

<p>It takes three iterators as an input, plus an optional comparator that isnâ€™t different from the comparators we already saw. Letâ€™s focus on the three iterators.</p>

<p>The first one denotes the beginning of the input range, the third one the end of it.</p>

<p>The middle one gives the point up until you want the range to be sorted. Itâ€™s worth to emphasize that this iterator denotes the position up until you want to sort the range, not the last sorted value.</p>

<p>Letâ€™s have a look at a simple example.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">numbers</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  
  <span class="n">std</span><span class="o">::</span><span class="n">partial_sort</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">number</span><span class="p">){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;});</span>    
<span class="p">}</span>
<span class="cm">/*
1 2 3 4 9 8 7 6 5 
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this example, we have a vector of numbers from 1 to 9 in random order. (Notice how you can omit the contained type with C++20!) We call <code class="language-plaintext highlighter-rouge">partial_sort</code> on the whole container where the <em>middle</em> element is <code class="language-plaintext highlighter-rouge">numbers.begin()+4</code>.</p>

<p><code class="language-plaintext highlighter-rouge">numbers.begin()+4</code> points at the position of <code class="language-plaintext highlighter-rouge">9</code> in the original vector, which is the fifth number (position 4 starting from 0). So our call to <code class="language-plaintext highlighter-rouge">partial_sort</code> means that we want to sort the elements up until the fifth element (excluded), so the first four elements.</p>

<p>The result that is <code class="language-plaintext highlighter-rouge">1 2 3 4 9 8 7 6 5</code> exactly shows that. In the first 4 places, we have the elements sorted, and after not. It seems like they follow a reversed sorting, but donâ€™t be deceived, thatâ€™s just coincidence. The elements after position <code class="language-plaintext highlighter-rouge">middle</code> do not follow any particular order.</p>

<h2 id="partial_sort_copy"><code class="language-plaintext highlighter-rouge">partial_sort_copy</code></h2>

<p><code class="language-plaintext highlighter-rouge">partial_sort_copy</code> is more different from <code class="language-plaintext highlighter-rouge">partial_sort</code> then many would expect. Based on what we have seen so far in this series, you most probably think that it has the same signature apart from an extra parameter denoting the beginning of the output range.</p>

<p>But itâ€™s not the case.</p>

<p>Instead of three input iterators, it only takes two. One for the beginning and one for the end of the range we want to partially sort. Then it takes two output iterators one for the beginning and one for the end of the range we want to copy our sorted elements.</p>

<p>And of course, there is the usual optional comparator.</p>

<p>The length of this output range defines how many elements will be sorted. Letâ€™s have a look at the example:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">numbers</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">output</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  
  <span class="n">std</span><span class="o">::</span><span class="n">partial_sort_copy</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">output</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">output</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">output</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">number</span><span class="p">){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;});</span>    
<span class="p">}</span>
<span class="cm">/*
1 2 3 4 
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>There are a couple of things to notice.</p>
<ul>
  <li>Only the sorted elements will be copied.</li>
  <li><code class="language-plaintext highlighter-rouge">std::partial_sort_copy</code> checks the size of the output range, not its capacity. In other words, if you default initialize a vector and then you reserve a capacity, nothing will be copied over because the size of the output vector is still 0.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">numbers</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">output</span><span class="p">;</span>
  <span class="n">output</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  
  <span class="n">std</span><span class="o">::</span><span class="n">partial_sort_copy</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">output</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">output</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="s">"is the output empty? "</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
is the output empty? true
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Personally, I find the signature of this algorithm not so great. Itâ€™s not following the practices we got used to in the <code class="language-plaintext highlighter-rouge">&lt;algorithms&gt;</code> header. I think that defining the output range is impractical. Itâ€™s safer than asking only for the beginning where the caller has to make sure that output is big enough to accommodate all the inserted elements. Yet, with this solution, you must initialize a vector to a certain size and that means either copying the same element n times at initialization or the default initialization of n elements. It might be cheap, but in certain cases, it might be expensive. Whereas when you can simply pass in a <code class="language-plaintext highlighter-rouge">std::back_inserter</code> as an output, itâ€™s not an issue.</p>

<h2 id="is_sorted"><code class="language-plaintext highlighter-rouge">is_sorted</code></h2>

<p><code class="language-plaintext highlighter-rouge">is_sorted</code> is super simple. It takes the beginning and the end of a range an optional comparator and tell you whether the range is sorted or not by returning a <code class="language-plaintext highlighter-rouge">bool</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">sortedNumbers</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">unsortedNumbers</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">descendingNumbers</span> <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="s">"is the sortedNumbers sorted? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">sortedNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sortedNumbers</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="s">"is the unsortedNumbers sorted? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">unsortedNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">unsortedNumbers</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="s">"is the descendingNumbers sorted? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">descendingNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">descendingNumbers</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="s">"is the descendingNumbers sorted? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">descendingNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">descendingNumbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">lfs</span><span class="p">,</span> <span class="k">auto</span> <span class="n">rhs</span><span class="p">){</span> <span class="k">return</span> <span class="n">lfs</span> <span class="o">&gt;</span> <span class="n">rhs</span><span class="p">;</span> <span class="p">})</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="s">"is the descendingNumbers sorted? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">descendingNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">descendingNumbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;&gt;</span><span class="p">{})</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 
is the sortedNumbers sorted? true
is the unsortedNumbers sorted? false
is the descendingNumbers sorted? false
is the descendingNumbers sorted? true
is the descendingNumbers sorted? true
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Itâ€™s worth to remind ourselves that being sorted is calculated based on using <code class="language-plaintext highlighter-rouge">operator&lt;</code>. Order matters, even if you think that <code class="language-plaintext highlighter-rouge">descendingNumbers</code> are nicely sorted, <code class="language-plaintext highlighter-rouge">std::is_sorted</code> doesnâ€™t think so by default. If you want to compare based on another comparator you have to pass it, just like you can see in the last two lines.</p>

<h2 id="is_sorted_until"><code class="language-plaintext highlighter-rouge">is_sorted_until</code></h2>

<p><code class="language-plaintext highlighter-rouge">is_sorted_until</code> takes a range defined by its beginning and its end and an optional comparator. It returns an iterator that points to the last sorted element starting the first item.</p>

<p>Meaning that if you call <code class="language-plaintext highlighter-rouge">is_sorted</code> with the beginning of the inspected range and with the return value <code class="language-plaintext highlighter-rouge">is_sorted_until</code>, it will return <code class="language-plaintext highlighter-rouge">true</code>. On the other hand, if you call it with the return value + 1, the result will be <code class="language-plaintext highlighter-rouge">false</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">numbers</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
  <span class="k">auto</span> <span class="n">lastSortedNumber</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_sorted_until</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Last sorted number in numbers: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">lastSortedNumber</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"std::is_sorted(numbers.begin(), lastSortedNumber): "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lastSortedNumber</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"std::is_sorted(numbers.begin(), lastSortedNumber+1): "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lastSortedNumber</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
Last sorted number in numbers: 5
std::is_sorted(numbers.begin(), lastSortedNumber): true
std::is_sorted(numbers.begin(), lastSortedNumber+1): false
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="nth_element"><code class="language-plaintext highlighter-rouge">nth_element</code></h2>

<p><code class="language-plaintext highlighter-rouge">nth_element</code> is a function that told me nothing by its name when I looked at it. Do you get it just like that?</p>

<p>Ok, I tell you. Letâ€™s ignore for a moment the arguments it takes.</p>

<p><code class="language-plaintext highlighter-rouge">nth_element</code> will rearrange the container in a way that at the nth position you will find the element that would be there if the container was sorted.</p>

<p>Before there will be smaller or equal elements not following any particular order and larger ones after.</p>

<p>The parameters are quite similar to <code class="language-plaintext highlighter-rouge">partial_sort</code>. The first parameter denotes the beginning, the third the end and in the middle, you have the nth element. As usual, you can pass in a custom comparator.</p>

<p>Letâ€™s have a look at an example.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">numbers</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">number</span><span class="p">){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;});</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The fifth largest element is: "</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
3 2 1 4 5 6 7 8 9 
The fifth largest element is: 5

*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>In the above example, by passing in <code class="language-plaintext highlighter-rouge">numbers.begin()+4</code> as the middle parameter we determined what is the 5th largest element in <code class="language-plaintext highlighter-rouge">numbers</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Today, we learned about sorting algorithms. Some are pretty straightforward (such as <code class="language-plaintext highlighter-rouge">sort</code>, <code class="language-plaintext highlighter-rouge">partial_sort</code> or <code class="language-plaintext highlighter-rouge">is_sorted</code>), while <code class="language-plaintext highlighter-rouge">nth_element</code> made us - at least me - think and <code class="language-plaintext highlighter-rouge">partial_sort_copy</code> gave us some surprises and inconsistencies. I hope you enjoyed todayâ€™s discoveries, next time weâ€™ll move from sorting algorithms to binary searches.</p>

<h2 id="connect-deeper">Connect deeper</h2>

<p>If you found interesting this article, please <a href="http://eepurl.com/gvcv1j">subscribe to my personal blog</a> and letâ€™s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</p>
:ET