I",<p>Python 3.8 is coming and not surprisingly it comes with <a href="https://docs.python.org/3.9/whatsnew/3.8.html">a bag of new features</a>. In this post, I’d like to present only one that I’ve been really waiting for: assignment expressions!
<!--more--></p>
<h2 id="the-problem">The problem</h2>

<p>Whenever we see a new solution, we have to understand the problem or if there is a problem at all in the first place.</p>

<p>Let’s take this piece of code</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="err"> </span> <span class="n">result</span> <span class="o">=</span> <span class="n">s</span>
<span class="err"> </span> <span class="c1"># ... do some stuff
</span><span class="err"> </span> <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
<span class="err"> </span> <span class="k">return</span> <span class="bp">True</span> <span class="c1"># for the sake of the example
</span>
<span class="n">t</span><span class="o">=</span><span class="nb">input</span><span class="p">()</span>
<span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="p">():</span>
<span class="err"> </span> <span class="err"> </span><span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span><span class="c1"># do something with p
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Here we can identify at least two problems:</p>

<ul>
  <li>We have code duplication as we wrote <code class="language-plaintext highlighter-rouge">f(s)</code> twice, while it’s part of the same logical branch</li>
  <li>What is evident, but it is even worse, we don’t just write, but we call f(s) twice. Even if we assume that with the same input we’ll always have the same outputs, so the function is deterministic and might even be pure, we might face some issues. What if it triggers expensive calculations? Well, then we do it twice, which might have bad consequences.</li>
</ul>

<p>There is a solution, we can call f(s) once before the <code class="language-plaintext highlighter-rouge">if</code> block, and save the result in a variable!</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="err"> </span> <span class="n">result</span> <span class="o">=</span> <span class="n">s</span>
<span class="err"> </span> <span class="c1"># ... do some stuff
</span><span class="err"> </span> <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
<span class="err"> </span> <span class="k">return</span> <span class="bp">True</span> <span class="c1"># for the sake of the example
</span>
<span class="n">t</span><span class="o">=</span><span class="nb">input</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="k">if</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">g</span><span class="p">():</span>
<span class="err"> </span> <span class="err"> </span><span class="c1"># do something with p
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Is that better? Well, it depends.</p>

<p>On the one hand, you type a bit less and if the calculations in <code class="language-plaintext highlighter-rouge">f(s)</code> are costly, you eliminated that expensive function call, that’s great!</p>

<p>On the other hand, now you have a variable that is accessible outside the <code class="language-plaintext highlighter-rouge">if</code> block where you orientally wanted to use it. This might be unsafe. Imagine that you create your variable as a reference to something that takes a long-chained command to retrieve.</p>

<p>But before you use it, you want to make a validity check.</p>

<p>If you create the variable outside the if block, so before making the validity check, you have to remember that if you want to use that variable later on in that function (which would probably be a bad practice anyway), you must do the validity check again.</p>

<p>Python 3.8 and <a href="https://www.python.org/dev/peps/pep-0572/">PEP 572</a> provides us with the ultimate solution you probably always wanted for such issues.</p>

<p>You can create a variable in the <code class="language-plaintext highlighter-rouge">if</code> expression whose scope is only the whole if block. Isn’t that awesome?! You can do things like this, just to continue with the previous example:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="err"> </span> <span class="n">result</span> <span class="o">=</span> <span class="n">s</span>
<span class="err"> </span> <span class="c1"># ...
</span><span class="err"> </span> <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
<span class="err"> </span> <span class="k">return</span> <span class="bp">True</span> <span class="c1"># for the sake of the example
</span>
<span class="n">t</span><span class="o">=</span><span class="nb">input</span><span class="p">()</span>
<span class="k">if</span> <span class="n">p</span><span class="p">:</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="p">():</span>
<span class="err"> </span> <span class="err"> </span><span class="c1"># do something with p
</span><span class="err"> </span> <span class="err"> </span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>By the “whole <code class="language-plaintext highlighter-rouge">if</code> block”, I meant that <code class="language-plaintext highlighter-rouge">else</code> is also included. To generalize, we can say that the scope of the variable assigned in the assignment expression is just the current scope. If it’s an if, then an if, if it’s the whole function, it’s the whole function.</p>

<p>What I also like a lot is that we now can simplify list comprehensions as well. Look at this example:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="n">numbers_and_int_square_roots</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="o">==</span> <span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="p">)}</span>
<span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">numbers_and_int_square_roots</span><span class="p">.</span><span class="n">items</span><span class="p">())</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>So, we take a list of numbers and we want to keep the ones that are squares of an integers and we also want to keep their squared and non-squared values. We have to calculate the square roots twice!</p>

<p>Only if I could save the square root in that generator expression! Lo and behold, now I can:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>inputs = [1, 2, 3, 56, 78, 42, 36, 54, 35, 99]
numbers_and_int_square_roots = {k: v for k in inputs if (v:=int(math.sqrt(k))) == math.sqrt(k)}
print(*numbers_and_int_square_roots.items())
</pre></td></tr></tbody></table></code></pre></div></div>
<p>That is just super cool to me! Less typing, less calculations, faster runtime!</p>

<p>What do you think?</p>

<h2 id="conclusion">Conclusion</h2>

<p><a href="https://docs.python.org/3.9/whatsnew/3.8.html">Python 3.8</a> introduces <a href="https://www.python.org/dev/peps/pep-0572/">assignment expressions</a> which lets us create new variables in places where we always wanted but never could in a usable way. Probably the best way to use this new feature is to create new variables in an <code class="language-plaintext highlighter-rouge">if</code> and use it in the scope of that block.</p>

<p>For more information, you can read the specs <a href="https://www.python.org/dev/peps/pep-0572/">here</a>.</p>

<p>As an online interpreter, for the moment you can use <a href="https://tio.run/#python38pr">this</a>.</p>

<p>And if you want to install python3.8 locally, you can refer to <a href="https://dev.to/mortoray/how-to-install-python-3-8-on-ubuntu-1bp4">this article</a></p>

<p>Happy coding!</p>
:ET