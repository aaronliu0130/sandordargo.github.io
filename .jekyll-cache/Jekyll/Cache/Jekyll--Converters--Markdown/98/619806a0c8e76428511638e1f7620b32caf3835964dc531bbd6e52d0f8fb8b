I"à9<p>The idea of concepts is one of the major new features added to C++20. Concepts are an extension for templates. They can be used to perform compile-time validation of template arguments through boolean predicates. They can also be used to perform function dispatch based on properties of types.
<!--more--></p>

<p>With concepts, you can <em>require</em> both syntactic and semantic conditions. In terms of syntactic requirements, imagine that you can impose the existence of certain functions in the API of any class. For example, you can create a concept <code class="language-plaintext highlighter-rouge">Car</code> that requires the existence of an <code class="language-plaintext highlighter-rouge">accelerate</code> function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Car</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">C</span> <span class="n">car</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">car</span><span class="p">.</span><span class="n">accelerate</span><span class="p">()</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Donâ€™t worry about the syntax, weâ€™ll get there next week.</p>

<p>Semantic requirements are more related to mathematical axioms, for example, you can think about associativy or commutativity:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>a + b == b + a // commutativity
(a + b) + c == a + (b + c) // associativity
</pre></td></tr></tbody></table></code></pre></div></div>
<p>There are concepts in the standard library expressing semantic requirements. Take for example <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable"><code class="language-plaintext highlighter-rouge">std::equality_comparable</code></a>.</p>

<p>It requires that</p>
<ul>
  <li>the two equality comparison between the passed in types are commutative,</li>
  <li><code class="language-plaintext highlighter-rouge">==</code> is symmetric, transitive and reflexive,</li>
  <li>and <code class="language-plaintext highlighter-rouge">equality_comparable_with&lt;T, U&gt;</code> is modeled only if, given any lvalue t of type <code class="language-plaintext highlighter-rouge">const std::remove_reference_t&lt;T&gt;</code> and any lvalue u of type <code class="language-plaintext highlighter-rouge">const std::remove_reference_t&lt;U&gt;,</code> and let C be <code class="language-plaintext highlighter-rouge">std::common_reference_t&lt;const std::remove_reference_t&lt;T&gt;&amp;, const std::remove_reference_t&lt;U&gt;&amp;&gt;</code>, <code class="language-plaintext highlighter-rouge">bool(t == u) == bool(C(t) == C(u))</code>.</li>
</ul>

<p>Though this latter one is probably a bit more difficult to decipher. Anyway, if you are looking for a thorough article dedicated to semantic requirements, read <a href="https://akrzemi1.wordpress.com/2020/10/26/semantic-requirements-in-concepts/">this one by Andrzej KrzemieÅ„ski</a>.</p>

<h2 id="the-motivation-behind-concepts">The motivation behind concepts</h2>

<p>We have briefly seen from a very high-level what we can express with concepts. But why do we need them in the first place?</p>

<p>For the sake of example, letâ€™s say you want to write a function that adds up two numbers. You want to accept both integral and floating-point numbers. What are you going to do?</p>

<p>You could accept <code class="language-plaintext highlighter-rouge">double</code>s, maybe even <code class="language-plaintext highlighter-rouge">long double</code>s and return a value of the same type.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="nf">add</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">{</span><span class="mi">66</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The problem is that when you call <code class="language-plaintext highlighter-rouge">add()</code> with two <code class="language-plaintext highlighter-rouge">int</code>s, they will be cast to <code class="language-plaintext highlighter-rouge">long double</code>. You might want a smaller memory footprint, or maybe youâ€™d like to take into account the maximum or minimum limits of a type. And anyway, itâ€™s not the best idea to rely on implicit conversions.</p>

<p>Implicit conversions might allow code to compile that was not at all in your intentions. Itâ€™s not bad by definition, but implicit conversions should be intentional and not accidental.</p>

<p>In this case, I donâ€™t think that an intentional cast is justified.</p>

<p>Defining overloads for the different types is another way to take, but it is definitely tedious.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="nf">add</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">{</span><span class="mi">66</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Imagine that you want to do this for <a href="https://en.cppreference.com/w/cpp/language/types">all the different numeric types</a>. Should we also do it for combinations of <code class="language-plaintext highlighter-rouge">long double</code>s and <code class="language-plaintext highlighter-rouge">short</code>s? Ehâ€¦ Thanks, but no thanks.</p>

<p>Another option is to define a template!</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">{</span><span class="mi">66</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">double</span> <span class="n">x</span><span class="p">{</span><span class="mf">42.42</span><span class="n">L</span><span class="p">};</span>
  <span class="kt">long</span> <span class="kt">double</span> <span class="n">y</span><span class="p">{</span><span class="mf">66.6</span><span class="n">L</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>If you have a look at <a href="https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGlvc3RyZWFtPgoKdGVtcGxhdGUgPHR5cGVuYW1lIFQ+ClQgYWRkKFQgYSwgVCBiKSB7CiAgICByZXR1cm4gYStiOwp9CgppbnQgbWFpbigpIHsKICBpbnQgYXs0Mn07CiAgaW50IGJ7NjZ9OwogIHN0ZDo6Y291dCA8PCBhZGQoYSwgYikgPDwgJ1xuJzsKICBsb25nIGRvdWJsZSB4ezQyLjQyTH07CiAgbG9uZyBkb3VibGUgeXs2Ni42TH07CiAgc3RkOjpjb3V0IDw8IGFkZCh4LCB5KSA8PCAnXG4nOwogIAp9Cg==&amp;insightsOptions=cpp17&amp;std=cpp17&amp;rev=1.0">CPP Insights</a> you will see that code was generated both for an <code class="language-plaintext highlighter-rouge">int</code> and for a <code class="language-plaintext highlighter-rouge">long double</code> overload. There is no static cast taking place at any point.</p>

<p>Are we good yet?</p>

<p>Unfortunately, no.</p>

<p>What happens if you try to call <code class="language-plaintext highlighter-rouge">add(true, false)</code>? Youâ€™ll get a <code class="language-plaintext highlighter-rouge">1</code> as <code class="language-plaintext highlighter-rouge">true</code> is promoted to an integer, summed up with <code class="language-plaintext highlighter-rouge">false</code> promoted to an integer and then they will be turned back (by <code class="language-plaintext highlighter-rouge">static_cast</code>) into a boolean.</p>

<p>What if you add up two string? They will be concatenated. But is that really what you want? Maybe you donâ€™t want that to be a valid operation and you prefer a compilation failure.</p>

<p>So you might have to forbid that <a href="https://dev.to/pgradot/forbid-a-particular-specialization-of-a-template-4348">template specialization</a>. And for how many types do you want to do the same?</p>

<p>What if you could simply say that you only want to add up integral or floating-point types. In brief, rational numbers. And here come <code class="language-plaintext highlighter-rouge">concepts</code> into the picture.</p>

<p>With concepts, you can easily express such requirements on template parameters.</p>

<p>You can precise requirements on</p>
<ul>
  <li>the validity of expressions (that certain functions should exist in the classâ€™ API)</li>
  <li>the return types of certain functions</li>
  <li>the existence of inner types, of template specializations</li>
  <li>the type-traits of the accepted types</li>
</ul>

<p>How? Thatâ€™s what we are going to explore in this series on C++ concepts.</p>

<h2 id="whats-next">Whatâ€™s next?</h2>

<p>During the next couple of weeks we are going to discuss:</p>

<ul>
  <li><a href="https://www.sandordargo.com/blog/2021/02/10/cpp-concepts-motivations">the 4 ways to use a concept</a></li>
  <li><a href="https://www.sandordargo.com/blog/2021/02/17/cpp-concepts-4-ways-to-use-them">how to use concepts with functions</a></li>
  <li><a href="https://www.sandordargo.com/blog/2021/02/24/cpp-concepts-with-classes">how to use concepts with classes</a></li>
  <li><a href="https://www.sandordargo.com/blog/2021/03/03/cpp-concepts-in-standard-library">what kind of predefined concepts the standard library introduced</a></li>
  <li>how to write our own concepts (<a href="https://www.sandordargo.com/blog/2021/03/10/write-your-own-cpp-concepts-part-i">part I</a> and <a href="https://www.sandordargo.com/blog/2021/03/17/write-your-own-cpp-concepts-part-ii">part II</a>)</li>
</ul>

<p>Stay tuned!</p>
:ET