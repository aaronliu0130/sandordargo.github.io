I"&¬<p>Last week we started to discuss <a href="https://www.sandordargo.com/blog/2021/03/10/write-your-own-cpp-concepts-part-i">how to write our own concepts</a>. Our first step was to combine different <a href="https://www.sandordargo.com/blog/2021/03/03/cpp-concepts-in-standard-library">already existing concepts</a>, then we continued with declaring constraints on the existence of certain operations, certain methods.
<!--more--></p>

<p>Today, we are going to discover how to express our requirements on function return types, how to write type requirements (and what they are) and we are going to finish with discussing nested requirements.</p>

<h2 id="write-your-own-constraints">Write your own constraints</h2>

<p>Last time, we had an example with the concept <code class="language-plaintext highlighter-rouge">HasSquare</code>. It accepts any type that has a <code class="language-plaintext highlighter-rouge">square</code> function regardless of the return type.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;concepts&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">HasSquare</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span><span class="p">.</span><span class="n">square</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">IntWithoutSquare</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">IntWithoutSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_num</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">IntWithSquare</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">IntWithSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_num</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">int</span> <span class="n">square</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m_num</span> <span class="o">*</span> <span class="n">m_num</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="nf">printSquare</span><span class="p">(</span><span class="n">HasSquare</span> <span class="k">auto</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">.</span><span class="n">square</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">printSquare</span><span class="p">(</span><span class="n">IntWithoutSquare</span><span class="p">{</span><span class="mi">4</span><span class="p">});</span> <span class="c1">// error: use of function 'void printSquare(auto:11) [with auto:11 = IntWithoutSquare]' with unsatisfied constraints, </span>
                                    <span class="c1">// the required expression 't.square()' is invalid</span>
  <span class="n">printSquare</span><span class="p">(</span><span class="n">IntWithSquare</span><span class="p">{</span><span class="mi">5</span><span class="p">});</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Now letâ€™s continue with constraining the return types.</p>

<h3 id="requirements-on-return-types-aka-compound-requirements">Requirements on return types (a.k.a compound requirements)</h3>

<p>Weâ€™ve seen how to write a requirement expressing the need of a certain API, a certain function.</p>

<p>But did we also constrain the return type of those functions?</p>

<p>No, we didnâ€™t. <code class="language-plaintext highlighter-rouge">IntWithSquare</code> satisfies the <code class="language-plaintext highlighter-rouge">HasSquare</code> concept both with <code class="language-plaintext highlighter-rouge">int square()</code> and <code class="language-plaintext highlighter-rouge">void square()</code>.</p>

<p>If you want to specify the return type, you must use something that is called a compound requirement.</p>

<p>Here is an example:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">HasSquare</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">square</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span> 
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Notice the following:</p>
<ul>
  <li>The expression on what you want to set a return type requirement must be surrounded by braces (<code class="language-plaintext highlighter-rouge">{}</code>), then comes an arrow (<code class="language-plaintext highlighter-rouge">-&gt;</code>) followed by the constraint of the return type.</li>
  <li>A constraint cannot simply be a type. Had you written simply <code class="language-plaintext highlighter-rouge">int</code>, you would receive an error message: <em>return-type-requirement is not a type-constraint.</em> The original concepts TS allowed the direct usage of types, so if you experimented with that, you might be surprised by this error. This possibility was removed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1452r2.html">P1452R2</a>.</li>
</ul>

<p>There are a number of reasons for this removal. One of the motivations was that it would interfere with a future direction of wanting to adopt a generalized form of <code class="language-plaintext highlighter-rouge">auto</code>, like <code class="language-plaintext highlighter-rouge">vector&lt;auto&gt;</code> or <code class="language-plaintext highlighter-rouge">vector&lt;Concept&gt;.</code></p>

<p>So instead of simply naming a type you have to choose a concept! If you want to set the return type one of the two following options will satisfy your needs:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">square</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">square</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>I think that the difference is obvious. In case of <code class="language-plaintext highlighter-rouge">std::same_as</code>, the return value must be the same as specified as the template argument, while with <code class="language-plaintext highlighter-rouge">std::convertible_to</code> conversions are allowed.</p>

<p>In order to demonstrate this, letâ€™s have a look at the following example:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;concepts&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">HasIntSquare</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">square</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">HasConvertibleToIntSquare</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">square</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">IntWithIntSquare</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">IntWithIntSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_num</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">int</span> <span class="n">square</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m_num</span> <span class="o">*</span> <span class="n">m_num</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">IntWithLongSquare</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">IntWithLongSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_num</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">long</span> <span class="n">square</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m_num</span> <span class="o">*</span> <span class="n">m_num</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">IntWithVoidSquare</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">IntWithVoidSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_num</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">void</span> <span class="n">square</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_num</span> <span class="o">*</span> <span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="nf">printSquareSame</span><span class="p">(</span><span class="n">HasIntSquare</span> <span class="k">auto</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">.</span><span class="n">square</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">printSquareConvertible</span><span class="p">(</span><span class="n">HasConvertibleToIntSquare</span> <span class="k">auto</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">.</span><span class="n">square</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">printSquareSame</span><span class="p">(</span><span class="n">IntWithIntSquare</span><span class="p">{</span><span class="mi">1</span><span class="p">});</span> <span class="c1">// int same as int</span>
<span class="c1">//   printSquareSame(IntWithLongSquare{2}); // long not same as int</span>
<span class="c1">//   printSquareSame(IntWithVoidSquare{3}); // void not same as int</span>
  <span class="n">printSquareConvertible</span><span class="p">(</span><span class="n">IntWithIntSquare</span><span class="p">{</span><span class="mi">4</span><span class="p">});</span> <span class="c1">// int convertible to int</span>
  <span class="n">printSquareConvertible</span><span class="p">(</span><span class="n">IntWithLongSquare</span><span class="p">{</span><span class="mi">5</span><span class="p">});</span> <span class="c1">// int convertible to int</span>
<span class="c1">//   printSquareConvertible(IntWithVoidSquare{6}); // void not convertible to int</span>
<span class="p">}</span>
<span class="cm">/*
1
16
25
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In the above example, we can observe that the class with <code class="language-plaintext highlighter-rouge">void square() const</code> doesnâ€™t satisfy either the <code class="language-plaintext highlighter-rouge">HasIntSquare</code> or the <code class="language-plaintext highlighter-rouge">HasConvertibleToIntSquare</code> concepts.</p>

<p><code class="language-plaintext highlighter-rouge">IntWithLongSquare</code>, so the class with the function <code class="language-plaintext highlighter-rouge">long square() const</code> doesnâ€™t satisfy the concept <code class="language-plaintext highlighter-rouge">HasIntSquare</code> as long is not the same as <code class="language-plaintext highlighter-rouge">int</code>, but it does satisfy the <code class="language-plaintext highlighter-rouge">HasConvertibleToIntSquare</code> concept as <code class="language-plaintext highlighter-rouge">long</code> is convertible to <code class="language-plaintext highlighter-rouge">int</code>.</p>

<p>Class <code class="language-plaintext highlighter-rouge">IntWithIntSquare</code> satisfies both concepts as an <code class="language-plaintext highlighter-rouge">int</code> is obviously the same as <code class="language-plaintext highlighter-rouge">int</code> and itâ€™s also convertible to an <code class="language-plaintext highlighter-rouge">int</code>.</p>

<h3 id="type-requirements">Type requirements</h3>

<p>With type requirements, we can express that a certain type is valid in a specific context. Type requirements can be used to verify that</p>

<ul>
  <li>a certain nested type exists</li>
  <li>a class template specialization names a type</li>
  <li>an alias template specialization names a type</li>
</ul>

<p>You have to use the keyword <code class="language-plaintext highlighter-rouge">typename</code> along with the type name that is expected to exist:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">TypeRequirement</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">{</span>
  <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
  <span class="k">typename</span> <span class="n">Other</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>The concept <code class="language-plaintext highlighter-rouge">TypeRequirement</code> requires that the type <code class="language-plaintext highlighter-rouge">T</code> has a nested type <code class="language-plaintext highlighter-rouge">value_type</code>, and that the class template <code class="language-plaintext highlighter-rouge">Other</code> can be instantiated with <code class="language-plaintext highlighter-rouge">T</code>.</p>

<p>Letâ€™s see how it works:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Other</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">TypeRequirement</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">{</span>
  <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
  <span class="k">typename</span> <span class="n">Other</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">TypeRequirement</span> <span class="k">auto</span> <span class="n">myVec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  <span class="c1">// TypeRequirement auto myInt {3}; // error: deduced initializer does not satisfy placeholder constraints ... the required type 'typename T::value_type' is invalid </span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The expression <code class="language-plaintext highlighter-rouge">TypeRequirement auto myVec = std::vector&lt;int&gt;{1, 2, 3}</code> (line 13) is valid.</p>

<p>A <code class="language-plaintext highlighter-rouge">std::vector</code> has an inner member type <code class="language-plaintext highlighter-rouge">value_type</code> (requested on line 8) and the class template <code class="language-plaintext highlighter-rouge">Other</code> can be instantiated with <code class="language-plaintext highlighter-rouge">std::vector&lt;int&gt;</code> (line 9).</p>

<p>At the same time, an <code class="language-plaintext highlighter-rouge">int</code> doesnâ€™t have any member, in particular <code class="language-plaintext highlighter-rouge">value_type</code>, so it doesnâ€™t satisfy the constraints of <code class="language-plaintext highlighter-rouge">TypeRequirement</code>.</p>

<p>Letâ€™s change class template <code class="language-plaintext highlighter-rouge">Other</code> and make a requirement on the template parameter by making sure that <code class="language-plaintext highlighter-rouge">Other</code> cannot be instantiated with a <code class="language-plaintext highlighter-rouge">vector</code> of <code class="language-plaintext highlighter-rouge">int</code>s.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">requires</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">)</span>
<span class="k">struct</span> <span class="nc">Other</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now, the line <code class="language-plaintext highlighter-rouge">TypeRequirement auto myVec = std::vector&lt;int&gt;{1, 2, 3};</code> fails with the following error message:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>main.cpp: In function 'int main()':
main.cpp:16:55: error: deduced initializer does not satisfy placeholder constraints
   16 |   TypeRequirement auto myVec = std::vector&lt;int&gt;{1, 2, 3};
      |                                                       ^
main.cpp:16:55: note: constraints not satisfied
main.cpp:10:9:   required for the satisfaction of 'TypeRequirement&lt;std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;'
main.cpp:10:27:   in requirements  [with T = std::vector&lt;int, std::allocator&lt;int&gt; &gt;]
main.cpp:12:12: note: the required type 'Other&lt;T&gt;' is invalid
   12 |   typename Other&lt;T&gt;;
      |   ~~~~~~~~~^~~~~~~~~
cc1plus: note: set '-fconcepts-diagnostics-depth=' to at least 2 for more detail
</pre></td></tr></tbody></table></code></pre></div></div>

<p>With type requirements, we can make sure that a class has a nested member type or that a template specialization is possible.</p>

<p>To show that a concept can be used to prove that an alias template specialization names a type, letâ€™s take our original example and create a template alias <code class="language-plaintext highlighter-rouge">Reference</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">using</span> <span class="n">Reference</span> <span class="o">=</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>And use it in the concept <code class="language-plaintext highlighter-rouge">TypeRequirement</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">TypeRequirement</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">{</span>
  <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
  <span class="k">typename</span> <span class="n">Other</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">typename</span> <span class="n">Reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Our example should still compile:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Other</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">using</span> <span class="n">Reference</span> <span class="o">=</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">TypeRequirement</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">{</span>
  <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
  <span class="k">typename</span> <span class="n">Other</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">typename</span> <span class="n">Reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">TypeRequirement</span> <span class="k">auto</span> <span class="n">myVec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="nested-requirements">Nested requirements</h3>

<p>We can use nested requirements to specify additional constraints in a concept without introducing another named concepts.</p>

<p>You can think of nested requirements as one would think about lambda functions for STL algorithms. You can use lambdas to alter the behaviour of an algorithm without the need of naming a function or a function object.</p>

<p>In this case, you can write a constraint more suitable for your needs without the need of naming one more constraint that youâ€™d only use in one (nested) context.</p>

<p>Its syntax follows the following form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>requires constraint-expression;
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Letâ€™s start with a simpler example. Where the concept <code class="language-plaintext highlighter-rouge">Coupe</code> uses two other concepts <code class="language-plaintext highlighter-rouge">Car</code> and <code class="language-plaintext highlighter-rouge">Convertible</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">struct</span> <span class="nc">AwesomeCabrio</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">openRoof</span><span class="p">(){}</span>
  <span class="kt">void</span> <span class="n">startEngine</span><span class="p">(){}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">CoolCoupe</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">startEngine</span><span class="p">(){}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Car</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">C</span> <span class="n">car</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">car</span><span class="p">.</span><span class="n">startEngine</span><span class="p">();</span>
<span class="p">};</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Convertible</span> <span class="o">=</span> <span class="n">Car</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">requires</span> <span class="p">(</span><span class="n">C</span> <span class="n">car</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">car</span><span class="p">.</span><span class="n">openRoof</span><span class="p">();</span>
<span class="p">};</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Coupe</span> <span class="o">=</span> <span class="n">Car</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">requires</span> <span class="p">(</span><span class="n">C</span> <span class="n">car</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">requires</span> <span class="o">!</span><span class="n">Convertible</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Convertible</span> <span class="k">auto</span> <span class="n">cabrio</span> <span class="o">=</span> <span class="n">AwesomeCabrio</span><span class="p">{};</span>
  <span class="c1">//Coupe auto notACoupe = AwesomeCabrio{}; // nested requirement '! Convertible&lt;C&gt;' is not satisfied</span>
  <span class="n">Coupe</span> <span class="k">auto</span> <span class="n">coupe</span> <span class="o">=</span> <span class="n">CoolCoupe</span><span class="p">{};</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Letâ€™s have a look at the concept <code class="language-plaintext highlighter-rouge">Coupe</code>. First, we make sure that only types satisfying the <code class="language-plaintext highlighter-rouge">Car</code> concept are accepted. Then we introduce a nested concept that requires that our template type is not a <code class="language-plaintext highlighter-rouge">Convertible</code>.</p>

<p>Itâ€™s true that we donâ€™t <em>need</em> the nested constraint, we could express ourselves without it:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Coupe</span> <span class="o">=</span> <span class="n">Car</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Convertible</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Nevertheless, we saw the syntax in a working example.</p>

<p>Nested requires clauses can be used more effectively with local parameters that are listed in the outer <code class="language-plaintext highlighter-rouge">requires</code> scope, like in the next example with <code class="language-plaintext highlighter-rouge">C clonable</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">struct</span> <span class="nc">Droid</span> <span class="p">{</span>
  <span class="n">Droid</span> <span class="n">clone</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">Droid</span><span class="p">{};</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">DroidV2</span> <span class="p">{</span>
  <span class="n">Droid</span> <span class="n">clones</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">Droid</span><span class="p">{};</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Clonable</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">C</span> <span class="n">clonable</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clonable</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
    <span class="n">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">clonable</span><span class="p">.</span><span class="n">clone</span><span class="p">())</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Clonable</span> <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Droid</span><span class="p">{};</span>
  <span class="c1">// Clonable auto c2 = DroidV2{}; // nested requirement 'same_as&lt;C, decltype (clonable.clone())&gt;' is not satisfied</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this example, we have two droid types, <code class="language-plaintext highlighter-rouge">Droid</code> and <code class="language-plaintext highlighter-rouge">DroidV2</code>. We expect that droids should be clonable meaning that each type should have a clone method that returns another droid of the same type. With <code class="language-plaintext highlighter-rouge">DroidV2</code> we made a mistake and it still returns <code class="language-plaintext highlighter-rouge">Droid</code>.</p>

<p>Can we write a concept that catches this error?</p>

<p>We can, in fact as probably you noticed, we already did. In the concept <code class="language-plaintext highlighter-rouge">Clonable</code> we work with a <code class="language-plaintext highlighter-rouge">C cloneable</code> local parameter. With the nested requirement <code class="language-plaintext highlighter-rouge">requires std::same_as&lt;C, decltype(clonable.clone())&gt;</code> we express that the clone method should return the same type as the parametersâ€™.</p>

<p>You might argue that there is another way to express this, without the nested clause and youâ€™d be right:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Clonable</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">C</span> <span class="n">clonable</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">clonable</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>For a more complex example, Iâ€™d recommend you to check the implementation of <code class="language-plaintext highlighter-rouge">SemiRegular</code> concepts on <a href="https://en.cppreference.com/w/cpp/language/constraints">C++ Reference</a>.</p>

<p>To incorporate one of the requirements of <code class="language-plaintext highlighter-rouge">Semiregular</code> to our <code class="language-plaintext highlighter-rouge">Clonable</code> concept, we could write this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Clonable</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">C</span> <span class="n">clonable</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">clonable</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">C</span><span class="o">*</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clonable</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This additional line makes sure that the address of operator (<code class="language-plaintext highlighter-rouge">&amp;</code>) returns the same type for the <code class="language-plaintext highlighter-rouge">cloneable</code> parameter as <code class="language-plaintext highlighter-rouge">C*</code> is.</p>

<p>I agree, it doesnâ€™t make much sense in this context (it does for <code class="language-plaintext highlighter-rouge">SemiRegular</code>), but itâ€™s finally an example that is not easier to express without a nested requirement than with.</p>

<p>In the next post, weâ€™ll see how to use a nested requirement when even the enclosing concept is unnamed.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Today we continued and finished discussing what building blocks are available for us to write our own concepts. We saw how to make constraints on function return types, how to use type requirements on inner types, template aliases and specialisations and finally we saw that itâ€™s possible to nest requirements, even though often there are easier ways to express ourselves.</p>

<p>Next time, weâ€™ll continue with <a href="https://www.sandordargo.com/blog/2021/03/24/concepts-in-real-life">some real life examples</a> of how concepts can make our projects easier to understand. Stay tuned!</p>
:ET