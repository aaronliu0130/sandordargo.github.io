I"Ö'<p>This topic came up recently during a coding dojo in our department, while we were working on the <a href="https://kata-log.rocks/ugly-trivia-kata">ugly trivia</a> kata. We wanted to extract a struct, containing the player data. Later we wanted to turn it into a real class with logic in it. Only later, as I prefer doing small steps at a time. Hence we started with a pure data container class, a.k.a. a struct in C++.
<!--more--></p>

<h2 id="how-class-members-are-initialized">How class members are initialized?</h2>

<p>But how should we properly initialize a class or a struct? How should we initialize the members? After all, even if someone just started out in C++, most probably already heard of the burdens of uninitialized members. But how to avoid them in the correct way?</p>

<p>So first question. How members got initialized?</p>
<ul>
  <li>For objects (e.g. <code class="language-plaintext highlighter-rouge">std::string</code>) the default constructor is called. If there is no default constructor nor explicit initialization, there is a compile-time error.</li>
  <li>Primitive types (including pointers) will contain whatever (garbage) was at the given memory location previously</li>
  <li>References must be initialized, you simply cannot compile the code if not done.</li>
</ul>

<p>Is it complicated? Or do you find it simple?</p>

<p>I don‚Äôt think it is very complex, but before writing this article I had to look it up and verify just to make it sure.</p>

<p>So I‚Äôm still convinced that the best thing you can do is that you explicitly initialize all your members. Being implicit makes the reader think and unnecessary thinking is often a source of errors.</p>

<p>How would you perform that initialization?</p>

<h2 id="constructor-delegation">Constructor delegation</h2>

<p>The good old way is just to initialize everything in the constructor‚Äôs member initializer list, in the order of the declaration of the members.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">T</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="n">T</span><span class="p">()</span> <span class="o">:</span> <span class="n">num</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="s">""</span><span class="p">)</span> <span class="p">{};</span>

<span class="n">T</span><span class="p">(</span><span class="kt">int</span> <span class="n">iNum</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">iText</span><span class="p">)</span> <span class="o">:</span> <span class="n">num</span><span class="p">(</span><span class="n">iNum</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="n">iText</span><span class="p">)</span> <span class="p">{};</span>

<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>If you look closer, there is a little bit of duplication going on here. Both constructors enumerate and set the two members one by one. It would be nice to call the second constructor with the default parameters, like this.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">T</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="n">T</span><span class="p">()</span> <span class="o">:</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span> <span class="p">{};</span>

<span class="n">T</span><span class="p">(</span><span class="kt">int</span> <span class="n">iNum</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">iText</span><span class="p">)</span> <span class="o">:</span> <span class="n">num</span><span class="p">(</span><span class="n">iNum</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="n">iText</span><span class="p">)</span> <span class="p">{};</span>

<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The good news is this is possible for almost 10 years, since C++11 and it‚Äôs called constructor delegation. Something that has been available in Java for even longer if I‚Äôm not mistaken.</p>

<h2 id="default-member-initialization">Default Member Initialization</h2>

<p>Constructor delegation can be quite handy and simplify code, but for this very use-case, I have a better way that I want to show you.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">T</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="n">T</span><span class="p">()</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
<span class="n">T</span><span class="p">(</span><span class="kt">int</span> <span class="n">iNum</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">iText</span><span class="p">)</span> <span class="o">:</span> <span class="n">num</span><span class="p">(</span><span class="n">iNum</span><span class="p">),</span> <span class="n">text</span><span class="p">(</span><span class="n">iText</span><span class="p">)</span> <span class="p">{};</span>

<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">{};</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>So what is going on here. Let‚Äôs go from the top to the bottom.</p>

<p>Given our original example, we need the default constructor, the one not taking any parameters. But we don‚Äôt want to implement it on our own, so we just leave it to the compiler by appending <code class="language-plaintext highlighter-rouge">=default</code> to its declaration.</p>

<p>What is even more interesting for is the declaration of the members. We don‚Äôt just declare them, but we also initialize them right away. This default member initialization is also something that is available since C++ 11.</p>

<p>It has at least two advantages. If you consistently follow this practice you will not have to worry that you forgot to initialize something and you‚Äôll not have to scroll anywhere else to find the default value.</p>

<p>Please also note that we used the brace initialization instead of the assignment operator (<code class="language-plaintext highlighter-rouge">=</code>). There are - again - two reasons behind</p>
<ul>
  <li>it‚Äôs ‚Äúnew‚Äù so it‚Äôs fancy‚Ä¶ just kidding‚Ä¶</li>
  <li>the assignment operator allows narrowing (e.g. -1 can be assigned to an <code class="language-plaintext highlighter-rouge">unsigned int</code>), while the brance initialization would end up in a compiler error in such situations.</li>
</ul>

<p>Even though we already gave some default values with our shiny brace initializers, we can override those values in any constructors. In case, we initialize a member both in-place and in a constructor, the constructor wins.</p>

<p>You might ask if it means that the members will first be assigned to their default value and then reassigned with the values from the constructor.</p>

<p><a href="https://godbolt.org/">GodBolt compiler explorer</a> is our friend. Even without any explicit compiler optimization, we can find that there are no extra assignments. The compiler is smart enough to know which value to use and it avoids extra assignments.</p>

<p>If you are the person of guidelines, the <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c45-dont-define-a-default-constructor-that-only-initializes-data-members-use-in-class-member-initializers-instead">C++ Core Guidelines</a> is your friend in this case. <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c45-dont-define-a-default-constructor-that-only-initializes-data-members-use-in-class-member-initializers-instead">C.45</a>:</p>

<blockquote>
  <p>‚ÄúDon‚Äôt define a default constructor that only initializes data members; use in-class member initializers instead‚Äù</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>It this article, we saw how C++ initializes class members, how constructor delegation works in order to introduce <em>Default Member Initialization</em>. This latter helps us not to implement the default constructor manually, but instead to assign default values to members right where they are declared. This makes code more readable and leaves space for less accidentally uninitialized variables.</p>

<p>Happy coding!</p>
:ET