I"Ä*<p>Iâ€™ve spent quite some time during the last two months on Jenkins pipelines and I had to solve an interesting problem that Iâ€™m going to share with you in this article.
<!--more--></p>

<p>We perform regular source code scans and binary scans for our applications, but the triggering process has been somewhat manual. I already automated both scans as much as I could, as much as I had ideas, but it was far from optimal, even if it was much better than in the other departments I know about.</p>

<p>Unfortunately, there was no way to put them into the regular CI/CD pipelines as one of the scans is really slow and with such a delay, devs would have done to me the worst of the worst and the other scan is asynchronous and it was not accepted to be triggered by the regular CI/CD.</p>

<p>Letâ€™s say that my automation was good enough for what I needed it.</p>

<p>But requirements and expectations changed and we needed something better.</p>

<p>As I already had some experience with these jobs, I volunteered for piloting the new solution. At that time, I didnâ€™t understand that piloting in this case would mean that I have to build most of it.</p>

<h2 id="problem-statement">Problem statement</h2>

<ul>
  <li>We needed a scheduled pipeline in Jenkins that executes two scans for various software components for several applications.</li>
  <li>The scans should be parallelized as much as meaningful</li>
  <li>It should be easy if not effortless to add new components to the scan</li>
</ul>

<p>What we built, in the end, was a scheduled job that at each run creates other one-off jobs and executes them immediately. One job that creates them all, and one job for each component of an application.</p>

<p>The scheduling workflow (a scheduled job capable of creating other jobs) was developed already by someone at another division, who guided me through with the rest. Benjamin was a great help and taught me a lot about Jenkins pipelines.</p>

<p>I only had to modify the scheduling workflow a little and that little part is what Iâ€™m focusing on today.</p>

<h2 id="share-data-between-docker-images">Share data between docker images</h2>

<p>I had to share a generated file between my Jenkinsfile and the workflow it was calling. As the file was generated on the fly, it was not possible to simply pass a Bitbucket URL as a parameter from one to the other. If I committed the file, I could have just passed the URL. This is something that I already made working as a first iteration, but I clearly didnâ€™t want to go with committed files as there can be many of them.</p>

<p>Unfortunately, I couldnâ€™t simply just look at the place in the filesystem where I generated the file, because the different parts of workflows were running on different docker images and I had no right to change this behaviour.</p>

<p>The file generation couldnâ€™t be delegated either, due to two reasons. I have no right to modify the scheduling workflow just anyhow and more importantly, it wouldnâ€™t have made any sense to give it a responsibility that doesnâ€™t belong there.</p>

<p>Sharing the content of the generated as a (quite long) text parameter could have been an option and I kept it as such - one last option. An option that I didnâ€™t want to try until I had any hope to resolve the problem in any other way. I donâ€™t find it elegant, even though Groovyâ€™s 65536 characters limit to Unicode strings would have been more than enough even in the long run.</p>

<h2 id="stashunstash-the-jenkins-way"><code class="language-plaintext highlighter-rouge">stash</code>/<code class="language-plaintext highlighter-rouge">unstash</code> the Jenkins way</h2>

<p>I was advised to use <code class="language-plaintext highlighter-rouge">stash</code>/<code class="language-plaintext highlighter-rouge">unstash</code>. First I was puzzled. What should I do with git here? But okay, letâ€™s give it a try. Then I realized that itâ€™s also <a href="https://www.jenkins.io/doc/pipeline/steps/workflow-basic-steps/#stash-stash-some-files-to-be-used-later-in-the-build">a pair of commands in Jenkins terminology</a>, itâ€™s simply not so widely known as its git counterpart. After all, fewer people configure Jenkins pipelines than work with git.</p>

<p>The usage seemed fairly simple, an easy way to share jobs between jobs in the same pipeline. What is important is that we are in a node context, but it was granted in my case. The main thing to pay attention to is that somehow I still have to share the <code class="language-plaintext highlighter-rouge">stash</code> name with the other workflow which would call the <code class="language-plaintext highlighter-rouge">unstash</code> command with the same name.Â </p>

<p>This means, there is an observable difference compared to git un/stash, where you can simply <code class="language-plaintext highlighter-rouge">unstash</code> the lastly stashed items. In Jenkins, you must provide the name. And if you provide a wrong name, there is an exception thrown.</p>

<p>But the name is short, and it was easy to share it as a context parameter between my main job and the scheduling pipeline.</p>

<p>I went along the examples I found and I had no exception!</p>

<p>Champagne?!</p>

<p>Not yet.</p>

<p>I needed to copy the within the scheduling workflow, or in fact, rename the file would have been enough.</p>

<p>Again, I have to emphasize that Iâ€™m no way a Jenkins expert. So I went to Stackoverflow for copy-pasta and checked how to copy a text file:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> --><td class="rouge-code"><pre><span class="err">Â </span> <span class="n">src</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="err">'</span><span class="n">src</span><span class="o">.</span><span class="na">txt</span><span class="err">'</span><span class="o">)</span>
<span class="err">Â </span> <span class="n">dst</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="err">'</span><span class="n">dst</span><span class="o">.</span><span class="na">txt</span><span class="err">'</span><span class="o">)</span>
<span class="err">Â </span> <span class="n">dst</span> <span class="o">&lt;&lt;</span> <span class="n">src</span><span class="o">.</span><span class="na">text</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It didnâ€™t work! In fact, an exception was thrown because the source file didnâ€™t exist. Why? I didnâ€™t understand at that point. I couldnâ€™t understand where it can be, where it disappeared.</p>

<p>After all, <code class="language-plaintext highlighter-rouge">unstash</code> was successful, but the file was nowhere. I tried to list the current directory, I tried to list files a level higher, a lever deeper, nothing. I was in despair.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> --><td class="rouge-code"><pre><span class="c1">// Listing all the files and subdirectories in a given path. </span>
<span class="c1">// I didn'have the rights to call the eachFileRecurse call</span>
<span class="n">local</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="sc">'.'</span><span class="o">)</span>
<span class="n">local</span><span class="o">.</span><span class="na">eachFile</span> <span class="o">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Then I contacted my colleague once more. He told me that depending on whether I use Jenkins commands or Java/Groovy classes my current working directory can be completely different. And as <code class="language-plaintext highlighter-rouge">stash</code>/<code class="language-plaintext highlighter-rouge">unstash</code> are part of Jenkins, not Groovy, and I should try to use <code class="language-plaintext highlighter-rouge">readFile</code> and <code class="language-plaintext highlighter-rouge">writeFile</code> instead to make the copy.</p>

<p>Lo and behold, it worked right away. I could read in the file without a problem, and I could write into a new one without permission issues.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="err">Â </span><span class="n">writeFile</span><span class="o">(</span><span class="nl">file:</span><span class="n">fileName</span><span class="o">,</span> <span class="nl">text:</span><span class="n">readFile</span><span class="o">(</span><span class="s">"unstashedFile"</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>The most important takeaway for me is that good cooperation is indispensable and we should always rely on the knowledge of people more experienced with a given technology. Even if what they say seems quite surprising. Like who would have thought that the local directory is not the same if I read a file with the <code class="language-plaintext highlighter-rouge">File</code> class and if read it with <code class="language-plaintext highlighter-rouge">readFile()</code>. In fact, most probably thatâ€™s the moment - when they say something surprising - when we should pay even more attention.</p>

<p>Thinking about key learning from a technical aspect, I learned that I can share files in a Jenkins pipeline between different jobs, between different docker images trough <code class="language-plaintext highlighter-rouge">stash</code> and <code class="language-plaintext highlighter-rouge">unstash</code>, and I only have to make sure that the name is something that I can share between the different parts of the pipeline or something that we can compute or we know before.</p>

<p>The most interesting I learned that when in Jenkins, I should use Jenkins verbs as much as I can and not mix them with native Java and Groovy classes unnecessarily, especially when it comes to theÂ filesystem. Otherwise, I might end not being able to read files, or writing them to somewhere else compared to where intended them to write.</p>

<p>All in all, Iâ€™ve been enjoying this project and my understanding of what is possible within the realms of CI/CD reached the next - still not to high - level.</p>
:ET