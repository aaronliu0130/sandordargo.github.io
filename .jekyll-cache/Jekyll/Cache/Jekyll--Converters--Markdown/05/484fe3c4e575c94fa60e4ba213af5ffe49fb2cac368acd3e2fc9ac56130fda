I"<p>In this first part of <a href="http://sandordargo.com/blog/2019/01/30/stl-algos-intro">the big STL algorithm tutorial</a>, I’ll start with the first chunk of the non-modifying sequence operations.
<!--more--></p>

<p>Namely, in this post, you are going to read about <code class="language-plaintext highlighter-rouge">all_of</code>, <code class="language-plaintext highlighter-rouge">any_of</code> and <code class="language-plaintext highlighter-rouge">none_of</code> functions.</p>

<p>Their names are quite intuitive and as you might suspect it, they all return booleans and they operate on STL containers.</p>

<p>Unless you use ranges (that should be part of another post), you don’t pass them directly a container, but rather two iterators on the same container. Those iterators define the range the function will work on.</p>

<p>After the two iterators, you pass in a predicate. That predicate can be a function pointer or a function object (including <a href="http://sandordargo.com/blog/2018/12/19/c++-lambda-expressions">lambdas</a>) returning a boolean or at least something that is convertible to boolean.</p>

<p>It means that the next code does NOT even compile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main()
{

  auto nums = {1,2,3,4,5,3};
  if (std::any_of(std::begin(nums), std::end(nums), 3) {
      std::cout &lt;&lt; "there is a 3 in the list" &lt;&lt; std::endl;
  } else {
      std::cout &lt;&lt; "there is NOT ANY 3 in the list" &lt;&lt; std::endl;
  }
    
}

</pre></td></tr></tbody></table></code></pre></div></div>

<p>Instead, let’s see two implementation that works. The first one will use a function object:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;


class IsEqualTo {
public:
    IsEqualTo(int num) : m_num(num) {}
    
    bool operator()(int i) {
        return i == m_num;
    }
private:
    int m_num;
};

int main()
{

auto nums = {1,2,3,4,5,3};
if (std::any_of(std::begin(nums), std::end(nums), IsEqualTo(3))) {
      std::cout &lt;&lt; "there is a 3 in the list" &lt;&lt; std::endl;
  } else {
      std::cout &lt;&lt; "there is NOT ANY 3 in the list" &lt;&lt; std::endl;
}
    
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It’s a bit long, but thanks to the well-named functor (function object) it is easily readable.</p>

<p>Now let’s have a look at bersion with a lambda expression:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main()
{

  auto nums = {1,2,3,4,5,3};
  if (std::any_of(std::begin(nums), std::end(nums), [](int i){return i == 3;})) {
      std::cout &lt;&lt; "there is a 3 in the list" &lt;&lt; std::endl;
  } else {
      std::cout &lt;&lt; "there is NOT ANY 3 in the list" &lt;&lt; std::endl;
  }
    
}

</pre></td></tr></tbody></table></code></pre></div></div>

<p>This version is a lot shorter, a lot more dense and instead of the whole definition of our class <code class="language-plaintext highlighter-rouge">IsEqualTo</code> you have only this lambda expression: <code class="language-plaintext highlighter-rouge">[](int i){return i == 3;})</code>.</p>

<p>Which one is better to use? It depends on the context. You can read some details about this question and on how to write lambdas in C++ in general in <a href="http://sandordargo.com/blog/2018/12/19/c++-lambda-expressions">this article</a>.</p>

<p>Now, let’s talk a little bit about what the 3 mentioned functions do, but maybe it’s already clear to you.</p>

<h3 id="stdall_of"><code class="language-plaintext highlighter-rouge">std::all_of</code></h3>

<p><code class="language-plaintext highlighter-rouge">std::all_of</code> will return true if the predicate is evaluated to true or can be converted to true for <strong>all</strong> the items, false otherwise.</p>

<p>That <em>“can be converted”</em> part means that the predicate doesn’t have to return a boolean. It can return a number for example. But really anything that can be treated as a boolean.</p>

<h3 id="stdany_of"><code class="language-plaintext highlighter-rouge">std::any_of</code></h3>

<p><code class="language-plaintext highlighter-rouge">std::any_of</code> will return true if the predicate is evaluated to true or can be converted to true for <strong>any</strong> of the items, false otherwise. Meaning that if the predicate is true only for one element out of a hundred, <code class="language-plaintext highlighter-rouge">std::any_of</code> will return true.</p>

<h3 id="stdnone_of"><code class="language-plaintext highlighter-rouge">std::none_of</code></h3>

<p><code class="language-plaintext highlighter-rouge">std::none_of</code> will return true if the predicate is evaluated to true or can be converted to true for <strong>none</strong> of the items, false otherwise. Turning it around, <code class="language-plaintext highlighter-rouge">std::none_of</code> return true if the predicate is false for <strong>all</strong> the items! If there is at least one returning true, the function itself will return false.</p>

<h2 id="conclusion">Conclusion</h2>

<p>That’s it for the first part. The three presented functions - <code class="language-plaintext highlighter-rouge">all_of</code>, <code class="language-plaintext highlighter-rouge">any_of</code> and <code class="language-plaintext highlighter-rouge">none_of</code> - can replace ugly loops with an if and a break inside your code, making it much more expressive and readable. Use them without moderation wherever you can and stay tuned for the next episodes!</p>
:ET