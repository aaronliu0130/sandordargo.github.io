I"9›<p>During the previous weeks, we discussed <a href="https://www.sandordargo.com/blog/2021/02/10/cpp-concepts-motivations">the motivations behind C++ concepts</a> and <a href="https://www.sandordargo.com/blog/2021/02/17/cpp-concepts-4-ways-to-use-them">how to use them with functions</a> and <a href="https://www.sandordargo.com/blog/2021/02/24/cpp-concepts-with-classes">with classes</a>. But we have hardly written any. We defined a functionally incomplete concept called <code class="language-plaintext highlighter-rouge">Number</code> for the sake of example, but thatâ€™s it. Now are going into details on what kind of constraints we can express in a concept.
<!--more--></p>

<p>This article would be too long if I included the different kinds of constraints all at once. In this one, we are going start from the simples concepts combining existing ones then we are going to finish with required operations and in general requirements on a classâ€™ API.</p>

<p>Next week, Iâ€™ll show you how to write requirements on return types, how to express type requirements and how to nest constraints.</p>

<p>Itâ€™s high time to finally get started.</p>

<h2 id="the-simples-concept">The simples <code class="language-plaintext highlighter-rouge">concept</code></h2>

<p>Letâ€™s define the simplest concept we can imagine first, just to see the syntax.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> 
<span class="n">concept</span> <span class="n">Any</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>First, we list the template parameters, in this case, we have only one, <code class="language-plaintext highlighter-rouge">T</code>, but we could have multiple ones separated by commas. Then after the keyword <code class="language-plaintext highlighter-rouge">concept,</code> we declare the name of the concept and then after the <code class="language-plaintext highlighter-rouge">=</code> we define the concept.</p>

<p>In this example, we simply say <code class="language-plaintext highlighter-rouge">true</code>, meaning that for any type <code class="language-plaintext highlighter-rouge">T</code> the concept will be evaluated to <code class="language-plaintext highlighter-rouge">true</code>; any type is accepted. Should we wrote <code class="language-plaintext highlighter-rouge">false</code>, nothing would be accepted.</p>

<p>Now that we saw the simplest concept, letâ€™s check what building blocks are at our disposal to construct a more detailed concept.</p>

<h2 id="use-already-defined-concepts">Use already defined concepts</h2>

<p>Arguably the easiest way to define new concepts is by combining existing ones.</p>

<p>For instance, in the next example, we are going to create - once again - a concept called <code class="language-plaintext highlighter-rouge">Number</code> by accepting both integers and floating-point numbers.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> 
<span class="n">concept</span> <span class="n">Number</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As you can see in the above example, we could easily combine with the <code class="language-plaintext highlighter-rouge">||</code> operator two concepts. Of course, we can use any logical operator.</p>

<p>Probably itâ€™s self-evident, but we can use user-defined concepts as well.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> 
<span class="n">concept</span> <span class="n">Integer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> 
<span class="n">concept</span> <span class="n">Float</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> 
<span class="n">concept</span> <span class="n">Number</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">Float</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this example, we basically just aliased (and added a layer of indirection to) <code class="language-plaintext highlighter-rouge">std::integral</code> and <code class="language-plaintext highlighter-rouge">std::floating_point</code> to show that user-defined concepts can also be used in a combination of concepts.</p>

<p><a href="https://www.sandordargo.com/blog/2021/03/03/cpp-concepts-in-standard-library">As we saw earlier</a>, there are plenty of concepts defined in the different headers of the standard library so there is an endless way to combine them.</p>

<p>But how to define truly unique concepts?</p>

<h2 id="write-your-own-constraints">Write your own constraints</h2>

<p>In the coming sections, we are going to delve into how to express our own unique requirements without using any of the predefined concepts.</p>

<h3 id="requirements-on-operations">Requirements on operations</h3>

<p>We can simply express that we require that a template parameter support a certain operation or operator by <em>wishful writing</em>.</p>

<p>If you require that template parameters are addable you can create a concept for that:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;concepts&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Addable</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> 
<span class="p">};</span>

<span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">Addable</span> <span class="k">auto</span> <span class="n">x</span><span class="p">,</span> <span class="n">Addable</span> <span class="k">auto</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">WrappedInt</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">m_int</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="c1">// std::cout &lt;&lt; add(WrappedInt{4}, WrappedInt{5}) &lt;&lt; '\n'; // error: use of function 'auto add(auto:11, auto:12) [with auto:11 = WrappedInt; auto:12 = WrappedInt]' with unsatisfied constraints</span>
<span class="p">}</span>
<span class="cm">/*
9
2 
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>We can observe that when <code class="language-plaintext highlighter-rouge">add()</code> is called with parameters of type <code class="language-plaintext highlighter-rouge">WrappedInt</code> - as they do not support <code class="language-plaintext highlighter-rouge">operator+</code> - the compilation fails with a rather descriptive error message (not the whole error message is copied over into the above example).</p>

<p>Writing the <code class="language-plaintext highlighter-rouge">Addable</code> concept seems rather easy, right? After the <code class="language-plaintext highlighter-rouge">requires</code> keyword we basically wrote down what kind of syntax we expect to compile and run.</p>

<h3 id="simple-requirements-on-the-interface">Simple requirements on the interface</h3>

<p>Letâ€™s think about operations for a little longer. What does it mean after all to require the support of a <code class="language-plaintext highlighter-rouge">+</code> operation?</p>

<p>It means that we constrain the accepted types to those having a function <code class="language-plaintext highlighter-rouge">T T::operator+(const T&amp; other) const</code> function. Or it can even be <code class="language-plaintext highlighter-rouge">T T::operator+(const U&amp; other) const</code>, as maybe we want to add to an instance of another type, but thatâ€™s not the point here. My point is that we made a requirement on having a specific function.</p>

<p>So we should be able to define a requirement on any function call, shouldnâ€™t we?</p>

<p>Right, letâ€™s see how to do it.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;concepts&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="c1">// 2</span>
<span class="n">concept</span> <span class="n">HasSquare</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span><span class="p">.</span><span class="n">square</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">IntWithoutSquare</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">IntWithoutSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_num</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">IntWithSquare</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">IntWithSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_num</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">int</span> <span class="n">square</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m_num</span> <span class="o">*</span> <span class="n">m_num</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="nf">printSquare</span><span class="p">(</span><span class="n">HasSquare</span> <span class="k">auto</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 1</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">.</span><span class="n">square</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">printSquare</span><span class="p">(</span><span class="n">IntWithoutSquare</span><span class="p">{</span><span class="mi">4</span><span class="p">});</span> <span class="c1">// error: use of function 'void printSquare(auto:11) [with auto:11 = IntWithoutSquare]' with unsatisfied constraints, </span>
                                    <span class="c1">// the required expression 't.square()' is invalid</span>
  <span class="n">printSquare</span><span class="p">(</span><span class="n">IntWithSquare</span><span class="p">{</span><span class="mi">5</span><span class="p">});</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this example, we have a function <code class="language-plaintext highlighter-rouge">printSquare</code> (1) that requires a parameter satisfying the concept <code class="language-plaintext highlighter-rouge">HasSquare</code> (2). In that concept, we can see that itâ€™s really easy to define what interface we expect. After the <code class="language-plaintext highlighter-rouge">requires</code> keyword, we have to write down how what calls should be supported by the interface of the accepted types.</p>

<p>Our expectations are written after the <code class="language-plaintext highlighter-rouge">requires</code> keyword. First, there is a parameter list between parentheses - like for a function - where we have to list all the template parameters that would be constrained and any other parameters that might appear in the constraints. More on that later.</p>

<p>If we expect that any passed in type have a function called <code class="language-plaintext highlighter-rouge">square</code>, we simply have to write <code class="language-plaintext highlighter-rouge">(T t) {t.square();}</code>. <code class="language-plaintext highlighter-rouge">(T t)</code> because we want to define a constraint on an instance of <code class="language-plaintext highlighter-rouge">T</code> template type and <code class="language-plaintext highlighter-rouge">t.square()</code> because we expect that <code class="language-plaintext highlighter-rouge">t</code> instance of type <code class="language-plaintext highlighter-rouge">T</code> must have a public function <code class="language-plaintext highlighter-rouge">square()</code>.</p>

<p>If we have requirements on the validity of multiple function calls, we just have to list all of them separated by a semicolon like if we called them one after the other:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">HasSquare</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">t</span><span class="p">.</span><span class="n">square</span><span class="p">();</span>
  <span class="n">t</span><span class="p">.</span><span class="n">sqrt</span><span class="p">();</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>What about parameters? Letâ€™s define a <code class="language-plaintext highlighter-rouge">power</code> function that takes an <code class="language-plaintext highlighter-rouge">int</code> parameter for the exponent:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">HasPower</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span><span class="p">.</span><span class="n">power</span><span class="p">(</span><span class="n">exponent</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// ...</span>

<span class="kt">void</span> <span class="nf">printPower</span><span class="p">(</span><span class="n">HasPower</span> <span class="k">auto</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">.</span><span class="n">power</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">exponent</code> variable that we pass to the <code class="language-plaintext highlighter-rouge">T::power</code> function has to be listed after the <code class="language-plaintext highlighter-rouge">requires</code> keyword with its type, along with the template type(s) we constrain. As such, we fix that the parameter will be something that is (convertible to) an <code class="language-plaintext highlighter-rouge">int</code>.</p>

<p>But what if we wanted to accept just any integral number as an exponent. Where is a will, there is a way! Well, itâ€™s not always true when it comes to syntactical questions, but we got lucky in this case.</p>

<p>First, our concept <code class="language-plaintext highlighter-rouge">HasPower</code> should take two parameters. One for the base type and one for the exponent type.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Base</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Exponent</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">HasPower</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">Exponent</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">requires</span> <span class="p">(</span><span class="n">Base</span> <span class="n">base</span><span class="p">,</span> <span class="n">Exponent</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">base</span><span class="p">.</span><span class="n">power</span><span class="p">(</span><span class="n">exponent</span><span class="p">);</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We make sure that template type <code class="language-plaintext highlighter-rouge">Exponent</code> is an integral and that it can be passed to <code class="language-plaintext highlighter-rouge">Base::power()</code> as a parameter.</p>

<p>The next step is to update our <code class="language-plaintext highlighter-rouge">printPower</code> function. The concept <code class="language-plaintext highlighter-rouge">HasPower</code> has changed, now it takes two types, we have to make some changes accordingly:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Exponent</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">printPower</span><span class="p">(</span><span class="n">HasPower</span><span class="o">&lt;</span><span class="n">Exponent</span><span class="o">&gt;</span> <span class="k">auto</span> <span class="n">number</span><span class="p">,</span> <span class="n">Exponent</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">.</span><span class="n">power</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As <code class="language-plaintext highlighter-rouge">Exponent</code> is explicitly listed as a template type parameter, there is no need for the <code class="language-plaintext highlighter-rouge">auto</code> keyword after it. On the other hand, <code class="language-plaintext highlighter-rouge">auto</code> is needed after <code class="language-plaintext highlighter-rouge">HasPower</code>, otherwise, how would we know that itâ€™s a concept and not a specific type?! As <code class="language-plaintext highlighter-rouge">Exponent</code> is passed as a template type parameter to <code class="language-plaintext highlighter-rouge">HasPower</code> constraints are applied to it too.</p>

<p>Now <code class="language-plaintext highlighter-rouge">printPower</code> can be called the following way - given that we renamed <code class="language-plaintext highlighter-rouge">IntWithSquare</code> to <code class="language-plaintext highlighter-rouge">IntWithPower</code> following our API changes:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre><span class="n">printPower</span><span class="p">(</span><span class="n">IntWithPower</span><span class="p">{</span><span class="mi">5</span><span class="p">},</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">printPower</span><span class="p">(</span><span class="n">IntWithPower</span><span class="p">{</span><span class="mi">5</span><span class="p">},</span> <span class="mi">4L</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>At the same time, the call <code class="language-plaintext highlighter-rouge">printPower(IntWithPower{5}, 3.0);</code> will fail because the type <code class="language-plaintext highlighter-rouge">float</code> does not satisfy the constraint on integrality.</p>

<p>Do we miss something? Yes! We canâ€™t use <code class="language-plaintext highlighter-rouge">IntWithPower</code> as an exponent. We want to be able to call <code class="language-plaintext highlighter-rouge">Base::power(Exponent exp)</code> with a custom type, like <code class="language-plaintext highlighter-rouge">IntWithPower</code> and for that, we need two things:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">IntWithPower</code> should be considered an <code class="language-plaintext highlighter-rouge">integral</code> type</li>
  <li><code class="language-plaintext highlighter-rouge">IntWithPower</code> should be convertible to something accepted by <code class="language-plaintext highlighter-rouge">pow</code> from the <code class="language-plaintext highlighter-rouge">cmath</code> header.</li>
</ul>

<p>Letâ€™s go one by one.</p>

<p>By explicitly specifying the <code class="language-plaintext highlighter-rouge">type_trait</code> <code class="language-plaintext highlighter-rouge">std::is_integral</code> for <code class="language-plaintext highlighter-rouge">IntWithPower</code>, we can make <code class="language-plaintext highlighter-rouge">IntWithPower</code> an integral type. Of course, if we plan to do so in real life, itâ€™s better to make sure that our type has all the characteristics of an integral type, but thatâ€™s beyond our scope here. (<em>Update: specializing most of the type traits results in Undefined Behaviour, so donâ€™t do this in production code</em>)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">IntWithPower</span><span class="o">&gt;</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span> <span class="p">{};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now we have to make sure that <code class="language-plaintext highlighter-rouge">IntWithPower</code> is convertible into a type that is accepted by <a href="http://www.cplusplus.com/reference/cmath/pow/"><code class="language-plaintext highlighter-rouge">pow</code></a>. It accepts floating-point types, but when it comes to <code class="language-plaintext highlighter-rouge">IntWithPower</code>, in my opinion, itâ€™s more meaningful to convert it to an <code class="language-plaintext highlighter-rouge">int</code> and let the compiler perform the implicit conversion to <code class="language-plaintext highlighter-rouge">float</code> - even though itâ€™s better to avoid implicit conversions in general. But after all, <code class="language-plaintext highlighter-rouge">IntWithPower</code> might be used in other contexts as well - as an integer.</p>

<p>For that we have to define <code class="language-plaintext highlighter-rouge">operator int</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">IntWithPower</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">IntWithPower</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_num</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">int</span> <span class="n">power</span><span class="p">(</span><span class="n">IntWithPower</span> <span class="n">exp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">pow</span><span class="p">(</span><span class="n">m_num</span><span class="p">,</span> <span class="n">exp</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">m_num</span><span class="p">;}</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>If we check our example now, weâ€™ll see that both <code class="language-plaintext highlighter-rouge">printPower(IntWithPower{5}, IntWithPower{4});</code> and <code class="language-plaintext highlighter-rouge">printPower(IntWithPower{5}, 4L);</code> will compile, but <code class="language-plaintext highlighter-rouge">printPower(IntWithPower{5}, 3.0);</code> will fail because <code class="language-plaintext highlighter-rouge">3.0</code> is not integral.</p>

<p>Right, as we just stated, <a href="http://www.cplusplus.com/reference/cmath/pow/"><code class="language-plaintext highlighter-rouge">pow</code></a> operates on floating-point numbers but we only accept integrals. Letâ€™s update our concept accordingly!</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Base</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Exponent</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">HasPower</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">Exponent</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">Exponent</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">requires</span> <span class="p">(</span><span class="n">Base</span> <span class="n">base</span><span class="p">,</span> <span class="n">Exponent</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">base</span><span class="p">.</span><span class="n">power</span><span class="p">(</span><span class="n">exponent</span><span class="p">);</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now we can call <code class="language-plaintext highlighter-rouge">printPower</code> with any type for <code class="language-plaintext highlighter-rouge">base</code> that satisfies the <code class="language-plaintext highlighter-rouge">HasPower</code> concept and both with integral and floating-point numbers as an exponent.</p>

<p>Letâ€™s have a look at the full example now:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;concepts&gt;
#include &lt;type_traits&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Base</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Exponent</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">HasPower</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">Exponent</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">Exponent</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">requires</span> <span class="p">(</span><span class="n">Base</span> <span class="n">base</span><span class="p">,</span> <span class="n">Exponent</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">base</span><span class="p">.</span><span class="n">power</span><span class="p">(</span><span class="n">exponent</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">IntWithPower</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">IntWithPower</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_num</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">int</span> <span class="n">power</span><span class="p">(</span><span class="n">IntWithPower</span> <span class="n">exp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">pow</span><span class="p">(</span><span class="n">m_num</span><span class="p">,</span> <span class="n">exp</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">m_num</span><span class="p">;}</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">IntWithPower</span><span class="o">&gt;</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Exponent</span><span class="p">&gt;</span> 
<span class="kt">void</span> <span class="nf">printPower</span><span class="p">(</span><span class="n">HasPower</span><span class="o">&lt;</span><span class="n">Exponent</span><span class="o">&gt;</span> <span class="k">auto</span> <span class="n">number</span><span class="p">,</span> <span class="n">Exponent</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">.</span><span class="n">power</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">printPower</span><span class="p">(</span><span class="n">IntWithPower</span><span class="p">{</span><span class="mi">5</span><span class="p">},</span> <span class="n">IntWithPower</span><span class="p">{</span><span class="mi">4</span><span class="p">});</span>
  <span class="n">printPower</span><span class="p">(</span><span class="n">IntWithPower</span><span class="p">{</span><span class="mi">5</span><span class="p">},</span> <span class="mi">4L</span><span class="p">);</span>
  <span class="n">printPower</span><span class="p">(</span><span class="n">IntWithPower</span><span class="p">{</span><span class="mi">5</span><span class="p">},</span> <span class="mf">3.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this example, we can observe how to write a concept that expects the presence of a certain function that can accept a parameter of different constrained types. We can also see how to make a type satisfying built-in type traits, such as <code class="language-plaintext highlighter-rouge">std::is_integral</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Today we started to discover how to write our own concepts. First, we combined already existing concepts into more complex ones, then we continued with making requirements on the validity of operations on the constrained types then we finished by writing requirements for any function call with or without a parameter list.</p>

<p><a href="https://www.sandordargo.com/blog/2021/03/17/write-your-own-cpp-concepts-part-ii">Next time weâ€™ll continue with constraining the return types, making type and then nested requirements.</a></p>

<p>Stay tuned!</p>
:ET