I"ï<p>If you know Java this might be completely straightforward to you as you are already used to Java‚Äôs <code class="language-plaintext highlighter-rouge">@Override annotation</code>. If you‚Äôve been always coding in C/C++, this might be new. You might ask yourself the question, why should one put there an extra specifier when it‚Äôs not necessary. Your code will just work the very same way.
<!--more--></p>

<p>While in most of the cases it‚Äôs true that your code‚Äôs behaviour will not change, in some others - when you‚Äôre actually making a mistake - using <code class="language-plaintext highlighter-rouge">override</code> will stop you from checking in the buggy code as your compilation will fail. And none of us checks in code that doesn‚Äôt even compile, right?</p>

<p>The <code class="language-plaintext highlighter-rouge">override</code> specifier will tell both the compiler and the reader that the function where it is used is actually overriding a method from its base class.</p>

<p>It tells the reader that ‚Äúthis is a virtual method, that is overriding a virtual method of the base class.‚Äù</p>

<p>Use it correctly and you see no effect:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">};</span>
 
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">// OK: Derived::foo overrides Base::foo</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>But it will help you <em>revealing problems with constness</em>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">bar</span><span class="p">();</span>
<span class="p">};</span>
 
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> <span class="c1">// Error: Derived::foo does not override Base::foo</span>
                               <span class="c1">// It tries to override Base::foo const that doesn't exist```</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Let‚Äôs not forget that in C++, methods are non-virtual by default. If we use <code class="language-plaintext highlighter-rouge">override</code>, we might find that there is nothing to override. Without the <code class="language-plaintext highlighter-rouge">override</code> specifier we would just simply create a brand new method. <em>No more base methods forgotten to be declared as virtual.</em></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">};</span>
 
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">// Error: Base::foo is not virtual</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We should also keep in mind that when we override a method - with or without the <code class="language-plaintext highlighter-rouge">override</code> specifier - <em>no conversions are possible</em>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
  <span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">long</span> <span class="n">foo</span><span class="p">(</span><span class="kt">long</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
   <span class="nl">public:</span>
     <span class="kt">long</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="c1">// error: 'long int Derived::foo(int)' marked override, but does not override</span>
      <span class="c1">// ...</span>
     <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In my opinion, using the override specifier from C++11 is part of clean coding principles. It reveals the author‚Äôs intentions, it makes the code more readable and helps to identify bugs at build time. Use it without moderation!</p>

<p><em>If you are looking for more modern C++ tricks, I‚Äôd recommend you to check out <a href="https://www.aristeia.com/">Scott Meyers</a>‚Äôs <a href="https://amzn.to/2VZrLec">Effective Modern C++</a>!</em></p>
:ET