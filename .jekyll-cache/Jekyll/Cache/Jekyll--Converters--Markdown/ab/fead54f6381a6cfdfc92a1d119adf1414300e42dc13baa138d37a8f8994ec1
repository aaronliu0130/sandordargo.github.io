I"∏s<p>Welcome back to the series on C++ concepts. <a href="https://www.sandordargo.com/blog/2021/02/10/cpp-concepts-motivations">In the previous article</a> we discussed what are the motivations behind concepts, why we need them. Today we are going to focus on how to use existing concepts. There are a couple of different ways.
<!--more--></p>

<h2 id="the-4-ways-to-use-concepts">The 4 ways to use concepts</h2>

<p>To be more specific, we have four different ways at our disposal.</p>

<p>For all the ways I am going to share, let‚Äôs assume that we have a concept called <code class="language-plaintext highlighter-rouge">Number</code>. We are going to use a very simplistic implementation for it. I include it so that if you want to try the different code snippets, you have a concept to play with, but keep in mind that it is incomplete in a functional sense. More about that in a next episode.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Number</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="using-the-requires-clause">Using the <code class="language-plaintext highlighter-rouge">requires</code> clause</h3>

<p>In the first of the four presented ways, we use the <code class="language-plaintext highlighter-rouge">requires</code> clause between template parameter list and the function return type - which is <code class="language-plaintext highlighter-rouge">auto</code> in this case.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">requires</span> <span class="n">Number</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Note how we use the concept, how we define in the <code class="language-plaintext highlighter-rouge">requires</code> clause that any <code class="language-plaintext highlighter-rouge">T</code> template parameter must satisfy the requirements of the concept <code class="language-plaintext highlighter-rouge">Number</code>.</p>

<p>In order to determine the return type we simply use <code class="language-plaintext highlighter-rouge">auto</code> type deduction, but we could use <code class="language-plaintext highlighter-rouge">T</code> instead as well.</p>

<p>Unfortunately, we can only add up two numbers of the same type. We cannot add a <code class="language-plaintext highlighter-rouge">float</code> with an <code class="language-plaintext highlighter-rouge">int</code></p>

<p>If we tried so, we‚Äôd get a bit long, but quite understandable error message:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> --><td class="rouge-code"><pre>main.cpp: In function 'int main()':
main.cpp:15:27: error: no matching function for call to 'add(int, float)'
   15 |   std::cout &lt;&lt; add(5,42.1f) &lt;&lt; '\n';
      |                           ^
main.cpp:10:6: note: candidate: 'template&lt;class T&gt;  requires  Number&lt;T&gt; auto add(T, T)'
   10 | auto add(T a, T b)  {
      |      ^~~
main.cpp:10:6: note:   template argument deduction/substitution failed:
main.cpp:15:27: note:   deduced conflicting types for parameter 'T' ('int' and 'float')
   15 |   std::cout &lt;&lt; add(5,42.1f) &lt;&lt; '\n';
      |                           ^

</pre></td></tr></tbody></table></code></pre></div></div>

<p>If we wanted the capability of adding up numbers of multiple types, we‚Äôd need to introduce a second template parameter.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span>
          <span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="n">requires</span> <span class="n">Number</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">Number</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">U</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Then calls such as <code class="language-plaintext highlighter-rouge">add(1, 2.14)</code> will also work. Please note that the concept was modified. The drawback is that for each new function parameter you‚Äôd need to introduce a new template parameter and a requirement on it.</p>

<p>With the requires clause, we can also express more complex constraints. For the sake of example, let‚Äôs just ‚Äúinline‚Äù the definition of number:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Though for better readability, in most cases, I consider a better practice to name your concept, especially when you have a more complex expression.</p>

<h3 id="trailing-requires-clause">Trailing <code class="language-plaintext highlighter-rouge">requires</code> clause</h3>

<p>We can also use the so-called <em>trailing <code class="language-plaintext highlighter-rouge">requires</code> clause</em> that comes after the function parameter list (and the qualifiers - <code class="language-plaintext highlighter-rouge">const</code>, <code class="language-plaintext highlighter-rouge">override</code>, etc. - if any) and before the function implementation.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="n">requires</span> <span class="n">Number</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We have the same result as we had with the <code class="language-plaintext highlighter-rouge">requires</code> clause we just wrote it with different semantics. It means that we still cannot add two numbers of different types. We‚Äôd need to modify the template definition similarly as we did before:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">U</span> <span class="n">b</span><span class="p">)</span> <span class="n">requires</span> <span class="n">Number</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">Number</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Still, we have the drawback of scalability. Each new function parameter potentially of a different type needs its own template parameter.</p>

<p>Just as for the <code class="language-plaintext highlighter-rouge">requires</code> clause, you can express more complex constraints in the <em>trailing <code class="language-plaintext highlighter-rouge">requires</code> clause</em>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="n">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="constrained-template-parameter">Constrained template parameter</h3>

<p>The third way to use a concept is a bit terser than the previous ones, which also brings some limitations.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="n">Number</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As you can see, we don‚Äôt need any <code class="language-plaintext highlighter-rouge">requires</code> clause, we can simply define a requirement on our template parameters right where we declare them. We use a concept name instead of the keyword <code class="language-plaintext highlighter-rouge">typename</code>. We‚Äôll achieve the very same result as with the previous two methods.</p>

<p>If you don‚Äôt believe it, I‚Äôd urge you to check it on <a href="https://godbolt.org/z/sGTsab">Compiler Explorer</a>.</p>

<p>At the same time, it‚Äôs worth to note that this method has a limitation. When you use the <em><code class="language-plaintext highlighter-rouge">requires</code> clause</em> in any of two presented ways, you can define an expression such as <code class="language-plaintext highlighter-rouge">requires std::integral&lt;T&gt; || std::floating_point&lt;T&gt;</code>. When you use the <em>constrained template parameter</em> way, you cannot have such expressions; <code class="language-plaintext highlighter-rouge">template &lt;std::integral || std::floating_point T&gt;</code> <strong>is not valid</strong>.</p>

<p>So with this way, you can only use single concepts, but in a more concise form as with the previous ones.</p>

<h3 id="abbreviated-function-templates">Abbreviated function templates</h3>

<p>Oh, you looked for brevity? Here you go!</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> --><td class="rouge-code"><pre><span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">Number</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="n">Number</span> <span class="k">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>There is no need for any template parameter list or <em><code class="language-plaintext highlighter-rouge">requires</code> clause</em> when you opt for <em>abbreviated function templates</em>. You can directly use the concept where the function arguments are enumerated.</p>

<p>There is one thing to notice and more to mention.</p>

<p>After the concept <code class="language-plaintext highlighter-rouge">Number</code> we put <code class="language-plaintext highlighter-rouge">auto</code>. As such we can see that <code class="language-plaintext highlighter-rouge">Number</code> is a constraint on the type, not a type itself. Imagine if you‚Äôd simply see <code class="language-plaintext highlighter-rouge">auto add(Number a, Number b)</code>. How would you know as a user that <code class="language-plaintext highlighter-rouge">Number</code> is not a type but a concept?</p>

<p>The other thing I wanted to mention is that when you follow the <em>abbreviated function template</em> way, you can mix the types of the parameters. You can add an <code class="language-plaintext highlighter-rouge">int</code> to a <code class="language-plaintext highlighter-rouge">float</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
#include &lt;iostream&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Number</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">Number</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="n">Number</span> <span class="k">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
3.5
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>So with <em>abbreviated function templates</em> we can take different types without specifying multiple template parameters. It makes sense as we don‚Äôt have any template parameters in fact.</p>

<p>The disadvantage of this way of using concepts is that just like with <em>constrained template parameters</em>, we cannot use complex expressions to articulate our constraints.</p>

<h2 id="how-to-choose-among-the-4-ways">How to choose among the 4 ways?</h2>

<p>We have just seen 4 ways to use concepts, let‚Äôs have a look at them together.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
#include &lt;iostream&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">Number</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">requires</span> <span class="n">Number</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="nf">addRequiresClause</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="n">addTrailingRequiresClause</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="n">requires</span> <span class="n">Number</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">Number</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">addConstrainedTemplate</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="nf">addAbbreviatedFunctionTemplate</span><span class="p">(</span><span class="n">Number</span> <span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="n">Number</span> <span class="k">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"addRequiresClause(1, 2): "</span> <span class="o">&lt;&lt;</span> <span class="n">addRequiresClause</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="c1">// std::cout &lt;&lt; "addRequiresClause(1, 2.5): " &lt;&lt; addRequiresClause(1, 2.5) &lt;&lt; '\n'; // error: no matching function for call to 'addRequiresClause(int, double)'</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"addTrailingRequiresClause(1, 2): "</span> <span class="o">&lt;&lt;</span> <span class="n">addTrailingRequiresClause</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="c1">// std::cout &lt;&lt; "addTrailinRequiresClause(1, 2): " &lt;&lt; addTrailinRequiresClause(1, 2.5) &lt;&lt; '\n'; // error: no matching function for call to 'addTrailinRequiresClause(int, double)'</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"addConstrainedTemplate(1, 2): "</span> <span class="o">&lt;&lt;</span> <span class="n">addConstrainedTemplate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="c1">// std::cout &lt;&lt; "addConstrainedTemplate(1, 2): " &lt;&lt; addConstrainedTemplate(1, 2.5) &lt;&lt; '\n'; // error: no matching function for call to 'addConstrainedTemplate(int, double)'</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"addAbbreviatedFunctionTemplate(1, 2): "</span> <span class="o">&lt;&lt;</span> <span class="n">addAbbreviatedFunctionTemplate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"addAbbreviatedFunctionTemplate(1, 2): "</span> <span class="o">&lt;&lt;</span> <span class="n">addAbbreviatedFunctionTemplate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.14</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Which form should we use? As always, the answer is <em>it depends</em>‚Ä¶</p>

<p>If you have a complex requirement, to be able to use an expression you need either the <em><code class="language-plaintext highlighter-rouge">requires</code> clause</em> or the <em>trailing <code class="language-plaintext highlighter-rouge">requires</code> clause</em>.</p>

<p>What do I mean by a complex requirement? Anything that has more than one concept in it! Like <code class="language-plaintext highlighter-rouge">std::integral&lt;T&gt; || std::floating_point&lt;T&gt;</code>. That is something you cannot express either with a <em>constrained template parameter</em> or with an <em>abbreviated template function</em>.</p>

<p>If you still want to use them, you have to extract the complex constraint expressions into their own concept.</p>

<p>This is exactly what we did when we defined the concept <code class="language-plaintext highlighter-rouge">Number</code>. On the other hand, if your concept uses multiple parameters (something we‚Äôll see soon), you still cannot use <em>constrained template parameters</em> or <em>abbreviated template function</em> - or at least I didn‚Äôt find a way for the time being.</p>

<p>If I have complex requirements and I don‚Äôt want to define and name a concept, I‚Äôd go with either of the first two options, namely with <em><code class="language-plaintext highlighter-rouge">requires</code></em> clause or with <em>trailing <code class="language-plaintext highlighter-rouge">requires</code> clause</em>.</p>

<p>In case I have a simple requirement, I‚Äôd go with the <em>abbreviated function template</em>. Though we must remember that <em>abbreviated function templates</em> let you call your function with multiple different types at the same time, like how we called <code class="language-plaintext highlighter-rouge">add</code> with an <code class="language-plaintext highlighter-rouge">int</code> and with a <code class="language-plaintext highlighter-rouge">float</code>. If that is a problem and you despise the verboseness of the <code class="language-plaintext highlighter-rouge">requires</code> clause, choose a <em>constrained template parameter</em>.</p>

<p>Let‚Äôs also remember that we talk about templates. For whatever combination, a new specialization will be generated by the compiler at compile time. It‚Äôs worth to remember this in case you avoided templates already because of constraints on the binary size or compile time.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Today, we have seen how to use concepts with function parameters. We detailed 4 different ways and saw that the more verbose ones give us more flexibility on the constraints, while the tersest one (<em>abbreviated function template</em>) gives extreme flexibility with the types we can call the function with.</p>

<p><del>Next time, we are going to discuss what kind of concepts we get from the standard library before we‚Äôd actually start writing our own concepts.</del></p>

<p>The next article is about <a href="https://www.sandordargo.com/blog/2021/02/24/cpp-concepts-with-classes">how to use concepts with classes</a>!</p>

<p>Stay tuned!</p>
:ET