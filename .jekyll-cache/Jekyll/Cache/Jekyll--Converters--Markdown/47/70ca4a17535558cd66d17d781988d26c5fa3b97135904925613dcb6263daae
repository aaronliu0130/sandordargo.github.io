I"í<p><a href="https://amzn.to/2S3gRVr">The Art of Unit Testing</a> is useful for both beginner unit testers and for those who already have a bit of experience. While the edition I read is with C# examples it is useful and understandable for people who work in other languages. People like me.
<!--more--></p>

<p>It is practical, probably as long as you work with statically typed languages, not like Python or Ruby. In dynamic languages, you can extend basically anything at any point in time. You can change behaviour, replace implementations, hence design for testability is not a concern - as confirmed by the author, <a href="https://osherove.com/">Roy Osherove</a>.</p>

<p>In the beginning, the author spends quite some time on defining what is unit testing and he iterates over several definitions reaching the final one:</p>

<blockquote>
  <p>‚ÄúA unit test is an automated piece of code that invokes the unit of work being tested, and then checks some assumptions about a single end result of that unit. A unit test is almost always written using a unit testing framework. It can be written easily and runs quickly. It‚Äôs trustworthy, readable, and maintainable. It‚Äôs consistent in its results as long as production code hasn‚Äôt changed.‚Äù</p>
</blockquote>

<p>This also means that if a test uses the real system time, filesystem or a real database, it‚Äôs not a unit test anymore, but rather an integration test.</p>

<p>I had a discussion about this with other devs, and apparently there are many who accept certain ‚Äúintegration‚Äù tests as unit tests as long as they are deterministic and fast enough.</p>

<p>While the author discusses a lot <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a>, <a href="https://en.wikipedia.org/wiki/SOLID">Solid principles</a> and so, he claims that we can and should speak about three different areas:</p>
<ul>
  <li>unit testing</li>
  <li>code design</li>
  <li>test-driven development</li>
</ul>

<p>According to the author, while test-driven development is useful and has a lot of advantages including more testable code, it won‚Äôt lead automatically to better architecture. The above mentioned three areas are three different skills that one has to learn. The book focuses only on the first one, unit testing.</p>

<p>I found some interesting ideas in the book. At some points, I was a bit surprised and I thought that the content might be outdated. But maybe it was not out-of-date, just a bit language-specific. As an example, I prefer much more dependency injection compared to introducing inheritance just for the sake of unit testability. In C++, methods are not virtual by default and I prefer not to declare something virtual just in order to make it replaceable. Osherove is much more permissive with introducing inheritance for testing purposes. Again, this might depend on the language.</p>

<p>The book doesn‚Äôt only help you learn about unit testing, but also gives advice on where to start unit testing in legacy code - you should definitely read <a href="https://amzn.to/38NwJBn">Your Code as a Crime Scene</a> - and on how to introduce it in an organization, how to convince people. Though, these are not the main topics. If you want to get more detailed information on introducing changes, I‚Äôd advise you to read <a href="http://sandordargo.com/blog/2019/07/31/driving-technical-change">Driving Technical Change by Terrence Ryan</a>.</p>

<p>On the other hand, on unit testing best practices it really goes into details and if you have hard times to convince your peers about some techniques that you heard before here and there, now you have the perfect reference!</p>

<p>I‚Äôd mention one idea from the book, that I have never considered before, not even when I worked with Java and JUnit.</p>

<p>I thought that such a test for asserting that you expect an exception is great:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="nd">@Test</span><span class="o">(</span><span class="n">expected</span> <span class="o">=</span> <span class="nc">IndexOutOfBoundsException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testIndexOutOfBoundsException</span><span class="o">()</span> <span class="o">{</span>

    <span class="nc">List</span> <span class="n">emptyList</span> <span class="o">=</span> <span class="k">new</span> 
    <span class="nc">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">emptyList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>According to <a href="https://osherove.com/">Osherove</a>, it‚Äôs not.</p>

<p>The exception can come from any instruction, not just from the call that you actually want to test. So he prefers the following format instead.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">doStuffThrowsIndexOutOfBoundsException</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">Foo</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Foo</span><span class="o">();</span>

  <span class="nc">IndexOutOfBoundsException</span> <span class="n">e</span> <span class="o">=</span> <span class="n">assertThrows</span><span class="o">(</span>
    <span class="nc">IndexOutOfBoundsException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nl">foo:</span><span class="o">:</span><span class="n">doStuff</span><span class="o">);</span>

  <span class="n">assertThat</span><span class="o">(</span><span class="n">e</span><span class="o">).</span><span class="na">hasMessageThat</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="s">"woops!"</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The point is that your assertion should consider only the call that you expect to throw, no more.</p>

<p>All in all, I liked <a href="https://amzn.to/2S3gRVr">The Art of Unit Testing</a> for its detailed insights. If you work with C#, most probably it‚Äôs the <em>goto</em> book on unit testing, but even for other languages, it is more than useful. Read it, adapt it to your language and help your team to unit test better!</p>

<p>Happy testing!</p>
:ET