I"¥<p>Letâ€™s suppose we have a data model where we store all the winners of wine competitions. I mean virtually. There are nodes with the type of <code class="language-plaintext highlighter-rouge">:COMPETITION</code> and for each competition, we store the winning <code class="language-plaintext highlighter-rouge">:WINE</code>s in a linked list as such:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>(:COMPETITION {name: `Dargo Wine Cup`})-[:LAST_WINNER]-&gt;(:WINE {name: `NiceSyrah 2016`})-&gt;[:PREVIOUS_WINNER]-&gt;(:WINE {name: `Great Cabernet Franc 2015`})-&gt;[:PREVIOUS_WINNER]-&gt;(:WINE {name: `Awesome Kadarka 2014`})
</pre></td></tr></tbody></table></code></pre></div></div>

<p>For the sake of simplicity, we ignore the other attributes of competitions and wines here.</p>

<p>Retrieving the winner of the last year is really simple:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>MATCH (:COMPETITION {name:`Dargo Wine Cup`})-[:LAST_WINNER]-&gt;(winner)
RETURN winner
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Retrieving the winner of the previous year is still an easy task:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>MATCH (:COMPETITION {name:`Dargo Wine Cup`})-[:LAST_WINNER]-&gt;()-&gt;[:PREVIOUS_WINNER]-&gt;(winner)
RETURN winner
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Retrieving winners of the previous years can be done using brute force when you write your queries, but it becomes tedious. Please, donâ€™t do this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>MATCH (:COMPETITION {name:`Dargo Wine Cup`})-[:LAST_WINNER]-&gt;()-&gt;[:PREVIOUS_WINNER]-&gt;()-&gt;[:PREVIOUS_WINNER]-&gt;(winner)
RETURN winner
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Instead, you can explicitly declare the desired relationship length, so that you donâ€™t have to sketch multiple relationships of the same type connecting to each other:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>MATCH (:COMPETITION {name:`Dargo Wine Cup`})-[:LAST_WINNER]-&gt;()-&gt;[:PREVIOUS_WINNER*2]-&gt;(winner)
RETURN winner
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This means that from the node connected with <code class="language-plaintext highlighter-rouge">:LAST_WINNER</code> relationship to our competition we have to hop through wines twice, connected to each other by the <code class="language-plaintext highlighter-rouge">:PREVIOUS_WINNER</code> relationship.</p>

<p>We can easily infer that when you donâ€™t define the relationship length by putting a number following a <code class="language-plaintext highlighter-rouge">*</code> after the relationship type, there is an implicitly defined default length: <code class="language-plaintext highlighter-rouge">*1</code>.</p>

<p>Fixed multiple relationship length is already a nice feature, but there is even more. We can not just return something in a given distance, but we can define a range. If we want to retrieve all the winners of <em>Dargo Wine Cup</em> from the last three years, we can do it as such:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>MATCH (:COMPETITION {name:`Dargo Wine Cup`})-[:LAST_WINNER]-&gt;(last_winner)-&gt;[:PREVIOUS_WINNER*2..3]-&gt;(previous_winner)
RETURN last_winner, previous_winner
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Letâ€™s say you want to return all the winners of <code class="language-plaintext highlighter-rouge">Dargo Wine Cup</code>, but you donâ€™t know when the competition first took place. Either you query that information and pass it to the previous query as a relationship length, or you just say that you want them all.</p>

<p>It is really easy, you just have to omit the number after the <code class="language-plaintext highlighter-rouge">*</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>MATCH (:COMPETITION {name:`Dargo Wine Cup`})-[:LAST_WINNER]-&gt;(last_winner)-&gt;[:PREVIOUS_WINNER*]-&gt;(previous_winner)
RETURN last_winner, previous_winner
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Please keep in mind that this is quite a dangerous option. In a production environment, it can seriously harm your userâ€™s experience in a big enough database. So itâ€™s better to limit your query in a way that in extreme conditions it can still provide an answer in a tolerable time frame.</p>

<p>We have already seen that instead of the default length of 1, you can use bigger lengths, ranges, even infinite lengths, but I havenâ€™t mentioned that you set the length to zero.</p>

<p>Imagine that in our data model there are a lot of competitions including relatively new ones. By relatively new, I mean that they have only the last winner, they donâ€™t have winners from the previous years.</p>

<p>If you want to list all the winners of the last three years, you might want to use the following query:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>MATCH (:COMPETITION)-[:LAST_WINNER]-&gt;(last_winner)-&gt;[:PREVIOUS_WINNER]-&gt;(previous_winner)-&gt;[:PREVIOUS_WINNER]-&gt;(previous_previous_winner)
RETURN last_winner, previous_winner, previous_previous_winner
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This will return you all the winner wines from competitions where there are actually previous winners, but we skip all the winners of competitions which are not old enough to have winners from the last three years. Here we could use <code class="language-plaintext highlighter-rouge">OPTIONAL MATCH</code>, but itâ€™s even easier to use the 0 length:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>MATCH (:COMPETITION)-[:LAST_WINNER]-&gt;(last_winner)-&gt;[:PREVIOUS_WINNER*0..2]-&gt;(previous_winner)
RETURN last_winner, previous_winner
</pre></td></tr></tbody></table></code></pre></div></div>

<p><em>Source: https://graphaware.com/graphaware/2015/05/19/neo4j-cypher-variable-length-relationships-by-example.html</em></p>
:ET