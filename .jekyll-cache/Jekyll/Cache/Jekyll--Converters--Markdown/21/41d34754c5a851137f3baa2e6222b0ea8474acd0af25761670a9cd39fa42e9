I"°3<p>In one of my previous articles, I wrote about Scott Meyer‚Äôs <a href="https://amzn.to/2Rbh5pI">Effective Modern C++</a> and that with its focus on C++11/14 it‚Äôs like discovering a completely new language. I already wrote about <a href="/blog/2018/11/07/trailing-return-type">trailing return type declaration</a>. Now it‚Äôs time to review what usages you might have in C++ for ampersands (<code class="language-plaintext highlighter-rouge">&amp;</code>).
<!--more--></p>

<p>Let‚Äôs start with the good old, better-known usages:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&amp;</code> to declare a reference to a type</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;</code> to get the address of a variable</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;</code> as a bit-wise operator</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;&amp;</code> in a conditional expression</li>
</ul>

<p>These are not new, but ‚Äúrepetition is the mother of learning‚Äù.</p>

<h2 id="use--to-declare-a-reference-to-a-type">Use <code class="language-plaintext highlighter-rouge">&amp;</code> to declare a reference to a type</h2>

<p>If you use <code class="language-plaintext highlighter-rouge">&amp;</code> in the left-hand side of a variable declaration, it means that you expect to have a <a href="https://www.tutorialspoint.com/cplusplus/cpp_references.htm">reference</a> to the declared type. It can be used in any type of declarations (local variables, class members, method parameters).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre>std::string mrSamberg("Andy");
std::string&amp; theBoss = mrSamberg;
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This doesn‚Äôt just mean that both <code class="language-plaintext highlighter-rouge">mrSamberg</code> and <code class="language-plaintext highlighter-rouge">theBoss</code> will have the same value, but they will actually point to the same place in the memory. You can read more about references <a href="https://www.tutorialspoint.com/cplusplus/cpp_references.htm">here</a>.</p>

<h2 id="use--to-get-the-address-of-a-variable">Use <code class="language-plaintext highlighter-rouge">&amp;</code> to get the address of a variable</h2>

<p>The meaning of <code class="language-plaintext highlighter-rouge">&amp;</code> changes if you use it in the right-hand side of an expression. In fact, if you use it on the left-hand side, it must be used in a variable declaration, on the right-hand side, it can be used in assignments too.</p>

<p>When using it on the right-hand side of a variable, it‚Äôs also known as the ‚Äúaddress-of operator‚Äù. Not surprisingly if you put it in front of a variable, it‚Äôll return its address in the memory instead of the variable‚Äôs value itself. It is useful for pointer declarations.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre>std::string mrSamberg("Andy");
std::string* theBoss;

theBoss = &amp;mrSamberg;

</pre></td></tr></tbody></table></code></pre></div></div>

<p>The end result of the previous snippet is the same as previously. Although the type of <code class="language-plaintext highlighter-rouge">theBoss</code> is different. Previously it was a reference, now it‚Äôs a pointer. The main difference is that a pointer can be null, while a reference must point to a valid value. (Well‚Ä¶ There are shortcuts‚Ä¶ But that‚Äôs beyond our scope in this article.). More on this topic <a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in">here</a>.</p>

<h2 id="use--as-a-bitwise-operator">Use <code class="language-plaintext highlighter-rouge">&amp;</code> as a bitwise operator</h2>

<p>It is the bitwise AND. Its an infix operator taking two numbers as inputs and doing an <code class="language-plaintext highlighter-rouge">AND</code> on each of the bit pairs of the inputs. Here is an example. 14 is represented as <em>1110</em> as a binary number and 42 can be written as <em>101010</em>. So <em>1110</em> (14) will be zero filed from the left and then the operation goes like this.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">¬†</th>
      <th style="text-align: center">32</th>
      <th style="text-align: center">16</th>
      <th style="text-align: center">8</th>
      <th style="text-align: center">4</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">14</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: right">42</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: right">14&amp;42=10</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
    </tr>
  </tbody>
</table>

<h2 id="use--in-a-logical-expression">Use <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> in a logical expression</h2>

<p><code class="language-plaintext highlighter-rouge">&amp;&amp;</code> in a (logical) expression is just the C-style way to say <code class="language-plaintext highlighter-rouge">and</code>. That‚Äôs it.</p>

<h2 id="use--for-declaring-rvalue-references">Use <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> for declaring rvalue references</h2>

<p>Declaring a what? - you might ask. Okay, so let‚Äôs clarify first what are lvalues and rvalues and what are the differences.</p>

<p>According to <a href="https://eli.thegreenplace.net/">Eli Bendersky</a>:</p>

<blockquote>
  <p>An lvalue (locator value) represents an object that occupies some identifiable location in memory (i.e. has an address).</p>

  <p>rvalues are defined by exclusion, by saying that every expression is either an lvalue or an rvalue. Therefore, from the above definition of lvalue, an rvalue is an expression that does not represent an object occupying some identifiable location in memory.</p>
</blockquote>

<p>Let‚Äôs take one example to show both an lvalue and an rvalue.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>auto mrSamberg = std::string{"Andy"};
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">mrSamberg</code> represents an lvalue. It points to a specific place in the memory which identifies an object. On the other hand, what you can find on the right side <code class="language-plaintext highlighter-rouge">std::string{"Andy"}</code> is actually an rvalue. It‚Äôs an expression that can‚Äôt have a value assigned to, that‚Äôs already the value itself. It can be only on the right-hand side of an assignment operator.</p>

<p>For a better and deeper explanation, please read <a href="https://eli.thegreenplace.net/">Eli‚Äôs article</a>.</p>

<p>Although rvalues can only appear on the right-hand side, still one can capture references to them. Those ‚Äúcaptures‚Äù are called <em>rvalue references</em> and such variables have to be declared with double ampersands (<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>). Binding such temporaries are needed to implement move semantics and perfect forwarding. (I‚Äôll explain perfect forwarding and move semantics in a later article.)</p>

<h2 id="use--for-declaring-universal-references">Use <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> for declaring universal references</h2>

<p>The bad news is that <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> after a type might or might not mean that you are declaring an rvalue reference. In certain circumstances, it only means something that [Scott Meyers] calls a universal reference in his <a href="https://amzn.to/2Rbh5pI">Effective Modern C++</a>.</p>

<p>What are those circumstances? Briefly, if type deduction takes place, you declare a universal reference, if not an rvalue reference.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> --><td class="rouge-code"><pre>Vehicle car;
auto&amp;&amp; car2 = car; // type deduction! this is a universal reference!
Vehicle&amp;&amp; car3 = car; // no type deduction, so it's an rvalue reference
</pre></td></tr></tbody></table></code></pre></div></div>

<p>There is another possibility, it‚Äôs in case of templates. Taking the example from <a href="https://amzn.to/2Rbh5pI">Effective Modern C++</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre>template&lt;typename T&gt;
void f(std::vector&lt;T&gt;&amp;&amp; param);     // rvalue reference

template&lt;typename T&gt;
void f(T&amp;&amp; param); // type deduction occurs, so this is a universal reference!
</pre></td></tr></tbody></table></code></pre></div></div>

<p>There are more subtilities in the case of templates, but again, it‚Äôs beyond the scope. Read Item 24 from <a href="https://amzn.to/2Rbh5pI">Effective Modern C++</a> in case you want to learn more about how to distinguish universal references from rvalue references.</p>

<h2 id="use--or--for-function-overloading">Use <code class="language-plaintext highlighter-rouge">&amp;</code> or <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> for function overloading</h2>

<p>We are not finished yet.</p>

<p>Since C++11 you can use both the single and double ampersands as part of the function signature, but not part of the parameter list. If I‚Äôm not clear enough, let me give the examples:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre>void doSomething() &amp;;
void doSomething() &amp;&amp;;
auto doSomethingElse() &amp; -&gt; int;
auto doSomethingElse() &amp;&amp; -&gt; int;
</pre></td></tr></tbody></table></code></pre></div></div>

<p>What this means is that you can limit the use of a member function based on whether <code class="language-plaintext highlighter-rouge">*this</code> is a lvalue or an rvalue.  So you can only use this feature within classes, of course. Let‚Äôs expand our example.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> --><td class="rouge-code"><pre>class Tool {
public:
  // ...
  void doSomething() &amp;; // used when *this is a lvalue
  void doSomething() &amp;&amp;; // used when *this is a rvalue
};

Tool makeTool(); //a factory function returning an rvalue

Tool t; // t is an lvalue

t.doSomething(); // Tool::doSomething &amp; is called

makeTool().doSomething(); // Tool::doSomething &amp;&amp; is called
</pre></td></tr></tbody></table></code></pre></div></div>

<p>When would you use this kind of differentiation? Mostly when you‚Äôd like to optimize your memory footprint by taking advantage of move semantics. In a later post, I‚Äôll go more deeply on that.</p>

<h2 id="conslusion">Conslusion</h2>

<p>In this post, you saw 7 different type of usages the ampersands in C++. They can be used in single or double form, in variable declarations, function declarations and conditional expressions.</p>

<p>I didn‚Äôt intend to give you a full explanation of each. Move semantics and perfect forwarding can fill multiple chapters of good books, like in <a href="https://amzn.to/2Rbh5pI">Effective Modern C++</a>. On the other hand, I‚Äôll try to give a deeper explanation on those topics in a later post.</p>
:ET