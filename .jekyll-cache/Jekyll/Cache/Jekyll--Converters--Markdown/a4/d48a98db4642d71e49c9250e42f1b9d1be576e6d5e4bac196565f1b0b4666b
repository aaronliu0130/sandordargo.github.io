I"êz<p>Welcome back to the series about C++ concepts. In the previous episodes, we discussed what are the motivations behind concepts, and then how to use them. Today we are going to have an overview of what kind of concepts are shipped with the C++ standard library.
<!--more--></p>

<p>C++20 hasnâ€™t only given us the ability to write powerful concepts, but it also comes with more than 50 concepts part of the standard library and shared across three different headers.</p>

<h2 id="concepts-in-the-concepts-header">Concepts in the <code class="language-plaintext highlighter-rouge">&lt;concepts&gt;</code> header</h2>

<p>In the <code class="language-plaintext highlighter-rouge">&lt;concepts&gt;</code> header you will find the most generic ones expressing core language concepts, comparison concepts and object concepts.</p>

<p>We are not going to explore all of them here for obvious reasons, you can find <a href="https://en.cppreference.com/w/cpp/concepts">the full list here</a>. Let me just pick three concepts so that we can get the idea.</p>

<h3 id="stdconvertible_to-for-conversions-with-fewer-surprises"><code class="language-plaintext highlighter-rouge">std::convertible_to</code> for conversions with fewer surprises</h3>

<p><code class="language-plaintext highlighter-rouge">std::convertible_to</code> helps you to express that you only accept types that are convertible to another type - a type that you specify. The conversion can be both explicit or implicit. For example, you can say that you only accept types that can be converted into a <code class="language-plaintext highlighter-rouge">bool</code>. As the first parameter, you pass the type you want a conversion to be valid <code class="language-plaintext highlighter-rouge">From</code> and as the second, the type you want to be able to convert <code class="language-plaintext highlighter-rouge">To</code>, in our case, <code class="language-plaintext highlighter-rouge">bool</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="n">T</span> <span class="n">bar</span><span class="p">)</span> <span class="n">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="n">fun</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// OK an int can be converted into a pointer</span>
<span class="c1">//  fun(std::string("Not OK")); // oid fun(T) requires  convertible_to&lt;T, bool&gt; [with T = std::__cxx11::basic_string&lt;char&gt;]' with unsatisfied constraints</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="stdtotally_ordered-for-defined-comparisons"><code class="language-plaintext highlighter-rouge">std::totally_ordered</code> for defined comparisons</h3>

<p><code class="language-plaintext highlighter-rouge">std::totally_ordered</code> helps to accept types that specify all the 6 comparison operators (<code class="language-plaintext highlighter-rouge">==</code>,<code class="language-plaintext highlighter-rouge">!=</code>,<code class="language-plaintext highlighter-rouge">&lt;</code>,<code class="language-plaintext highlighter-rouge">&gt;</code>,<code class="language-plaintext highlighter-rouge">&lt;=</code>,<code class="language-plaintext highlighter-rouge">&gt;=</code>) and that the results are consistent with a <a href="https://en.wikipedia.org/wiki/Total_order#Strict_total_order">strict total order</a> on T.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
#include &lt;iostream&gt;
#include &lt;typeinfo&gt; 
</span>
<span class="k">struct</span> <span class="nc">NonComparable</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Comparable</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Comparable</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="n">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">totally_ordered</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" can be ordered</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">NonComparable</span> <span class="n">nc</span><span class="p">{</span><span class="mi">666</span><span class="p">};</span>
<span class="c1">//   fun(nc); // Not OK: error: use of function 'void fun(T) requires  totally_ordered&lt;T&gt; [with T = NonComparable]' with unsatisfied constraints</span>
  <span class="n">Comparable</span> <span class="n">c</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
  <span class="n">fun</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In the above example, you can also observe how to easily use the <code class="language-plaintext highlighter-rouge">&lt;=&gt;</code> (a.k.a. spaceship) operator to generate all the comparison operators.</p>

<p>If you are looking for more information on the <code class="language-plaintext highlighter-rouge">&lt;=&gt;</code> operator, I highly recommend reading <a href="https://www.modernescpp.com/index.php/c-20-more-details-to-the-spaceship-operator">this article from Modernes C++</a>.</p>

<h3 id="stdcopyable-for-copyable-types"><code class="language-plaintext highlighter-rouge">std::copyable</code> for copyable types</h3>

<p><code class="language-plaintext highlighter-rouge">std::copyable</code> helps you to ensure that only such types are accepted whose instances can be copied. <code class="language-plaintext highlighter-rouge">std::copyable</code> object must be copy constructible, assignable and movable.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;concepts&gt;
#include &lt;iostream&gt;
#include &lt;typeinfo&gt; 
</span>
<span class="k">class</span> <span class="nc">NonMovable</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">NonMovable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="o">~</span><span class="n">NonMovable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="n">NonMovable</span><span class="p">(</span><span class="k">const</span> <span class="n">NonMovable</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">NonMovable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NonMovable</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  
  <span class="n">NonMovable</span><span class="p">(</span><span class="n">NonMovable</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">NonMovable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">NonMovable</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">NonCopyable</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">NonCopyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="o">~</span><span class="n">NonCopyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="n">NonCopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyable</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyable</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  
  <span class="n">NonCopyable</span><span class="p">(</span><span class="n">NonCopyable</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">NonCopyable</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Copyable</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Copyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="o">~</span><span class="n">Copyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="n">Copyable</span><span class="p">(</span><span class="k">const</span> <span class="n">Copyable</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">Copyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Copyable</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="n">Copyable</span><span class="p">(</span><span class="n">Copyable</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">Copyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Copyable</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="n">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">copyable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" is copyable</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">NonMovable</span> <span class="n">nm</span><span class="p">;</span>
<span class="c1">//   fun(nm); // error: use of function 'void fun(T) requires  copyable&lt;T&gt; [with T = NonMovable]' with unsatisfied constraints</span>
  <span class="n">NonCopyable</span> <span class="n">nc</span><span class="p">;</span>
<span class="c1">//   fun(nc); // error: use of function 'void fun(T) requires  copyable&lt;T&gt; [with T = NonCopyable]' with unsatisfied constraints</span>
  <span class="n">Copyable</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">fun</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As you can see in the above example, class <code class="language-plaintext highlighter-rouge">NonMovable</code> doesnâ€™t satisfy the concept as its move assignment and move constructor are deleted.</p>

<p>For <code class="language-plaintext highlighter-rouge">NonCopiable</code>, itâ€™s a similar case, but while the move semantics are available, it lacks the copy assignment and the copy constructor.</p>

<p>Finally, <code class="language-plaintext highlighter-rouge">Copyable</code> class defaults all the 5 special member functions and as such, it satisfies the concept of <code class="language-plaintext highlighter-rouge">std::copyable</code>.</p>

<h2 id="concepts-in-the-iterator-header">Concepts in the <code class="language-plaintext highlighter-rouge">&lt;iterator&gt;</code> header</h2>

<p>In the <a href="https://en.cppreference.com/w/cpp/iterator#Algorithm_concepts_and_utilities"><code class="language-plaintext highlighter-rouge">&lt;iterator&gt;</code></a> header, youâ€™ll mostly find concepts that will come in handy when you deal with <a href="https://www.sandordargo.com/blog/2019/01/30/stl-algos-intro">algorithms</a>. It makes sense if you think about it, as the functions of the <code class="language-plaintext highlighter-rouge">&lt;algorithms&gt;</code> header operate on the containers through iterators, not directly on the containers.</p>

<h3 id="stdindirect_unary_predicatef-i"><code class="language-plaintext highlighter-rouge">std::indirect_unary_predicate&lt;F, I&gt;</code></h3>

<p>There are concepts related to callables, e.g. you can specify that you accept only unary predicates. First, what is a predicate? A predicate is a callable that returns either a <code class="language-plaintext highlighter-rouge">bool</code> value or value that is convertible to a <code class="language-plaintext highlighter-rouge">bool</code>. A unary predicate is a predicate that takes one parameter as its input.</p>

<p>I know that the following example is not very realistic, itâ€™s only for demonstrational purposes.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">I</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">F</span> <span class="n">fun</span><span class="p">,</span> <span class="n">I</span> <span class="n">iterator</span><span class="p">)</span> <span class="n">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">indirect_unary_predicate</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">I</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">iterator</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">biggerThan42</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span><span class="k">return</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">42</span><span class="p">;};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">numbers</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">66</span><span class="p">};</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">foo</span><span class="p">(</span><span class="n">biggerThan42</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In the above example <code class="language-plaintext highlighter-rouge">foo</code> takes a function and an iterator and the concept <code class="language-plaintext highlighter-rouge">std::indirect_unary_predicate</code> ensures that the passed-in function can take the value pointed by the iterator and return a <code class="language-plaintext highlighter-rouge">bool</code> instead.</p>

<h3 id="stdindirectly_comparable"><code class="language-plaintext highlighter-rouge">std::indirectly_comparable</code></h3>

<p>In the <a href="https://en.cppreference.com/w/cpp/iterator#Algorithm_concepts_and_utilities"><code class="language-plaintext highlighter-rouge">&lt;iterator&gt;</code></a> header youâ€™ll not only find concepts related to callables but more generic ones as well. Such as whether two types are inderictly comparable. That sounds interesting, letâ€™s take a simple example:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Il</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Ir</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">F</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">Il</span> <span class="n">leftIterator</span><span class="p">,</span> <span class="n">Ir</span> <span class="n">rightIterator</span><span class="p">,</span> <span class="n">F</span> <span class="n">function</span><span class="p">)</span> <span class="n">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">indirectly_comparable</span><span class="o">&lt;</span><span class="n">Il</span><span class="p">,</span> <span class="n">Ir</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">leftIterator</span><span class="p">,</span> <span class="o">*</span><span class="n">rightIterator</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">string_literals</span><span class="p">;</span>
  
  <span class="k">auto</span> <span class="n">binaryLambda</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">){</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">};</span>
  <span class="k">auto</span> <span class="n">binaryLambda2</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">j</span><span class="p">){</span><span class="k">return</span> <span class="mi">666</span><span class="p">;};</span>
  
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">ints</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">66</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">floats</span><span class="p">{</span><span class="mf">15.1</span><span class="p">,</span> <span class="mf">42.3</span><span class="p">,</span> <span class="mf">66.6</span><span class="p">};</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">ints</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">floats</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">binaryLambda</span><span class="p">);</span>
<span class="c1">//   foo(ints.begin(), floats.begin(), binaryLambda2); // error: use of function 'void foo(Il, Ir, F) requires  indirectly_comparable&lt;Il, Ir, F, std::identity, std::identity&gt; </span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this case, Iâ€™ve been left a bit puzzled by the <a href="https://en.cppreference.com/w/cpp/iterator/indirectly_comparable">documentation</a>:</p>
<ul>
  <li>As a third template parameter it has <code class="language-plaintext highlighter-rouge">class R</code> which normally would refer to ranges.</li>
  <li>But then according to its definition, it calls <code class="language-plaintext highlighter-rouge">std::indirect_binary_predicate</code> with <code class="language-plaintext highlighter-rouge">R</code> forwarded in the first position.</li>
  <li>In <a href="https://en.cppreference.com/w/cpp/iterator/indirect_binary_predicate"><code class="language-plaintext highlighter-rouge">std::indirect_binary_predicate</code></a>, in the first position, you accept a <code class="language-plaintext highlighter-rouge">class F</code> and F stands for a callable (often a function).</li>
</ul>

<p>Why isnâ€™t <code class="language-plaintext highlighter-rouge">R</code> called <code class="language-plaintext highlighter-rouge">F</code>? Why binary predicates are not mentioned in the textual description?</p>

<p>Probably only because this is still the beginning of the concepts journey. Iâ€™m actually going to submit a change request on this item.</p>

<h2 id="concepts-in-the-ranges-header">Concepts in the <code class="language-plaintext highlighter-rouge">&lt;ranges&gt;</code> header</h2>

<p>In the <a href="https://en.cppreference.com/w/cpp/ranges#Range_concepts"><code class="language-plaintext highlighter-rouge">&lt;ranges&gt;</code></a> header youâ€™ll find concepts describing requirements on different types of ranges.</p>

<p>Or simply that a parameter is a <code class="language-plaintext highlighter-rouge">range</code>. But you can assert for any kind of ranges, like <code class="language-plaintext highlighter-rouge">input_range</code>, <code class="language-plaintext highlighter-rouge">output_range</code>, <code class="language-plaintext highlighter-rouge">forward_range</code>, etc.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;typeinfo&gt; 
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">R</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">R</span> <span class="n">range</span><span class="p">)</span> <span class="n">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">borrowed_range</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">range</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" is a borrowed range</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">numbers</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">66</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">stringView</span><span class="p">{</span><span class="s">"is this borrowed?"</span><span class="p">};</span>
<span class="c1">//   foo(numbers); // error: use of function 'void foo(R) requires  borrowed_range&lt;R&gt; [with R = std::vector&lt;int, std::allocator&lt;int&gt; &gt;]' with unsatisfied constraints</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">stringView</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The above example checks whether a type satisfies the concept of a <code class="language-plaintext highlighter-rouge">borrowed_range</code>. We can observe that a <code class="language-plaintext highlighter-rouge">std::string_view</code> does, while a <code class="language-plaintext highlighter-rouge">vector</code> doesnâ€™t.</p>

<p>If you are curious, having a borrowed range means that a function can take it by value and can return an iterator obtained from it without any dangers of dangling. For more details, <a href="https://en.cppreference.com/w/cpp/ranges/borrowed_range">click here</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Today weâ€™ve seen a few examples of concepts shipped with the C++20 standard library. There are about 50 of them shared among 3 headers (<code class="language-plaintext highlighter-rouge">concepts</code>, <code class="language-plaintext highlighter-rouge">iterators</code>, <code class="language-plaintext highlighter-rouge">ranges</code>).</p>

<p>Next week, we are going to see how to implement our own concepts.</p>
:ET