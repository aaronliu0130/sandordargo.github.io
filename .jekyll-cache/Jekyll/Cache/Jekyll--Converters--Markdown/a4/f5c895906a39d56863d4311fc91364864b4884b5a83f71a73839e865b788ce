I"ê<p>This is post is not yet another one about Git aliases. Some like them, some donâ€™t. I use only a few. For the commands, I use the most and the ones I wouldnâ€™t forget anyway. In other words, Iâ€™m lazy to write <code class="language-plaintext highlighter-rouge">status</code> and <code class="language-plaintext highlighter-rouge">commit</code> all the time. These aliases are not worth a post. On the other hand, I modify my prompt in the terminal to give me a lot of information about the current state of the repository Iâ€™m at and I also use auto-completion for git commands.
<!--more--></p>

<p>When Iâ€™m not in a git repository, my prompt is not altered. This is the default state of my prompt:</p>

<p><img src="/assets/img/gitprompt-no-repo.png" alt="Not in a git repo" title="Not in a git repo" /></p>

<p>Letâ€™s create a new git repository by issuing the <code class="language-plaintext highlighter-rouge">git init</code> command right here on spot and see whatâ€™s going to happen. As you can see on the below image we are on the master branch, plus we see a hashtag. That hashtag shows that we are still in the init stage, the repository initialization has not finished yet.</p>

<p><img src="/assets/img/gitprompt-after-init.png" alt="After a git init" title="After a git init" /></p>

<p>Letâ€™s create a new file (i.e. <em>somefile.txt</em>) and commit it. Now our repository is in a clean state. We will see only the name of our current branch.</p>

<p>So if Iâ€™m in a git repository and it has a clean state, Iâ€™ll simply see the name of the current branch:</p>

<p><img src="/assets/img/gitprompt-clean.png" alt="In a clean branch" title="In a clean branch" /></p>

<p>Now, Iâ€™m going to modify <em>somefile.txt</em> and letâ€™s see how the prompt changes. A star appears after the branch name. That <code class="language-plaintext highlighter-rouge">*</code> means that I have an unstaged tracked file.</p>

<p><img src="/assets/img/gitprompt-unstaged.png" alt="Having an unstaged file" title="Having an unstaged file" /></p>

<p>Letâ€™s add another file (<em>newfile.txt</em>) and stage it immediately. Our prompt changed again, we have both a <code class="language-plaintext highlighter-rouge">*</code> and <code class="language-plaintext highlighter-rouge">+</code>. As you might have guessed that <code class="language-plaintext highlighter-rouge">+</code> is to show that we have a staged file.</p>

<p><img src="/assets/img/gitprompt-staged-unstaged.png" alt="Having a staged and an unstaged file" title="Having a staged and an unstaged file" /></p>

<p>Now letâ€™s stage <em>somefile.txt</em> as well, so we have only staged files. As we expect, the <code class="language-plaintext highlighter-rouge">*</code> disappears we are left only with the <code class="language-plaintext highlighter-rouge">+</code>.</p>

<p><img src="/assets/img/gitprompt-staged.png" alt="Having only staged files" title="Having only staged files" /></p>

<p>In order to finish our cycle and to have a clean repo again, we have to commit. Our working area is clean again. There are no unstaged or staged files.</p>

<p><img src="/assets/img/gitprompt-clean-again.png" alt="In a clean branch again" title="In a clean branch again" /></p>

<h2 id="key-takeaways">Key Takeaways</h2>

<p>To wrap it up, my prompt will always show the checked out branch name or commit hash. Besides it will display a <code class="language-plaintext highlighter-rouge">*</code> if we have any unstaged change on a tracked file and <code class="language-plaintext highlighter-rouge">+</code> if we have any staged files.</p>

<p>It also gives you some extra information during rebases and when you resolve merge conflicts.</p>

<p>This can save you issuing a lot a of <code class="language-plaintext highlighter-rouge">git branch</code> or <code class="language-plaintext highlighter-rouge">git rev-parse --abbrev-ref HEAD</code> to see in which branch you are and in addition you wonâ€™t need some of the <code class="language-plaintext highlighter-rouge">git status</code> commands as well as youâ€™ll know just by looking at your prompt if you are in a clean state or if you still have to stage some files while preparing your next commit.</p>

<h2 id="hot-to-get-it">Hot to get it</h2>

<p>I donâ€™t want to take the credit for this. The credit goes to Carolyn and Sarah who have <a href="https://classroom.udacity.com/courses/ud775">this super course about Git on Udacity</a>. We started to use git in my company a couple years ago and after some time I realized that if I use only the push/pull/commit/diff/status quintuple I will keep having troubles and Iâ€™ll like neither git, neither my work.</p>

<p>I enrolled to <a href="https://classroom.udacity.com/courses/ud775">this course</a> and understood better many concepts. They also provided a nice style-guide and these scripts. Iâ€™ll be always grateful to them.</p>

<p>Linux and Mac users will need to save <a href="https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash">this file auto-completion</a> and <a href="https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh">this file for checking the state of your repo</a>, and <a href="https://www.udacity.com/api/nodes/3341718587/supplemental_media/bash-profile-course/download?_ga=1.37232743.672083044.1467344711">this</a> helps you to set up your prompt using the previous two files.</p>

<p>If you are on Windows or if you want more details, check out the <a href="https://classroom.udacity.com/courses/ud775">course</a>, itâ€™s for free!</p>
:ET