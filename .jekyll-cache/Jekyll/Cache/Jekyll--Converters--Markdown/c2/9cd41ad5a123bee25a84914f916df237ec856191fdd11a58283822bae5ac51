I"æ8<p>In this post, we will discover the three different ways you could use the <code class="language-plaintext highlighter-rouge">delete</code> specifier in C++. We are going to see how</p>
<ul>
  <li>you can disallow an object from being copied</li>
  <li>you can limit what kind of implicit conversions you allow for a function call</li>
  <li>you can limit what kind of template instantiations you allow
 <!--more--></li>
</ul>

<h2 id="how-to-disallow-copyingmoving-for-a-class">How to disallow copying/moving for a class?</h2>

<p>The first question to answer is why would you need such a feature? You might not want a class to be copied or moved, so you want to keep related special functions unreachable for the caller.</p>

<p>In order to achieve this, there is a legacy and a modern option.</p>

<p>The legacy option is to declare them as private or protected and the modern one (since C++11) is that you explicitly delete them.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">NonCopyable</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">NonCopyable</span><span class="p">()</span> <span class="p">{</span><span class="cm">/*...*/</span><span class="p">}</span>
  <span class="c1">// ...</span>
<span class="nl">private:</span>
  <span class="n">NonCopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyable</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">//not defined</span>
  <span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyable</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">//not defined</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Before C++11 there was no other option than declaring the unneeded special functions private and not implementing them. As such one could disallow copying objects (there was no move semantics available back in time). The lack of implementation/definition helps against accidental usages in member functions, friends, or when you ignore the access specifiers. It doesnâ€™t cause a compile-time failure, youâ€™ll face a problem at linking time.</p>

<p>Since C++11 you can simply mark them deleted by declaring them as <code class="language-plaintext highlighter-rouge">= delete;</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">NonCopyable</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">NonCopyable</span><span class="p">()</span> <span class="p">{</span><span class="cm">/*...*/</span><span class="p">}</span>
  <span class="n">NonCopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyable</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyable</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="nl">private:</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>The C++11 way is a better approach because</p>
<ul>
  <li>itâ€™s more explicit than having the functions in the private section which might only be a mistake by the developer</li>
  <li>in case you try to make a copy, youâ€™ll already get an error at compilation time</li>
</ul>

<p>Itâ€™s worth to note that deleted functions should be declared as public, not private. In case, you make them private some compilers might only complain about that you call a private function, not that a deleted one.</p>

<h2 id="how-to-disallow-implicit-conversions-for-function-calls">How to disallow implicit conversions for function calls?</h2>

<p>You have a function taking integer numbers. Whole numbers. Letâ€™s say it takes as a parameter how many people can sit in a car. It might be 2, there are some strange three-seaters, for some luxury cars itâ€™s 4 and for the vast majority, itâ€™s 5. Itâ€™s not 4.9. Itâ€™s not 5.1 or not even 5 and a half. Itâ€™s 5. We donâ€™t traffic body parts.</p>

<p>How can you enforce that you only receive whole numbers as a parameter?</p>

<p>Obviously, youâ€™ll take an integer parameter. It might be <code class="language-plaintext highlighter-rouge">int</code>, even <code class="language-plaintext highlighter-rouge">unsigned</code> or simply a <code class="language-plaintext highlighter-rouge">short</code>. There are a lot of options. You probably even document that the <code class="language-plaintext highlighter-rouge">numberOfSeats</code> parameter should be an integral number.</p>

<p>Great!</p>

<p>So what happens if the client call still passes a float?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">numberOfSeats</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Number of seats: "</span> <span class="o">&lt;&lt;</span> <span class="n">numberOfSeats</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="mf">5.6</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
Number of seats: 5
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The floating-point parameter is accepted and narrowed down into an integer. You cannot even say that itâ€™s rounded, itâ€™s implicitly converted, narrowed down into an integer.</p>

<p>You might say that this is fine and in certain situation it probably is. But in others, this behaviour is simply not acceptable.</p>

<p>What can you do in such cases to avoid this problem?</p>

<p>You might handle it on the caller side, but</p>
<ul>
  <li>if <code class="language-plaintext highlighter-rouge">foo</code> is often used, itâ€™d tedious to do the checks at each call and code reviews are not reliable enough,</li>
  <li>if <code class="language-plaintext highlighter-rouge">foo</code> is part of an API used by the external world, itâ€™s out of your control.</li>
</ul>

<p>As we have seen in the previous section, since C++11, we can use the <code class="language-plaintext highlighter-rouge">delete</code> specifier in order to restrict certain types from being copied or moved. But <code class="language-plaintext highlighter-rouge">= delete</code> can be used for more. It can be applied to any functions, member or standalone.</p>

<p>If you donâ€™t want to allow implicit conversions from floating-point numbers, you can simply delete fooâ€™s overloaded version with a float:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">numberOfSeats</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Number of seats: "</span> <span class="o">&lt;&lt;</span> <span class="n">numberOfSeats</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// foo(5);</span>
    <span class="n">foo</span><span class="p">(</span><span class="mf">5.6</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
main.cpp: In function 'int main()':
main.cpp:12:13: error: use of deleted function 'void foo(double)'
   12 |     foo(5.6f);
      |             ^
main.cpp:8:6: note: declared here
    8 | void foo(double) = delete;
      |      ^~~
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Et voila! - as the French would say. Thatâ€™s it. By deleting some overloads of a function, you can forbid implicit conversions from certain types. Now, you are in complete control of the type of parameters your users can pass through your API.</p>

<h2 id="how-to-disallow-certain-instantiations-of-a-template">How to disallow certain instantiations of a template</h2>

<p>This kind approach also works with templates, you can disallow the instantiations of your templated function with certain types:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*..*/</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>If you call this function, letâ€™s say with an integer, it will compile just fine:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="n">bar</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>However, you can delete the instantiation with <code class="language-plaintext highlighter-rouge">int</code>, and then you receive a similar error message compared to the previous one:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*..*/</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">bar</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">bar</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
main.cpp: In function â€˜int main()â€™:
main.cpp:10:15: error: use of deleted function â€˜void bar(T) [with T = int]â€™
   10 |     bar&lt;int&gt;(5);
      |               ^
main.cpp:7:6: note: declared here
    7 | void bar&lt;int&gt;(int) = delete;
      |      ^~~~~~~~
*/</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Just keep in mind, that <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">const T</code> are different types and if you delete one, you should consider deleting the other too. This is only valid for the templates, not when you delete function overloads.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Today we saw 3 ways how to use the <code class="language-plaintext highlighter-rouge">delete</code> specifier that is available for us since C++11. We can make classes non-copyable and/or non-movable with its help, but we can also disallow implicit conversions for function parameters and we can even disallow template instantiations for any type. Itâ€™s a great tool to create a tight, strict <a href="https://www.youtube.com/watch?v=nLSm3Haxz0I">API that is difficult to misuse</a>.</p>
:ET