I"¬<p>In this next part of <a href="http://sandordargo.com/blog/2019/01/30/stl-algos-intro">the big STL algorithm tutorial</a>, we will discover some of modifying sequence operations who involve either move or swap:
<!--more--></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">move</code></li>
  <li><code class="language-plaintext highlighter-rouge">move_backward</code></li>
  <li><code class="language-plaintext highlighter-rouge">swap</code></li>
  <li><code class="language-plaintext highlighter-rouge">swap_ranges</code></li>
  <li><code class="language-plaintext highlighter-rouge">iter_swap</code></li>
</ul>

<h2 id="move"><code class="language-plaintext highlighter-rouge">move</code></h2>

<p><code class="language-plaintext highlighter-rouge">move</code> is pretty similar to <a href="http://sandordargo.com/blog/2019/08/14/stl-alogorithms-tutorial-part-5-copy-operations"><code class="language-plaintext highlighter-rouge">copy</code></a>, they both take two iterators defining an input range and one to mark the beginning of the output range.</p>

<p>While <code class="language-plaintext highlighter-rouge">copy</code> leaves the input intact, <code class="language-plaintext highlighter-rouge">move</code> will <em>transfer</em> objects from one range to another. It uses the move semantics introduced in C++11 eleven, meaning that the algorithm itself is available since C++11.</p>

<p>What happens to the source objects is normally defined in its move assignment operator. But be aware that if for example the move assignment operator is not implemented, calling <code class="language-plaintext highlighter-rouge">std::move</code> on the object will not fail. You wonâ€™t even get a compiler warning. Instead, the available assignment operator will be called.</p>

<p>The usage of <code class="language-plaintext highlighter-rouge">std::move</code> is a possibility, not something you can take for granted. Just to repeat, this means that if the compiler doesnâ€™t find an implementation for the move constructor/move assignment operator, then it will simply use the copy constructor/assignment operator.</p>

<p>With your types, you can control it, but in a big old codebase, you might not see or forget to check if move semantics are supported or not, you think you can use them and in fact, you donâ€™t. This might cost you some performance overhead you donâ€™t want to use.</p>

<p>Here is a sample example of how to use it.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
</span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>  
<span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_a</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// std::cout &lt;&lt; "this is not a move but simple ctr\n";    </span>
<span class="p">}</span>  

<span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">m_a</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// std::cout &lt;&lt; "this is not a move but copy ctr\n";</span>
<span class="p">}</span>   

<span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>    
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_a</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_a</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"this is not a move but an assignment operator</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>   

<span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>    
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_a</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"this is now move assignment</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m_a</span><span class="p">;</span>
<span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_a</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>  

  <span class="k">auto</span> <span class="n">myVect</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">{</span><span class="n">A</span><span class="p">(</span><span class="s">"1"</span><span class="p">),</span> <span class="n">A</span><span class="p">(</span><span class="s">"2"</span><span class="p">),</span> <span class="n">A</span><span class="p">(</span><span class="s">"3"</span><span class="p">),</span> <span class="n">A</span><span class="p">(</span><span class="s">"4"</span><span class="p">),</span> <span class="n">A</span><span class="p">(</span><span class="s">"5"</span><span class="p">)};</span> 
  <span class="k">auto</span> <span class="n">outputVect</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"0"</span><span class="p">)};</span>
  <span class="n">outputVect</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">myVect</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The content of myVect: "</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">:</span> <span class="n">myVect</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
  <span class="p">}</span>  
  
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The content of outputVect: "</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">:</span> <span class="n">outputVect</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"LET'S MOVE</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">myVect</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myVect</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">outputVect</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"MOVES are done</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The content of myVect: "</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">:</span> <span class="n">myVect</span><span class="p">)</span> <span class="p">{</span>    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
   <span class="p">}</span>  
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The content of outputVect: "</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">:</span> <span class="n">outputVect</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
  <span class="p">}</span>  
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>As we discussed for <a href="http://sandordargo.com/blog/2019/08/14/stl-alogorithms-tutorial-part-5-copy-operations"><code class="language-plaintext highlighter-rouge">copy</code></a>, the output range either has to provide enough space for the object you want to move into it, or you can also use an inserter operator. as its name suggests it will help you to add new elements to the output vector. You can use it like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">myVect</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myVect</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">outputVect</span><span class="p">));</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In this case, you can simply use the default constructor when you create your output vector and/or the reservation of a big enough space for it.</p>

<p>A particular problem you might think off is that our output container is empty in the beginning and it grows and grows. In how many steps? We canâ€™t really know in advance thatâ€™s an implementation detail of the compiler you are using. But if your input container is big enough, you can assume that the output operator will grow in multiple steps. Resizing your vector might be expensive, it needs memory allocation, finding continuous free areas, whatever.</p>

<p>If you want to help with that, you might use <code class="language-plaintext highlighter-rouge">std::vector::reserve</code>, which will reserve a big enough memory area for the vector so that it can grow without new allocations. And if the reserved size is not enough, there wonâ€™t be a segmentation fault or any other issue, just a new allocation.</p>

<p>What we could observe is that <code class="language-plaintext highlighter-rouge">std::move</code>, just like <code class="language-plaintext highlighter-rouge">std::copy</code>, doesnâ€™t insert new elements on its own, but it overwrites existing elements in the output container. It can only insert if an inserter iterator is used.</p>

<h2 id="move_backward"><code class="language-plaintext highlighter-rouge">move_backward</code></h2>
<p><code class="language-plaintext highlighter-rouge">move_backward</code> is similar to <code class="language-plaintext highlighter-rouge">copy_backward</code>. This algorithm moves elements from the input range but starting from the back going towards the beginning.</p>

<p>Does it produce a reversed order compared to the input? No, it doesnâ€™t. It keeps order. So why does this <code class="language-plaintext highlighter-rouge">move_backward</code> exists? What is its use? The answer and the example are pretty much the same that the one for <code class="language-plaintext highlighter-rouge">copy_backward</code>.</p>

<p>Letâ€™s think about the following case.</p>

<p>We have an input range of <code class="language-plaintext highlighter-rouge">{1, 2, 3, 4, 5, 6, 7}</code> and we want to move the part <code class="language-plaintext highlighter-rouge">{1, 2, 3}</code> over <code class="language-plaintext highlighter-rouge">{2, 3, 4}</code>. To make it more visual:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>So we try to use <code class="language-plaintext highlighter-rouge">std::move</code> and the output container is the same as the input.</p>

<p>You might try this code:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span> 
 <span class="k">auto</span> <span class="n">inputNumbers</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="s">"1"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">,</span><span class="s">"4"</span><span class="p">,</span><span class="s">"5"</span><span class="p">,</span><span class="s">"6"</span><span class="p">,</span><span class="s">"7"</span><span class="p">};</span>
 <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">inputNumbers</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">inputNumbers</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">inputNumbers</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
 <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">number</span> <span class="o">:</span> <span class="n">inputNumbers</span><span class="p">)</span> <span class="p">{</span>  
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
 <span class="p">}</span> 
 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The output might be different compared to what you expected - it depends on your expectation and compiler:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> --><td class="rouge-code"><pre>


<span class="mi">1</span>
<span class="mi">5</span>
<span class="mi">6</span>
<span class="mi">7</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>So what happened?</p>

<p>First, the first number (<code class="language-plaintext highlighter-rouge">inputNumbers.begin()</code>) is moved over the second one (inputNumbers.begin()+1). So 2 is overwritten by 1 and the original 1 is cleared now. Then the second number (<code class="language-plaintext highlighter-rouge">inputNumbers.begin()+1</code>) is getting moved to the third (<code class="language-plaintext highlighter-rouge">inputNumbers.begin()+2</code>) position. But by this time, the second number is 1, so thatâ€™s what will be moved to the third. And so on.</p>

<p><em>(It is possible that youâ€™re using a compiler that is smart enough to overcome this issue)</em></p>

<p><code class="language-plaintext highlighter-rouge">std::move_backward</code> will help you to not to have this issue. First, it will move the last element of your input range and then it will one by one towards the first element, keeping the relative order in the output. Use <code class="language-plaintext highlighter-rouge">move_backward</code> when you move to the right and the input range is overlapping with the output one. Just keep in mind that when you use <code class="language-plaintext highlighter-rouge">std::move</code> as an output you add the first output position (from the beginning of the container) and with <code class="language-plaintext highlighter-rouge">std::move</code> you have to pass the last one.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span> 
  <span class="k">auto</span> <span class="n">inputNumbers</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="s">"1"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">,</span><span class="s">"4"</span><span class="p">,</span><span class="s">"5"</span><span class="p">,</span><span class="s">"6"</span><span class="p">,</span><span class="s">"7"</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">move_backward</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">inputNumbers</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">inputNumbers</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">inputNumbers</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">number</span> <span class="o">:</span> <span class="n">inputNumbers</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span> 
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="swap"><code class="language-plaintext highlighter-rouge">swap</code></h2>

<p><code class="language-plaintext highlighter-rouge">std::swap</code> doesnâ€™t hold many surprises for us. Is swaps the content of the two passed in variables. They can be of built-in types, containers, user-defined objects.</p>

<p>Before C++11, it used the copy constructor to create a temporary object and the copy assignment operator to do perform the assignments.</p>

<p>Starting from C++11 it takes advantage of move semantics when itâ€™s available.</p>

<p>Here is a very simple example of its usage:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">51</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Before swap x: "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", y: "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Before swap x: "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", y: "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="swap_ranges"><code class="language-plaintext highlighter-rouge">swap_ranges</code></h2>

<p><code class="language-plaintext highlighter-rouge">swap_ranges</code> takes three iterators as parameters. The first two defines one of the ranges to be swapped and the other range to be swapped is only characterized by its beginning. It makes sense as the two ranges should have the same length.</p>

<p>I wrote should, not must.</p>

<p>If there is nothing to swap with, there is no error, no warning. Weâ€™ll lose the what we swap out from our first range and instead, weâ€™ll get a default constructed object.</p>

<p>Which means that you <code class="language-plaintext highlighter-rouge">swap_ranges</code> can be dangerous if not used properly.</p>

<p>Here is an example you can play with:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span> 
 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">33</span><span class="p">);</span>
 <span class="c1">// change the first parameter to get vector of differnt size</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"BEFORE SWAP:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo contains:"</span><span class="p">;</span>
 <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">foo</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">foo</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bar contains:"</span><span class="p">;</span>
 <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">bar</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">bar</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>  <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

 <span class="n">std</span><span class="o">::</span><span class="n">swap_ranges</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">foo</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bar</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AFTER SWAP:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo contains:"</span><span class="p">;</span>
 <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">foo</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">foo</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>  <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bar contains:"</span><span class="p">;</span>
 <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">bar</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">bar</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>  <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="iter_swap"><code class="language-plaintext highlighter-rouge">iter_swap</code></h2>

<p><code class="language-plaintext highlighter-rouge">iter_swap</code> is very similar to swap, but while <code class="language-plaintext highlighter-rouge">swap</code> changes the contents of two elements, <code class="language-plaintext highlighter-rouge">iter_swap</code> changes the content of two iterators.</p>

<p>You can use the previous example to experiment, we just have to change one line to remove the superfluous argument and of course to change <code class="language-plaintext highlighter-rouge">swap_ranges</code> to <code class="language-plaintext highlighter-rouge">iter_swap</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span> 
 
 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">33</span><span class="p">);</span>
 <span class="c1">// change the first parameter to get vector of differnt size</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"BEFORE SWAP:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo contains:"</span><span class="p">;</span>
 <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">foo</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">foo</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bar contains:"</span><span class="p">;</span>
 <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">bar</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">bar</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>  <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>


 <span class="n">std</span><span class="o">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">bar</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AFTER SWAP:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo contains:"</span><span class="p">;</span>
 <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">foo</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">foo</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bar contains:"</span><span class="p">;</span>
 <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">bar</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">bar</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>  <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>Today, we had a peek into the algorithms that either perform move or swap operations on single elements or on containers. (Well, technically on iterators).</p>

<p>Next time weâ€™ll start learning about the transform algorithm. Stay tuned!</p>
:ET