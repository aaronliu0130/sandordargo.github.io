I"û=<p>The kata we picked was <a href="http://coderetreat.org/facilitating/activities/tdd-as-if-you-meant-it">TDD as if you meant it</a>. The rules are the ones of TDD, plus some additionals. These rules - such as write the code first at the test class and don‚Äôt move it until‚Ä¶ - are not so complicated. However you might end up using quite some time thinking about whether you are playing by the rules‚Ä¶</p>

<p>As I‚Äôm sure you observed, <a href="http://coderetreat.org/facilitating/activities/tdd-as-if-you-meant-it">TDD as if you meant it</a> doesn‚Äôt give you a specific programming problem to solve. So in fact we had to pick another kata as well. We wanted to choose something simple, something we know. We picked the <a href="https://github.com/emilybache/DiamondKata">Diamond kata</a>.</p>

<p>The first tests seemed pretty lame.</p>

<p><code class="language-plaintext highlighter-rouge">ASSERT_EQ("A\n", diamond(1));</code></p>

<p>The production code simply returned ‚ÄúA‚Äù.</p>

<p><code class="language-plaintext highlighter-rouge">ASSERT_EQ(" A \nB B\n A \n", diamond(2));</code></p>

<p>I forgot to mention I paired with a highly experienced architect of our company.</p>

<p>So the prodcution code was still dead stupid as that was the least amount of code necessary to past the test.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> --><td class="rouge-code"><pre>std::string diamond(size_t size) {
    if (size == 1)
        return "A\n";
    if (size == 2)
        return " A \nB B\n A \n";
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As we put on our blue hat for refactoring, he asked me if I see the duplication. The what? Come on, why don‚Äôt we implement a normal algorithm here? But no. Still the repetition‚Ä¶. Well‚Ä¶ We do return twice, but‚Ä¶</p>

<p>I was told to ignore refactoring for a moment, and let‚Äôs just stupidly sketch up the next test with some hardcoded responses.</p>

<p>Well‚Ä¶ Why not‚Ä¶</p>

<p><code class="language-plaintext highlighter-rouge">ASSERT_EQ("  A  \n B B \nC   C\n B B \n  A  \n", diamond(3));</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td> --><td class="rouge-code"><pre>std::string diamond(size_t size) {
    if (size == 1)
        return "A\n";
    if (size == 2)
        return " A \nB B\n A \n";
    if (size == 3)
        return "  A  \n B B \nC   C\n B B \n  A  \n";
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Okay, not let‚Äôs change a bit the outline of this function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> --><td class="rouge-code"><pre>std::string diamond(size_t iSize) {
    if (iSize == 1)
        return "A\n";
    if (iSize == 2)
        return " A \n"\
               "B B\n"\
               " A \n";
    if (iSize == 3)
        return "  A  \n"\
               " B B \n"\
               "C   C\n"\
               " B B \n"\
               "  A  \n";
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Do you see it now, Luke? To be frank, I would have already implemented the algorithm‚Ä¶ I was trained on <a href="https://www.codingame.com/multiplayer/clashofcode">fastest mode code clashes</a>‚Ä¶ I don‚Äôt say it is a virtue, but I usually take bigger leaps. This time though let‚Äôs make some baby steps.</p>

<p>We started to implement functions such as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> --><td class="rouge-code"><pre>std::string makeALineSizeOf1() {
    return "A\n"
}

std::string makeALineSizeOf2() {
    return " A \n"
}

std::string makeBLineSizeOf2() {
    return "B B\n"
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>So at that time our diamond function would have been something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> --><td class="rouge-code"><pre>std::string diamond(size_t size) {
    if (size == 1)
        return makeALineSizeOf1();
    if (size == 2)
        return "makeALineSizeOf2() +
               "makeBLineSizeOf2() +
               "makeALineSizeOf2();
    if (size == 3)
        return "makeALineSizeOf3() +
               "makeBLineSizeOf3() +
               "makeCLineSizeOf3() +
               "makeBLineSizeOf3() +
               "makeALineSizeOf3();
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Time to generalize it a bit. But don‚Äôt move too fast!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> --><td class="rouge-code"><pre>std::string makeALineSizeOf(size_t size) {
    std::stringstream ss;
    ss &lt;&lt; std::string(size - 1, ' ') &lt;&lt; 'A' &lt;&lt; std::string(size - 1, ' ');
    return ss.toStr();
}

std::string makeBLineSizeOf(size_t size) {
    std::stringstream ss;
    ss &lt;&lt; std::string(size - 2, ' ') &lt;&lt; 'B' &lt;&lt; ' ' &lt;&lt; 'B' &lt;&lt; std::string(size - 2, ' ');
    return ss.toStr();
}

std::string makeCLineSizeOf(size_t size) {
    std::stringstream ss;
    ss &lt;&lt; std::string(size - 3, ' ') &lt;&lt; 'C' &lt;&lt; '   ' &lt;&lt; 'C' &lt;&lt; std::string(size - 3, ' ');
    return ss.toStr();
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Then our diamond function looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> --><td class="rouge-code"><pre>std::string diamond(size_t size) {
    if (size == 1)
        return makeALineSizeOf(1);
    if (size == 2)
        return makeALineSizeOf(2) +
               makeBLineSizeOf(2) +
               makeALineSizeOf(2);
    if (size == 3)
        return makeALineSizeOf(3) +
               makeBLineSizeOf(3) +
               makeCLineSizeOf(3) +
               makeBLineSizeOf(3) +
               makeALineSizeOf(3);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>You start to see how it goes. By the time we reached this point our time was up, we had to return to our offices. So now it is time to finish up the algorithm:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre>std::string makeLineOfCharacterSizeOf(char character, size_t size) {
    std::stringstream ss;
    ss &lt;&lt; std::string(size - (character - 'A' + 1), ' ') &lt;&lt; character &lt;&lt; std::string(1 + 2*int(character - 'B')) &lt;&lt; character &lt;&lt;  std::string(size - (character - 'A' + 1), ' ');
    return ss.str();
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Then the diamond is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> --><td class="rouge-code"><pre>std::string diamond(size_t size) {
    if (size == 1)
        return makeALineSizeOf(1);
    if (size == 2)
        return makeALineSizeOf(2) +
               makeLineOfCharacterSizeOf('B', 2) +
               makeALineSizeOf(2);
    if (size == 3)
        return makeALineSizeOf(3) +
               makeLineOfCharacterSizeOf('B', 3) +
               makeLineOfCharacterSizeOf('C', 3) +
               makeLineOfCharacterSizeOf('B', 3) +
               makeALineSizeOf(3);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We still have a problem with ‚ÄòA‚Äô-s. But that‚Äôs fine, we can have an if in our makeLineOfCharacterSizeOf():</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> --><td class="rouge-code"><pre>std::string makeLineOfCharacterSizeOf(char character, size_t size) {
    std::stringstream ss;
    if (character == 'A') {
        ss &lt;&lt; std::string(size - (character - 'A' + 1), ' ') &lt;&lt; character &lt;&lt; std::string(size - (character - 'A' + 1), ' ');
    } else {
        ss &lt;&lt; std::string(size - (character - 'A' + 1), ' ') &lt;&lt; character &lt;&lt; std::string(1 + 2*int(character - 'B')), ' ') &lt;&lt; character &lt;&lt;  std::string(size - (character - 'A' + 1), ' ');
    }
    return ss.str();
}
</pre></td></tr></tbody></table></code></pre></div></div>
<p>There are some duplications but we‚Äôll get back to that later.</p>

<p>Let‚Äôs go back to diamond which looks like this now:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> --><td class="rouge-code"><pre>std::string diamond(size_t size) {
    if (size == 1)
        return makeLineOfCharacterSizeOf('A', 1);
    if (size == 2)
        return makeLineOfCharacterSizeOf('A', 2) +
               makeLineOfCharacterSizeOf('B', 2) +
               makeLineOfCharacterSizeOf('A', 2);
    if (size == 3)
        return makeLineOfCharacterSizeOf('A', 3) +
               makeLineOfCharacterSizeOf('B', 3) +
               makeLineOfCharacterSizeOf('C', 3) +
               makeLineOfCharacterSizeOf('B', 3) +
               makeLineOfCharacterSizeOf('A', 3);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Finish it! If you remember Mortal Kombat‚Ä¶</p>

<p>Add a new failing test case:</p>

<p><code class="language-plaintext highlighter-rouge">ASSERT_EQ("   A   \n  B B  \n C   C \nD     D\n C   C \n  B B  \n   A   \n", diamond(4));</code></p>

<p>If you understand the pattern, you can see that first you have to add some lines starting from A. Then you add the middle line of the diamond which will appear only once. Then you add the lines you already added in the first phase, but now in reverse order.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> --><td class="rouge-code"><pre>std::string diamond(size_t size) {
    std::stringstream ss;
    for(int i=0; i&lt;size-1; ++i) {
        ss &lt;&lt; makeLineOfCharacterSizeOf('A'+i, size);
    }
    ss &lt;&lt; makeLineOfCharacterSizeOf('A'+size-1, size);
    for(int i=size-2; i&gt;=0; --i) {
        ss &lt;&lt; makeLineOfCharacterSizeOf('A'+i, size);
    }
    return ss.str();
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We are almost done! Let‚Äôs put on that blue hat again and start refactoring! First get rid off all those stringsteam to string conversions, except for the last one and pass the stringstream around.</p>

<p>A bit simpler now:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td> --><td class="rouge-code"><pre>std::string diamond(size_t size) {
    std::stringstream ss;
    for(int i=0; i&lt;size-1; ++i) {
        makeLineOfCharacterSizeOf('A'+i, size, ss);
    }
    makeLineOfCharacterSizeOf('A'+size-1, size, ss);
    for(int i=size-2; i&gt;=0; --i) {
        makeLineOfCharacterSizeOf('A'+i, size, ss);
    }
    return ss.str();
}

void makeLineOfCharacterSizeOf(char character, size_t size, std::stringstream&amp; ss) {
    if (character == 'A') {
        ss &lt;&lt; std::string(size - (character - 'A' + 1), ' ') &lt;&lt; character &lt;&lt; std::string(size - (character - 'A' + 1), ' ') &lt;&lt; "\n";
    } else {
    ss &lt;&lt; std::string(size - (character - 'A' + 1), ' ') &lt;&lt; character &lt;&lt; std::string(1 + 2 * int(character - 'B'), ' ') &lt;&lt; character &lt;&lt;  std::string(size - (character - 'A' + 1), ' ') &lt;&lt; "\n";
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>There are still some duplications though, and makeLineOfCharacterSizeOf is not so readable. So let‚Äôs improve it!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> --><td class="rouge-code"><pre>void makeLineOfCharacterSizeOf(char character, size_t size, std::stringstream&amp; ss) {
    ss  &lt;&lt; std::string(size - (character - 'A' + 1), ' ');
    if (character == 'A') {
        ss &lt;&lt; character;
    } else {
        ss &lt;&lt; character &lt;&lt; std::string(1 + 2 * int(character - 'B'), ' ') &lt;&lt; character;
    }
    ss &lt;&lt; std::string(size - (character - 'A' + 1), ' ') &lt;&lt; "\n";
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Seems better, right? I think so. Let‚Äôs move forward and even change some function names.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td> --><td class="rouge-code"><pre>std::string drawSizeOf(size_t size) {
    std::stringstream ss;
    for(int i=0; i&lt;size-1; ++i) {
        addLineOfCharacterSizeOf('A'+i, size, ss);
    }
    addLineOfCharacterSizeOf('A'+size-1, size, ss);
    for(int i=size-2; i&gt;=0; --i) {
        addLineOfCharacterSizeOf('A'+i, size, ss);
    }
    return ss.str();
}

void Diamond::addLineOfCharacterSizeOf(char character, size_t size, std::stringstream&amp; ss) {
    addEdgeSpaces(character, size, ss);
    addCharacter(character, ss);
    if (character != 'A') {
        addMiddleSpaces(character, size, ss);
        addCharacter(character, ss);
    }
    addEdgeSpaces(character, size, ss);
    addNewLine(ss);
}

void Diamond::addCharacter(char character, std::stringstream&amp; ss) {
    ss &lt;&lt; character;
}
void Diamond::addEdgeSpaces(char character, size_t size, std::stringstream&amp; ss) {
    ss &lt;&lt; std::string(size - (character - 'A' + 1), ' ');
}

void Diamond::addMiddleSpaces(char character, size_t size, std::stringstream&amp; ss) {
    ss &lt;&lt; std::string(1 + 2 * int(character - 'B'), ' ');
}

void Diamond::addNewLine(std::stringstream&amp; ss) {
    ss &lt;&lt; "\n";
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It‚Äôs a bit lengthy but it is way much cleaner.</p>
:ET